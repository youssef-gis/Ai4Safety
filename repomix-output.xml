This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules/**, public/**, dist/**, .next/**, yarn.lock, package-lock.json, **/.env, **/.env.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
ARCHITECTURE.md
components.json
DOMAIN.md
environment.d.ts
eslint.config.mjs
EVOLUTION.md
next.config.ts
package.json
postcss.config.mjs
prisma/migrations/20251126221700_optimize_schema_for_safety/migration.sql
prisma/migrations/migration_lock.toml
prisma/schema.prisma
prisma/seed.ts
README.md
repomix.config.json
src/actions/cookies.ts
src/app/(marketing)/layout.tsx
src/app/(marketing)/page.tsx
src/app/(saas)/_navigation/account-dropdown.tsx
src/app/(saas)/_navigation/header.tsx
src/app/(saas)/_navigation/sidebar/components/sidebar-item.tsx
src/app/(saas)/_navigation/sidebar/components/sidebar.tsx
src/app/(saas)/_navigation/sidebar/constants.tsx
src/app/(saas)/_navigation/sidebar/types.ts
src/app/(saas)/_providers/react-query/react-query-provider.tsx
src/app/(saas)/(authenticated)/account/_navigation/tabs.tsx
src/app/(saas)/(authenticated)/account/password/page.tsx
src/app/(saas)/(authenticated)/account/profile/page.tsx
src/app/(saas)/(authenticated)/layout.tsx
src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/_navigation/tabs.tsx
src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/credentials/page.tsx
src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/invitations/page.tsx
src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/layout.tsx
src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/memberships/page.tsx
src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/subscription/page.tsx
src/app/(saas)/(authenticated)/organization/create/page.tsx
src/app/(saas)/(authenticated)/organization/page.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/_navigation/tabs.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/edit/page.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/inspections/[inspectionId]/analysis/_navigation/tabs.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/inspections/[inspectionId]/analysis/3d_viewer/page.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/inspections/[inspectionId]/analysis/analysis-layout.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/inspections/[inspectionId]/analysis/page.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/inspections/[inspectionId]/analysis/table/page.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/inspections/create/page.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/inspections/page.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/layout.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/loading.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/not-found.tsx
src/app/(saas)/(authenticated)/projects/[projectId]/page.tsx
src/app/(saas)/(authenticated)/projects/create/page.tsx
src/app/(saas)/(authenticated)/projects/error.tsx
src/app/(saas)/(authenticated)/projects/page.tsx
src/app/(saas)/api/aws/s3/supplements/[supplementId]/route.ts
src/app/(saas)/api/aws/s3/supplements/presign-upload/route.ts
src/app/(saas)/api/inngest/route.ts
src/app/(saas)/api/stripe/route.ts
src/app/(saas)/api/tiles/[organizationId]/[projectId]/[inspectionId]/[...path]/route.ts
src/app/(saas)/email-invitation/[tokenId]/page.tsx
src/app/(saas)/email-verification/page.tsx
src/app/(saas)/favicon.ico
src/app/(saas)/layout.tsx
src/app/(saas)/onboarding/page.tsx
src/app/(saas)/onboarding/select-active-organization/page.tsx
src/app/(saas)/password-forgot/page.tsx
src/app/(saas)/password-reset/[tokenId]/page.tsx
src/app/(saas)/pricing/page.tsx
src/app/(saas)/sign-in/page.tsx
src/app/(saas)/sign-up/page.tsx
src/app/(saas)/template.tsx
src/app/globals.css
src/app/layout.tsx
src/components/3D_Viewer/auto-align-tileset.ts
src/components/3D_Viewer/camera-transform.ts
src/components/3D_Viewer/Cesium.tsx
src/components/3D_Viewer/CesiumWrapper.tsx
src/components/3D_Viewer/components/defect-search.tsx
src/components/3D_Viewer/components/layer-control.tsx
src/components/3D_Viewer/debug-projection.ts
src/components/3D_Viewer/example_utils/date.ts
src/components/3D_Viewer/get-Orientation-From-Rodrigues.ts
src/components/3D_Viewer/get-Ray-From-Pixel.ts
src/components/3D_Viewer/hooks/use-drawing-manager.ts
src/components/3D_Viewer/imagery_basemaps.ts
src/components/3D_Viewer/types/cesium.ts
src/components/3D_Viewer/types/map.ts
src/components/3D_Viewer/types/position.ts
src/components/3D_Viewer/utils/camera-math.ts
src/components/3D_Viewer/utils/intersection-utils.ts
src/components/breadcrumbs.tsx
src/components/card-compact.tsx
src/components/confirm-dialogue.tsx
src/components/content.tsx
src/components/data-table.tsx
src/components/date-picker.tsx
src/components/forms/field-error.tsx
src/components/forms/form.tsx
src/components/forms/hooks/use-actions-feedback.ts
src/components/forms/submit-buttton.tsx
src/components/forms/utils/to-action-state.ts
src/components/heading.tsx
src/components/image-viewer-modal.tsx
src/components/pagination/constants.ts
src/components/pagination/pagination.tsx
src/components/pagination/types.ts
src/components/placeholder.tsx
src/components/portal.tsx
src/components/redirect-toast.tsx
src/components/search-input.tsx
src/components/sort-select.tsx
src/components/spinner.tsx
src/components/theme/theme-provider.tsx
src/components/theme/theme-switcher.tsx
src/components/ui/alert-dialog.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/breadcrumb.tsx
src/components/ui/button.tsx
src/components/ui/calendar.tsx
src/components/ui/card.tsx
src/components/ui/checkbox.tsx
src/components/ui/dialog.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/popover.tsx
src/components/ui/resizable.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/skeleton.tsx
src/components/ui/sonner.tsx
src/components/ui/switch.tsx
src/components/ui/table.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/emails/auth/email-verification.tsx
src/emails/invitation/email-invitation.tsx
src/emails/password/email-password-reset.tsx
src/features/analysis/actions/get-analysis.ts
src/features/analysis/components/analysis_3d_viewer.tsx
src/features/analysis/components/analytics-drawer.tsx
src/features/analysis/components/inspection-analytics.tsx
src/features/analysis/components/inspector-panel.tsx
src/features/auth/actions/email-verification-resend.ts
src/features/auth/actions/email-verification.ts
src/features/auth/actions/sign-in.ts
src/features/auth/actions/sign-out.ts
src/features/auth/actions/sign-up.ts
src/features/auth/components/email-verification-form.tsx
src/features/auth/components/email-verification-resend-form.tsx
src/features/auth/components/sign-in-form.tsx
src/features/auth/components/sign-up-form.tsx
src/features/auth/emails/send-email-verification.tsx
src/features/auth/events/event-email-verification.ts
src/features/auth/hooks/use-auth.ts
src/features/auth/queries/get-auth-or-rerdirect.ts
src/features/auth/queries/get-auth.ts
src/features/auth/utils/can-resend-verification-email.ts
src/features/auth/utils/generate-email-verification-code.ts
src/features/auth/utils/is-owner.ts
src/features/auth/utils/session-cookie.ts
src/features/auth/utils/validate-email-verification-code.ts
src/features/constants.tsx
src/features/credential/actions/create-credential.ts
src/features/credential/components/credential-create-button.tsx
src/features/credential/components/credential-list.tsx
src/features/credential/queries/get-credentials.ts
src/features/credential/utils/generate-credential.ts
src/features/defects/actions/delete-detection.ts
src/features/defects/actions/upsert-detection.ts
src/features/defects/columns.tsx
src/features/defects/components/defect-form-upsert.tsx
src/features/defects/data/connect-referenced-defects.ts
src/features/defects/data/create-defect.ts
src/features/defects/data/index.ts
src/features/defects/defect-table.tsx
src/features/defects/permissions/get-defect-permissions.ts
src/features/defects/queries/get-defects.ts
src/features/defects/search-params.ts
src/features/defects/types.ts
src/features/inspection/actions/delete-inspection.ts
src/features/inspection/actions/toggle-permission.ts
src/features/inspection/actions/upsert-inspection.ts
src/features/inspection/components/inspection-actions.tsx
src/features/inspection/components/inspection-context-bar.tsx
src/features/inspection/components/inspection-delete-button.tsx
src/features/inspection/components/inspection-form-upsert.tsx
src/features/inspection/components/inspection-item.tsx
src/features/inspection/components/inspection-list.tsx
src/features/inspection/components/inspection-more-menu.tsx
src/features/inspection/components/inspection-pdf-template.tsx
src/features/inspection/components/permission-toggle.tsx
src/features/inspection/data/connect-referenced-inspections.ts
src/features/inspection/data/create-inspection.ts
src/features/inspection/data/index.ts
src/features/inspection/events/event-inspection-created.ts
src/features/inspection/permissions/get-inspection-permissions.ts
src/features/inspection/queries/get-admin-or-redirect.ts
src/features/inspection/queries/get-inspection.ts
src/features/inspection/queries/get-inspections.ts
src/features/inspection/queries/get-membership.ts
src/features/inspection/types.ts
src/features/invitation/actions/accept-invitation.ts
src/features/invitation/actions/create-invitation.ts
src/features/invitation/actions/delete-invitation.ts
src/features/invitation/components/invitation-accept-form.tsx
src/features/invitation/components/invitation-create-button.tsx
src/features/invitation/components/invitation-delete-button.tsx
src/features/invitation/components/invitation-list.tsx
src/features/invitation/emails/send-email-invitation.tsx
src/features/invitation/events/event-invitation-created.ts
src/features/invitation/queries/get-invitations.ts
src/features/invitation/utils/generate-invitation-link.ts
src/features/membership/actions/delete-membership.ts
src/features/membership/actions/toggle-permission.ts
src/features/membership/actions/update-membership-role.ts
src/features/membership/components/membership-delete-button.tsx
src/features/membership/components/membership-list.tsx
src/features/membership/components/membership-more-menu.tsx
src/features/membership/components/permission-manager.tsx
src/features/membership/components/permission-toggle.tsx
src/features/membership/queries/get-active-membership.ts
src/features/membership/queries/get-admin-or-redirect.ts
src/features/membership/queries/get-membership.ts
src/features/membership/queries/get-memberships.ts
src/features/organization/actions/create-organization.ts
src/features/organization/actions/delete-organization.ts
src/features/organization/actions/switch-organization.ts
src/features/organization/components/organization-create-form.tsx
src/features/organization/components/organization-delete-button.tsx
src/features/organization/components/organization-list.tsx
src/features/organization/components/organization-switch-button.tsx
src/features/organization/events/event-organization-created.ts
src/features/organization/queries/get-active-organization.ts
src/features/organization/queries/get-organizations-by-user.ts
src/features/password/actions/password-change.ts
src/features/password/actions/password-forgot.ts
src/features/password/actions/password-reset.ts
src/features/password/components/password-change-form.tsx
src/features/password/components/password-forgot-form.tsx
src/features/password/components/password-reset-form.tsx
src/features/password/emails/send-email-password-resend.tsx
src/features/password/events/event-password-reset.ts
src/features/password/utils/generate-password-reset-link.ts
src/features/password/utils/hash-and-verify.ts
src/features/profile/actions/update-profile.ts
src/features/profile/components/profile-form.tsx
src/features/profile/queries/get-user-profile.ts
src/features/project/actions/delete-project.ts
src/features/project/actions/update-project-status.ts
src/features/project/actions/upsert-project.ts
src/features/project/components/project-form-upsert.tsx
src/features/project/components/project-item.tsx
src/features/project/components/project-list.tsx
src/features/project/components/project-more-menu.tsx
src/features/project/components/project-pagination.tsx
src/features/project/components/project-search-input.tsx
src/features/project/components/project-sort-select.tsx
src/features/project/components/project-stats.tsx
src/features/project/components/project-trend-chart.tsx
src/features/project/components/referenced-inspections.tsx
src/features/project/data/connect-referenced-inspections.ts
src/features/project/data/disconnect-referenced-inspections.ts
src/features/project/data/index.ts
src/features/project/permissions/get-project-permissions.ts
src/features/project/queries/get-project.ts
src/features/project/queries/get-projects.ts
src/features/project/queries/get-referenced-inspections.ts
src/features/project/search-params.ts
src/features/project/service/disconnect-referenced-inspections.ts
src/features/project/service/index.ts
src/features/project/types.ts
src/features/stripe/actions/create-checkout-session.ts
src/features/stripe/actions/create-customer-portal.ts
src/features/stripe/components/checkout-session-form.tsx
src/features/stripe/components/customer-portal-form.tsx
src/features/stripe/components/products.tsx
src/features/stripe/data/delete-subscription.ts
src/features/stripe/data/index.ts
src/features/stripe/data/update-subscription.ts
src/features/stripe/queries/get-stripe-customer.ts
src/features/stripe/queries/get-stripe-provisioning.ts
src/features/supplements/actions/create-attachments.ts
src/features/supplements/actions/delete-attachment.ts
src/features/supplements/components/attachment-create-button.tsx
src/features/supplements/components/attachment-create-form.tsx
src/features/supplements/components/attachment-delete-button.tsx
src/features/supplements/components/attachment-item.tsx
src/features/supplements/components/attachment-list.tsx
src/features/supplements/components/attachments.tsx
src/features/supplements/constants.ts
src/features/supplements/data/create-attachment.ts
src/features/supplements/data/get-attachment.ts
src/features/supplements/data/index.ts
src/features/supplements/dto/attachment-subject-dto.ts
src/features/supplements/events/event-attachment-deleted.ts
src/features/supplements/queries/get-attachments.ts
src/features/supplements/schema/files.ts
src/features/supplements/service/create-attachments.ts
src/features/supplements/service/get-attachment-subject.ts
src/features/supplements/service/index.ts
src/features/supplements/types.ts
src/features/supplements/utils/generate-s3-key.ts
src/features/supplements/utils/size.ts
src/lib/aws.ts
src/lib/big.ts
src/lib/inngest.ts
src/lib/lucia.ts
src/lib/prisma.ts
src/lib/resend.ts
src/lib/stripe/index.ts
src/lib/stripe/seed.ts
src/lib/supabase.ts
src/lib/utils.ts
src/middleware.ts
src/path.ts
src/utils/crypto.ts
src/utils/currency.tsx
src/utils/find-ids-from-text.ts
src/utils/get-active-path.ts
src/utils/url.ts
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="repomix.config.json">
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml"
  },
  "ignore": {
    "useGitignore": true,
    "customPatterns": [
      "node_modules/**",
      "public/**",
      "dist/**",
      ".next/**",
      "yarn.lock",
      "package-lock.json",
      "**/.env",       
      "**/.env.*"      
    ]
  }
}
</file>

<file path="src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }
</file>

<file path="src/features/analysis/components/analytics-drawer.tsx">
"use client";

import { useEffect, useState } from "react";
import { Detection } from "@prisma/client";
import { X, ChevronDown, BarChart3 } from "lucide-react";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { InspectionAnalytics } from "./inspection-analytics";

interface AnalyticsDrawerProps {
  isOpen: boolean;
  onClose: () => void;
  detections: Detection[];
}

export function AnalyticsDrawer({ isOpen, onClose, detections }: AnalyticsDrawerProps) {
  const [isVisible, setIsVisible] = useState(false);

  // Animate the drawer sliding in/out
  useEffect(() => {
    if (isOpen) {
      setIsVisible(true);
    } else {
      const timer = setTimeout(() => setIsVisible(false), 300); // Wait for transition
      return () => clearTimeout(timer);
    }
  }, [isOpen]);

  if (!isVisible && !isOpen) return null;

  return (
    <div
      className={cn(
        "absolute bottom-0 left-0 right-0 z-30 bg-background/95 backdrop-blur-md border-t border-border shadow-2xl transition-transform duration-300 ease-in-out flex flex-col",
        isOpen ? "translate-y-0" : "translate-y-full",
        "h-[320px] md:h-[350px]" // Fixed height for the drawer
      )}
    >
      {/* --- HEADER --- */}
      <div className="flex items-center justify-between px-6 py-3 border-b border-border/50 bg-secondary/20">
        <div className="flex items-center gap-2">
          <div className="p-1.5 bg-blue-100 dark:bg-blue-900/30 rounded-md">
            <BarChart3 className="w-4 h-4 text-blue-600 dark:text-blue-400" />
          </div>
          <h3 className="font-semibold text-sm">Project Analytics</h3>
          <span className="text-xs text-muted-foreground ml-2 border-l border-border pl-2">
            Based on {detections.length} total findings
          </span>
        </div>
        
        <div className="flex items-center gap-2">
          <Button 
            variant="ghost" 
            size="sm" 
            className="h-8 w-8 p-0 hover:bg-secondary" 
            onClick={onClose}
          >
            <ChevronDown className="w-4 h-4" />
          </Button>
        </div>
      </div>

      {/* --- CONTENT --- */}
      <div className="flex-1 p-4 overflow-hidden">
        {/* We reuse your existing chart component here */}
        <InspectionAnalytics />
      </div>
    </div>
  );
}
</file>

<file path="src/features/analysis/components/inspector-panel.tsx">
"use client";

import { useState } from "react";
import { Detection, Supplement } from "@prisma/client";
import { 
  ChevronLeft, 
  X, 
  Search, 
  Filter, 
  AlertTriangle,
  FileText,
  History,
  Camera,
  Plus,
  Download
} from "lucide-react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
// Removed ScrollArea import to fix clipping issues
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { cn } from "@/lib/utils";

import { DetectionUpsertForm } from "@/features/defects/components/defect-form-upsert";

import { DefectCandidate } from "@/components/3D_Viewer/hooks/use-drawing-manager";
import { useRouter } from "next/navigation";

interface InspectorPanelProps {
  inspectionId: string;
  projectId: string;
  defects: Detection[];
  camerasUrl: string;
  proxyBaseUrl: string;
  canDeleteDefect: boolean;
  canEditDefect: boolean;
  focusedDefectId: string | null;
  draftDefect?: { 
    position: { x: number, y: number, z: number }; 
  } | null; 
  onSelectDefect: (id: string | null) => void;
  onClose: () => void;
}

const EvidenceFiles = ({ defect }: { defect: Detection & { attachments?: Supplement[] } }) => {
  
  if (!defect.attachments || defect.attachments.length === 0) {
    return (
        <div className="text-sm text-muted-foreground italic p-4 text-center border border-dashed rounded-md">
            No files attached to this defect.
        </div>
    );
  }

  return (
    <div className="space-y-3 mb-6">
      <h4 className="text-xs font-semibold text-muted-foreground uppercase tracking-wider mb-2">
          Attached Files ({defect.attachments.length})
      </h4>
      
      <div className="flex flex-col gap-2">
        {defect.attachments.map((file) => (
          <div key={file.id} className="flex items-center justify-between p-2 rounded-md border border-border bg-card hover:bg-accent/50 transition-colors group">
            
            <div className="flex items-center gap-3 min-w-0">
                {/* Icon based on file type (simple check) */}
                {file.name.endsWith('.pdf') ? (
                  <FileText className="w-4 h-4 text-red-500 shrink-0" />
                ) : (
                  <div className="w-4 h-4 bg-blue-100 text-blue-600 rounded flex items-center justify-center shrink-0 text-[10px] font-bold">IMG</div>
                )}
                
                <div className="flex flex-col min-w-0">
                    <a 
                        href={`/api/aws/s3/supplements/${file.id}`} 
                        target="_blank" 
                        rel="noreferrer"
                        className="text-sm font-medium truncate text-foreground hover:underline hover:text-blue-600"
                    >
                        {file.name}
                    </a>
                    <span className="text-[10px] text-muted-foreground">
                        {new Date(file.createdAt).toLocaleDateString()}
                    </span>
                </div>
            </div>

            <a 
                href={`/api/aws/s3/supplements/${file.id}`} 
                target="_blank" 
                rel="noreferrer"
                className="p-1.5 text-muted-foreground hover:text-foreground rounded-md hover:bg-background/80"
                title="Download"
            >
               <Download className="w-4 h-4" />
            </a>

          </div>
        ))}
      </div>
    </div>
  );
};

const DefectCard = ({ defect, onClick }: { defect: Detection; onClick: () => void }) => {
  const severityColors: Record<string, string> = {
    CRITICAL: "bg-red-100 text-red-700 border-red-200 dark:bg-red-900/30 dark:text-red-400 dark:border-red-900",
    HIGH: "bg-orange-100 text-orange-700 border-orange-200 dark:bg-orange-900/30 dark:text-orange-400 dark:border-orange-900",
    MEDIUM: "bg-yellow-100 text-yellow-700 border-yellow-200 dark:bg-yellow-900/30 dark:text-yellow-400 dark:border-yellow-900",
    LOW: "bg-slate-100 text-slate-700 border-slate-200 dark:bg-slate-800 dark:text-slate-400 dark:border-slate-700",
  };

  const badgeColor = severityColors[defect.severity || "LOW"] || severityColors["LOW"];

  return (
    <div 
      onClick={onClick}
      className="group flex flex-col gap-2 p-3 rounded-lg border border-border bg-card hover:bg-accent/50 cursor-pointer transition-all shadow-sm"
    >
      <div className="flex justify-between items-start">
        <span className="font-mono text-[10px] text-muted-foreground uppercase tracking-wider">
          ID: #{defect.id.slice(-4)}
        </span>
        <Badge variant="outline" className={cn("text-[10px] px-1.5 py-0 border", badgeColor)}>
          {defect.severity}
        </Badge>
      </div>
      
      <div className="flex items-center gap-2">
        <AlertTriangle className="w-3.5 h-3.5 text-muted-foreground" />
        <span className="font-semibold text-sm text-foreground">
          {defect.type?.replace("_", " ")}
        </span>
      </div>

      <div className="flex items-center gap-2 text-xs text-muted-foreground mt-1">
        <div className={cn(
          "w-1.5 h-1.5 rounded-full",
          defect.status === "RESOLVED" ? "bg-green-500" : 
          defect.status === "IN_PROGRESS" ? "bg-orange-500" : "bg-blue-500"
        )} />
        {defect.status?.replace("_", " ")}
      </div>
    </div>
  );
};

export function InspectorPanel({
  inspectionId,
  projectId,
  defects,
  camerasUrl,
  proxyBaseUrl,
  canDeleteDefect,
  canEditDefect,
  focusedDefectId,
  draftDefect,
  onSelectDefect,
  onClose
}: InspectorPanelProps) {
  
  const [searchQuery, setSearchQuery] = useState("");
  const router = useRouter();
  
  const [defectToEditImage, setDefectToEditImage] = useState<Detection | null>(null);  
  const [defectCandidate, setDefectCandidate] = useState<DefectCandidate | null>(null);
  const [editingDefect, setEditingDefect] = useState<Detection | null>(null);
  const handleOpenImageEdit = (defect: Detection) => {
        setDefectToEditImage(defect);
    };
  
  const handleFormSuccess = () => {
        setDefectCandidate(null);
        setEditingDefect(null);
        router.refresh();
    };

  const filteredDefects = defects.filter(d => 
    d.type?.toLowerCase().includes(searchQuery.toLowerCase()) || 
    d.id.includes(searchQuery)
  );

  // Determine if we are in "Create Mode"
  const isCreating = !!draftDefect;
  const activeDefect = defects.find(d => d.id === focusedDefectId);

  // If Creating, show Form. If Active, show Details. Else, show List.
  const showDetailView = activeDefect || isCreating;

  return (
    <div className="flex flex-col h-full w-full bg-background/95 backdrop-blur-sm">
      
      {/* HEADER */}
      <div className="flex-none h-14 px-4 border-b border-border flex items-center justify-between bg-card/50">
        {showDetailView ? (
          <div className="flex items-center gap-1 overflow-hidden">
            <Button variant="ghost" size="icon" onClick={() => onSelectDefect(null)} className="-ml-2 h-8 w-8">
              <ChevronLeft className="w-4 h-4" />
            </Button>
            <div className="flex flex-col">
              <span className="font-semibold text-sm truncate">
                {isCreating ? "New Defect" : activeDefect?.type?.replace("_", " ")}
              </span>
              <span className="text-[10px] text-muted-foreground font-mono">
                {isCreating ? "Draft" : `#${activeDefect?.id.slice(0, 8)}`}
              </span>
            </div>
          </div>
        ) : (
          <div className="font-semibold text-sm">Inspector Panel</div>
        )}
        
        <Button variant="ghost" size="icon" onClick={onClose} className="h-8 w-8">
          <X className="w-4 h-4" />
        </Button>
      </div>

      {/* BODY */}
      <div className="flex-1 overflow-hidden relative flex flex-col">
        {showDetailView ? (
          // === DETAIL VIEW ===
          <div className="h-full flex flex-col">
            {/* A. VIEW/EDIT EXISTING DEFECT */}
            {activeDefect && !isCreating ? (
            <>
              {/* Status Header */}
              <div className="flex-none px-4 py-3 border-b border-border bg-card/30 space-y-2">
                <div className="flex justify-between items-center text-xs">
                    <span className="text-muted-foreground">Status:</span>
                    <Badge variant={activeDefect?.status === 'RESOLVED' ? 'default' : 'secondary'} className="uppercase text-[10px]">
                      {activeDefect?.status?.replace('_', ' ')}
                    </Badge>
                </div>
                {/* <div className="flex justify-between items-center text-xs">
                    <span className="text-muted-foreground">Assigned to:</span>
                    <span className="font-medium">Maintenance Team A</span>
                </div> */}
              </div>

              <Tabs defaultValue="evidence" className="flex-1 flex flex-col min-h-0">
                <div className="flex-none px-4 pt-2 border-b border-border">
                  <TabsList className="w-full grid grid-cols-2 bg-transparent p-0">
                    <TabsTrigger 
                      value="evidence" 
                      className="text-xs data-[state=active]:bg-transparent data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none rounded-none pb-2"
                    >
                      Evidence
                    </TabsTrigger>
                    <TabsTrigger 
                      value="history" 
                      className="text-xs data-[state=active]:bg-transparent data-[state=active]:border-b-2 data-[state=active]:border-primary data-[state=active]:shadow-none rounded-none pb-2"
                    >
                      History
                    </TabsTrigger>
                  </TabsList>
                </div>
                <div className="flex-1 overflow-y-auto">
                  <div className="p-4 pb-24"> {/* Added heavy bottom padding to ensure button visibility */}
                      <TabsContent value="evidence" className="mt-0 space-y-6">
                          {activeDefect && <EvidenceFiles defect={activeDefect} />} 
                          <div className="h-px bg-border w-full" />
                          <div className="space-y-2">
                              <h4 className="text-xs font-semibold text-muted-foreground uppercase tracking-wider">
                                  Technical Data
                              </h4>
                              <DetectionUpsertForm 
                                  detection={activeDefect}
                                  inspectionId={inspectionId}
                                  projectId={projectId}
                                  geometry={undefined}
                                  canDelete={canDeleteDefect} 
                                  canEdit={canEditDefect}
                                  onCancel={() => onSelectDefect(null)}
                                  onFormSuccess={handleFormSuccess}
                                  onOpenImage={handleOpenImageEdit}
                              />
                          </div>
                      </TabsContent>
                      
                      <TabsContent value="history" className="mt-0 pt-4">
                          <div className="border-l-2 border-border ml-2 space-y-6">
                              {[
                                  { date: "Jan 10", user: "System", action: "Created defect" },
                                  { date: "Jan 12", user: "User", action: "Uploaded report" }
                              ].map((log, i) => (
                                  <div key={i} className="relative pl-6">
                                      <div className="absolute -left-[5px] top-1.5 w-2.5 h-2.5 rounded-full bg-border" />
                                      <div className="text-xs text-muted-foreground mb-0.5">{log.date}</div>
                                      <div className="text-sm">
                                          <span className="font-medium text-foreground">{log.user}: </span>
                                          {log.action}
                                      </div>
                                  </div>
                              ))}
                          </div>
                      </TabsContent>
                  </div>
                </div>
              </Tabs>
            </>):(
              /* B. CREATE NEW DEFECT FORM */  
            <>
            <div className="p-4 overflow-y-auto">
                 <div className="mb-4 p-3 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md">
                    <p className="text-xs text-blue-700 dark:text-blue-300">
                        New defect draft at location: <br/>
                        <span className="font-mono">
                            {draftDefect?.position.x.toFixed(2)}, {draftDefect?.position.y.toFixed(2)}
                        </span>
                    </p>
                 </div>
                 
                 <DetectionUpsertForm 
                    inspectionId={inspectionId}
                    projectId={projectId}
                    geometry={draftDefect ? {
                        type: 'point',
                        coordinates: [draftDefect.position]
                    } : undefined}
                    canDelete={canDeleteDefect} 
                    canEdit={canEditDefect}
                    onCancel={() => {
                        // Clear draft when cancelling
                        onSelectDefect(null); 
                    }}
                    onFormSuccess={() => {
                        handleFormSuccess();
                        onClose(); // Close panel after create
                    }}
                    onOpenImage={() => {}} 
                />
            </div>
            </>)}
 
          </div>
        ) : (
          // === LIST VIEW ===
          <div className="h-full flex flex-col">
            <div className="flex-none p-4 pb-2">
              <div className="relative">
                <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Search defects..."
                  className="pl-9 bg-secondary/50 border-transparent focus:bg-background transition-all"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                />
              </div>
            </div>

            <div className="flex-none px-4 py-2 flex items-center justify-between text-xs text-muted-foreground border-b border-border/50 bg-muted/20">
              <span>{filteredDefects.length} Issues Found</span>
              <Button variant="ghost" size="sm" className="h-6 gap-1 text-xs px-2 hover:bg-background">
                <Filter className="w-3 h-3" /> Filter
              </Button>
            </div>

            {/* CHANGE: Replaced ScrollArea here as well for consistency */}
            <div className="flex-1 overflow-y-auto">
              <div className="p-4 flex flex-col gap-3 pb-20">
                {filteredDefects.length === 0 ? (
                  <div className="flex flex-col items-center justify-center py-12 text-muted-foreground">
                    <Search className="w-10 h-10 mb-3 opacity-20" />
                    <p className="text-sm">No defects found</p>
                  </div>
                ) : (
                  filteredDefects.map((defect) => (
                    <DefectCard 
                      key={defect.id} 
                      defect={defect} 
                      onClick={() => onSelectDefect(defect.id)} 
                    />
                  ))
                )}
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/features/defects/data/connect-referenced-defects.ts">
import { prisma } from "@/lib/prisma";

export const connectReferencedDefects = async (
  defectId: string,
  defectIds: string[]
) => {
  await prisma.detection.update({
    where: {
      id: defectId,
    },
    data: {
      referencedDetections: {
        connect: defectIds.map((id) => ({
          id,
        })),
      },
    },
  });
};
</file>

<file path="src/features/defects/data/create-defect.ts">
import { DetectionSeverity, DetectionStatus, DetectionType, Prisma } from "@prisma/client";
import { prisma } from "@/lib/prisma";

type CreateDefectArgs = {
  id: string;
  createdAt: Date;
  type: DetectionType;
  severity: DetectionSeverity;
  status: DetectionStatus;
  notes: string;
  locationOn3dModel: Prisma.InputJsonValue;
  annotation2D: Prisma.InputJsonValue;
  sourceImageId: string;
  analysisId: string;
};

type IncludeOptions = {
  includeAnalysis?: boolean;
};

export async function upsertDetection<T extends IncludeOptions>({
  id,
  createdAt,
  type,
  severity,
  status,
  notes,
  locationOn3dModel,
  annotation2D,
  sourceImageId,
  analysisId,
  options,
}: CreateDefectArgs & { options?: T }) {
  
  const include = {
    ...(options?.includeAnalysis && {
      analysis: {
        include: {
          inspection: {
            include: {
              project: true,
            },
          },
        },
      },
    }),
  };

  return prisma.detection.upsert({
    where: { id },
    update: {
      type,
      severity,
      status,
      notes,
      locationOn3dModel: locationOn3dModel ?? Prisma.DbNull,
      annotation2D: annotation2D ?? Prisma.DbNull,
      sourceImageId,
    },
    create: {
      id,
      createdAt,
      type,
      severity,
      status,
      notes,
      locationOn3dModel: locationOn3dModel ?? Prisma.DbNull,
      annotation2D: annotation2D ?? Prisma.DbNull,
      sourceImageId,
      analysisId,
    },
    include,
  });
}
</file>

<file path="ARCHITECTURE.md">
# Architecture Overview – Ai4Safety

## 1. System Overview
Ai4Safety is a multi-tenant SaaS for building inspection using drone imagery.
Core workflow:
Images → AI processing → Defects → Review → Analytics

## 2. High-Level Components
- Frontend (Next.js): UI, annotation, 3D/GS viewer
- Backend (FastAPI): API, auth, domain logic
- Processing Workers: AI inference, precomputation
- Storage: Images, splats, derived artifacts
- Database: Canonical inspection data

## 3. Data Flow (Critical)
1. User uploads images
2. Images stored in object storage
3. Async job triggers AI pipeline
4. AI outputs defects + metadata
5. Results stored as derived data
6. Frontend consumes precomputed results

## 4. Sync vs Async
- Sync: auth, CRUD, annotations
- Async: AI inference, analytics, model generation

## 5. Performance Strategy
- Heavy computations are precomputed
- Dashboard queries are read-only
- No AI inference in request/response path

## 6. Security & Tenancy
- All domain entities scoped by tenant_id
- No cross-tenant reads
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="DOMAIN.md">
# Domain Model – Ai4Safety

## Core Entities

### Tenant
Represents a company.
All data is tenant-scoped.

### Inspection
A logical inspection session.
Owns images, defects, annotations.

### Image
Raw uploaded drone image.
Source of truth for visual inspection.

### Defect
A detected or manually created issue.
Always references at least one Image.

### Annotation
User-created markup on an image.
Can be linked to a Defect.

## Source of Truth Rules
- Images are immutable
- Defects are derived data
- 3D models are visualization artifacts
- Analytics are precomputed and disposable

## Important Constraints
- Same defect may appear in multiple images
- Annotations do NOT duplicate across images
- Defects unify multiple image observations
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="EVOLUTION.md">
# System Evolution – Ai4Safety

## Current Phase
MVP → Early enterprise pilots

## Known Technical Debt
- Some inspection logic lives in frontend
- Cesium still partially present (planned removal)
- Analytics schema will change

## Planned Evolutions
- Move to 3DGS + PlayCanvas
- Image-first annotation as primary UX
- Full precomputation of analytics
- Event-driven processing pipeline

## Non-Goals
- Real-time AI inference
- Full BIM replacement
</file>

<file path="prisma/migrations/20251126221700_optimize_schema_for_safety/migration.sql">
-- CreateEnum
CREATE TYPE "StripeSubscriptionStatus" AS ENUM ('active', 'incomplete', 'incomplete_expired', 'past_due', 'canceled', 'unpaid', 'trialing', 'paused');

-- CreateEnum
CREATE TYPE "InvitationStatus" AS ENUM ('PENDING', 'ACCEPTED_WITHOUT_ACCOUNT');

-- CreateEnum
CREATE TYPE "MembershipRole" AS ENUM ('ADMIN', 'MEMBER');

-- CreateEnum
CREATE TYPE "SupplementType" AS ENUM ('DRONE_IMAGE', 'ORTHOMOSAIC', 'POINT_CLOUD', 'THREE_D_MODEL', 'INSPECTION_REPORT', 'THERMAL_MAP');

-- CreateEnum
CREATE TYPE "SupplementEntity" AS ENUM ('INSPECTION', 'ANALYSIS', 'COMMENT');

-- CreateEnum
CREATE TYPE "JobStatus" AS ENUM ('PENDING', 'RUNNING', 'COMPLETED', 'FAILED');

-- CreateEnum
CREATE TYPE "AnalysisType" AS ENUM ('THREE_D_MODELING', 'CRACK_DETECTION', 'THERMAL_ANALYSIS');

-- CreateEnum
CREATE TYPE "ProjectStatus" AS ENUM ('ACTIVE', 'ON_HOLD', 'COMPLETED', 'ARCHIVED');

-- CreateEnum
CREATE TYPE "InspectionStatus" AS ENUM ('SCHEDULED', 'IN_PROGRESS', 'DATA_UPLOADING', 'COMPLETED', 'FAILED');

-- CreateEnum
CREATE TYPE "AnalysisStatus" AS ENUM ('PENDING', 'RUNNING', 'COMPLETED', 'FAILED');

-- CreateEnum
CREATE TYPE "DetectionType" AS ENUM ('SPALLING_CRACK', 'EFFLORESCENCE', 'WATER_DAMAGE', 'CORROSION_STAIN', 'INSULATION_FAULT');

-- CreateEnum
CREATE TYPE "DetectionSeverity" AS ENUM ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL');

-- CreateEnum
CREATE TYPE "DetectionStatus" AS ENUM ('NEW', 'ACKNOWLEDGED', 'IN_PROGRESS', 'RESOLVED');

-- CreateTable
CREATE TABLE "Organization" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),
    "name" TEXT NOT NULL,
    "stripeCustomerId" TEXT,

    CONSTRAINT "Organization_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StripeCustomer" (
    "organizationId" TEXT NOT NULL,
    "customerId" TEXT NOT NULL,
    "subscriptionId" TEXT,
    "subscriptionStatus" "StripeSubscriptionStatus",
    "productId" TEXT,
    "priceId" TEXT,
    "eventAt" INTEGER
);

-- CreateTable
CREATE TABLE "Credential" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "secretHash" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "lastUsed" TIMESTAMP(3),
    "organizationId" TEXT NOT NULL,

    CONSTRAINT "Credential_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Invitation" (
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "email" TEXT NOT NULL,
    "tokenHash" TEXT NOT NULL,
    "organizationId" TEXT NOT NULL,
    "invitedByUserId" TEXT,
    "status" "InvitationStatus" NOT NULL DEFAULT 'PENDING',

    CONSTRAINT "Invitation_pkey" PRIMARY KEY ("organizationId","email")
);

-- CreateTable
CREATE TABLE "Membership" (
    "userId" TEXT NOT NULL,
    "organizationId" TEXT NOT NULL,
    "joinedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "isActive" BOOLEAN NOT NULL,
    "membershipRole" "MembershipRole" NOT NULL DEFAULT 'MEMBER',
    "canDeleteProject" BOOLEAN NOT NULL DEFAULT true,

    CONSTRAINT "Membership_pkey" PRIMARY KEY ("organizationId","userId")
);

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "username" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "emailVerified" BOOLEAN NOT NULL DEFAULT false,
    "passwordHash" TEXT NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "AuditLog" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "action" TEXT NOT NULL,
    "entityType" TEXT NOT NULL,
    "entityId" TEXT NOT NULL,
    "userId" TEXT,
    "organizationId" TEXT NOT NULL,
    "details" JSONB,

    CONSTRAINT "AuditLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "EmailVerificationToken" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "code" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "email" TEXT NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "EmailVerificationToken_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "PasswordResetToken" (
    "tokenHash" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "PasswordResetToken_pkey" PRIMARY KEY ("tokenHash")
);

-- CreateTable
CREATE TABLE "Session" (
    "id" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Session_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Comment" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "content" VARCHAR(1024) NOT NULL,
    "userId" TEXT,
    "inspectionId" TEXT,

    CONSTRAINT "Comment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Project" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),
    "name" TEXT NOT NULL,
    "address" TEXT,
    "metadata" JSONB,
    "description" TEXT,
    "status" "ProjectStatus" NOT NULL DEFAULT 'ACTIVE',
    "creatorId" TEXT,
    "organizationId" TEXT NOT NULL,

    CONSTRAINT "Project_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Inspection" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "inspectionDate" TIMESTAMP(3) NOT NULL,
    "status" "InspectionStatus" NOT NULL DEFAULT 'SCHEDULED',
    "weatherConditions" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "projectId" TEXT NOT NULL,
    "conductedByUserId" TEXT,

    CONSTRAINT "Inspection_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Job" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "startedAt" TIMESTAMP(3),
    "completedAt" TIMESTAMP(3),
    "type" "AnalysisType" NOT NULL,
    "status" "JobStatus" NOT NULL DEFAULT 'PENDING',
    "logs" TEXT,
    "errorMessage" TEXT,
    "attemptCount" INTEGER NOT NULL DEFAULT 0,
    "inspectionId" TEXT NOT NULL,

    CONSTRAINT "Job_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Analysis" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "summary" JSONB,
    "jobId" TEXT NOT NULL,
    "inspectionId" TEXT NOT NULL,

    CONSTRAINT "Analysis_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Detection" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "type" "DetectionType",
    "severity" "DetectionSeverity",
    "status" "DetectionStatus" DEFAULT 'NEW',
    "confidenceScore" DOUBLE PRECISION,
    "notes" TEXT,
    "locationOn3dModel" JSONB,
    "analysisId" TEXT NOT NULL,

    CONSTRAINT "Detection_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "DetectionOnImage" (
    "detectionId" TEXT NOT NULL,
    "supplementId" TEXT NOT NULL,
    "supplementPath" TEXT NOT NULL,
    "boundingBox" JSONB,

    CONSTRAINT "DetectionOnImage_pkey" PRIMARY KEY ("detectionId","supplementId")
);

-- CreateTable
CREATE TABLE "Supplement" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "name" TEXT NOT NULL,
    "entity" "SupplementEntity" NOT NULL,
    "url" TEXT,
    "sizeMB" DOUBLE PRECISION,
    "format" TEXT,
    "metadata" JSONB,
    "inspectionId" TEXT,
    "analysisId" TEXT,
    "commentId" TEXT,

    CONSTRAINT "Supplement_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_InspectionReferences" (
    "A" TEXT NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_InspectionReferences_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateIndex
CREATE UNIQUE INDEX "StripeCustomer_organizationId_key" ON "StripeCustomer"("organizationId");

-- CreateIndex
CREATE UNIQUE INDEX "StripeCustomer_customerId_key" ON "StripeCustomer"("customerId");

-- CreateIndex
CREATE UNIQUE INDEX "Credential_secretHash_key" ON "Credential"("secretHash");

-- CreateIndex
CREATE INDEX "Credential_organizationId_idx" ON "Credential"("organizationId");

-- CreateIndex
CREATE UNIQUE INDEX "Invitation_tokenHash_key" ON "Invitation"("tokenHash");

-- CreateIndex
CREATE INDEX "Invitation_organizationId_idx" ON "Invitation"("organizationId");

-- CreateIndex
CREATE INDEX "Membership_organizationId_idx" ON "Membership"("organizationId");

-- CreateIndex
CREATE INDEX "Membership_userId_idx" ON "Membership"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "User_username_key" ON "User"("username");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE INDEX "AuditLog_organizationId_idx" ON "AuditLog"("organizationId");

-- CreateIndex
CREATE INDEX "AuditLog_entityId_idx" ON "AuditLog"("entityId");

-- CreateIndex
CREATE INDEX "EmailVerificationToken_userId_idx" ON "EmailVerificationToken"("userId");

-- CreateIndex
CREATE INDEX "PasswordResetToken_userId_idx" ON "PasswordResetToken"("userId");

-- CreateIndex
CREATE INDEX "Session_userId_idx" ON "Session"("userId");

-- CreateIndex
CREATE INDEX "Comment_inspectionId_idx" ON "Comment"("inspectionId");

-- CreateIndex
CREATE INDEX "Comment_userId_idx" ON "Comment"("userId");

-- CreateIndex
CREATE INDEX "Project_creatorId_idx" ON "Project"("creatorId");

-- CreateIndex
CREATE INDEX "Project_organizationId_idx" ON "Project"("organizationId");

-- CreateIndex
CREATE INDEX "Inspection_projectId_idx" ON "Inspection"("projectId");

-- CreateIndex
CREATE INDEX "Inspection_conductedByUserId_idx" ON "Inspection"("conductedByUserId");

-- CreateIndex
CREATE INDEX "Job_inspectionId_idx" ON "Job"("inspectionId");

-- CreateIndex
CREATE UNIQUE INDEX "Analysis_jobId_key" ON "Analysis"("jobId");

-- CreateIndex
CREATE INDEX "Analysis_inspectionId_idx" ON "Analysis"("inspectionId");

-- CreateIndex
CREATE INDEX "Analysis_jobId_idx" ON "Analysis"("jobId");

-- CreateIndex
CREATE INDEX "Detection_analysisId_idx" ON "Detection"("analysisId");

-- CreateIndex
CREATE INDEX "Supplement_inspectionId_idx" ON "Supplement"("inspectionId");

-- CreateIndex
CREATE INDEX "Supplement_analysisId_idx" ON "Supplement"("analysisId");

-- CreateIndex
CREATE INDEX "Supplement_commentId_idx" ON "Supplement"("commentId");

-- CreateIndex
CREATE INDEX "_InspectionReferences_B_index" ON "_InspectionReferences"("B");

-- AddForeignKey
ALTER TABLE "StripeCustomer" ADD CONSTRAINT "StripeCustomer_organizationId_fkey" FOREIGN KEY ("organizationId") REFERENCES "Organization"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Credential" ADD CONSTRAINT "Credential_organizationId_fkey" FOREIGN KEY ("organizationId") REFERENCES "Organization"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Invitation" ADD CONSTRAINT "Invitation_organizationId_fkey" FOREIGN KEY ("organizationId") REFERENCES "Organization"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Invitation" ADD CONSTRAINT "Invitation_invitedByUserId_fkey" FOREIGN KEY ("invitedByUserId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Membership" ADD CONSTRAINT "Membership_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Membership" ADD CONSTRAINT "Membership_organizationId_fkey" FOREIGN KEY ("organizationId") REFERENCES "Organization"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AuditLog" ADD CONSTRAINT "AuditLog_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AuditLog" ADD CONSTRAINT "AuditLog_organizationId_fkey" FOREIGN KEY ("organizationId") REFERENCES "Organization"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "EmailVerificationToken" ADD CONSTRAINT "EmailVerificationToken_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "PasswordResetToken" ADD CONSTRAINT "PasswordResetToken_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Session" ADD CONSTRAINT "Session_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_inspectionId_fkey" FOREIGN KEY ("inspectionId") REFERENCES "Inspection"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Project" ADD CONSTRAINT "Project_creatorId_fkey" FOREIGN KEY ("creatorId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Project" ADD CONSTRAINT "Project_organizationId_fkey" FOREIGN KEY ("organizationId") REFERENCES "Organization"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Inspection" ADD CONSTRAINT "Inspection_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "Project"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Inspection" ADD CONSTRAINT "Inspection_conductedByUserId_fkey" FOREIGN KEY ("conductedByUserId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Job" ADD CONSTRAINT "Job_inspectionId_fkey" FOREIGN KEY ("inspectionId") REFERENCES "Inspection"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Analysis" ADD CONSTRAINT "Analysis_jobId_fkey" FOREIGN KEY ("jobId") REFERENCES "Job"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Analysis" ADD CONSTRAINT "Analysis_inspectionId_fkey" FOREIGN KEY ("inspectionId") REFERENCES "Inspection"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "Detection" ADD CONSTRAINT "Detection_analysisId_fkey" FOREIGN KEY ("analysisId") REFERENCES "Analysis"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "DetectionOnImage" ADD CONSTRAINT "DetectionOnImage_detectionId_fkey" FOREIGN KEY ("detectionId") REFERENCES "Detection"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "DetectionOnImage" ADD CONSTRAINT "DetectionOnImage_supplementId_fkey" FOREIGN KEY ("supplementId") REFERENCES "Supplement"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Supplement" ADD CONSTRAINT "Supplement_inspectionId_fkey" FOREIGN KEY ("inspectionId") REFERENCES "Inspection"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Supplement" ADD CONSTRAINT "Supplement_analysisId_fkey" FOREIGN KEY ("analysisId") REFERENCES "Analysis"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Supplement" ADD CONSTRAINT "Supplement_commentId_fkey" FOREIGN KEY ("commentId") REFERENCES "Comment"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_InspectionReferences" ADD CONSTRAINT "_InspectionReferences_A_fkey" FOREIGN KEY ("A") REFERENCES "Inspection"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_InspectionReferences" ADD CONSTRAINT "_InspectionReferences_B_fkey" FOREIGN KEY ("B") REFERENCES "Inspection"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="src/actions/cookies.ts">
'use server';

import { cookies } from "next/headers";


export const getCookieByKey = async (key: string) => {
    const cookieStore=await cookies(); 
    const cookie=  cookieStore.get(key);

    if(!cookie){
        return null;
    }
    return cookie.value ;
};


export const setCookieByKey = async (key:string, value: string) => {
    const cookieStore=await cookies(); 
    cookieStore.set(key, value);
};

export const deleteCookieByKey = async (key: string) =>{
    const cookieStore=await cookies(); 
    cookieStore.delete(key);
};

export const consumeCookiedByKey = async (key: string) => {
  const message = await getCookieByKey(key);

  await deleteCookieByKey(key);

  return message;
};
</file>

<file path="src/app/(marketing)/layout.tsx">
import React from "react";

export default function MarketingLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    // min-h-screen ensures it covers at least the full window
    // No "overflow-hidden" here, so the page can scroll normally
    <div className="min-h-screen bg-white dark:bg-slate-950">
      {children}
    </div>
  );
}
</file>

<file path="src/app/(marketing)/page.tsx">
'use client';
import React from 'react';
import { 
  Drone, 
  ShieldCheck, 
  Box, 
  BarChart3, 
  CheckCircle2, 
  ArrowRight, 
  Play,
  Menu,
  Layers
} from 'lucide-react';
import Image from 'next/image';
import Link from 'next/link'; // IMPROVEMENT: Import Link
import { signInPath, signUpPath } from '@/path';

import { useAuth } from "@/features/auth/hooks/use-auth";
import { AccountDropdown } from '../(saas)/_navigation/account-dropdown';



const Home = () => {
  const {user, isFetched}= useAuth( );
  if(!isFetched){
        return null;
    }

  const navItem= user ? (
        <AccountDropdown user={user} />
        
    ) : (<><button className="hidden md:block text-slate-900 dark:text-slate-200 font-medium text-sm hover:underline">
                    <Link href={signInPath()} >Log in</Link>
                </button>
                <button className="bg-blue-600 hover:bg-blue-700 text-white px-5 py-2.5 rounded-full text-sm font-medium transition">
                    <Link href={signUpPath()} >Get Started</Link>
            </button></>)

  return (
    <div className="min-h-screen bg-white dark:bg-slate-950 font-sans text-slate-900 dark:text-slate-200 transition-colors duration-200">
        <nav className="flex items-center justify-between px-6 py-4 max-w-7xl mx-auto">
                <div className="flex items-center gap-2">
                <div className="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center">
                    <ShieldCheck className="text-white w-5 h-5" />
                </div>
                <span className="text-xl font-bold text-slate-900 dark:text-white">AI4Safety</span>
                </div>
                <div className="hidden md:flex items-center gap-8 text-sm font-medium text-slate-600 dark:text-slate-400">
                <a href="#features" className="hover:text-blue-600 dark:hover:text-blue-400 transition">Features</a>
                <a href="#how-it-works" className="hover:text-blue-600 dark:hover:text-blue-400 transition">How it Works</a>
                <a href="#pricing" className="hover:text-blue-600 dark:hover:text-blue-400 transition">Pricing</a>
                </div>
                <div className="flex items-center gap-4">
                  {navItem}
                {/* <YourExistingDarkModeToggle /> */}
                <button className="md:hidden p-2 text-slate-900 dark:text-slate-200">
                    <Menu className="w-6 h-6" />
                </button>
                </div>
        </nav>
      {/* Hero Section */}
      <header className="relative pt-20 pb-32 px-6 overflow-hidden">
          {/* IMPROVEMENT: Optimized Background Image using Next/Image */}
          <div className="absolute inset-0 -z-10">
            <Image 
              src="/drone_survey.png"
              alt="Drone survey background"
              fill
              style={{ objectFit: 'cover' }}
              priority // Loads immediately for LCP score
              quality={85}
            />
             {/* Dark mode friendly overlay */}
            <div className="absolute inset-0 bg-gradient-to-t from-white via-white/80 to-transparent dark:from-slate-950 dark:via-slate-950/80 dark:to-transparent"></div>
          </div>

          <div className="relative z-10 max-w-7xl mx-auto grid lg:grid-cols-2 gap-16 items-center">
            <div className="space-y-8">
              <div className="inline-flex items-center gap-2 px-3 py-1 rounded-full bg-blue-50 text-blue-700 text-xs font-semibold uppercase tracking-wide dark:bg-blue-900/30 dark:text-blue-300">
                <span className="w-2 h-2 rounded-full bg-blue-600 animate-pulse"></span>
                v2.0 Now Live with 3D Tiles
              </div>
              <h1 className="text-5xl md:text-6xl font-bold text-slate-900 dark:text-white leading-tight">
                Automate Safety Inspections with <span className="text-blue-600 dark:text-blue-400">AI Precision.</span>
              </h1>
              <p className="text-lg text-slate-600 dark:text-slate-400 leading-relaxed max-w-lg">
                Transform drone imagery into 3D digital twins. Detect structural defects and safety violations instantly using our proprietary computer vision models.
              </p>
              <div className="flex flex-col sm:flex-row gap-4">
                <button className="bg-blue-600 hover:bg-blue-700 text-white px-8 py-4 rounded-full text-base font-bold transition flex items-center justify-center gap-2">
                  Start Free Inspection <ArrowRight className="w-4 h-4" />
                </button>
                <button className="bg-white border border-slate-200 hover:border-slate-300 text-slate-700 px-8 py-4 rounded-full text-base font-bold transition flex items-center justify-center gap-2 dark:bg-slate-800 dark:border-slate-700 dark:text-slate-200 dark:hover:border-slate-600">
                  <Play className="w-4 h-4 fill-slate-700 dark:fill-slate-200" /> Watch Demo
                </button>
              </div>
              <div className="pt-4 flex items-center gap-4 text-sm text-slate-500 dark:text-slate-400">
                <div className="flex -space-x-2">
                  {[1,2,3,4].map((i) => (
                    <div key={i} className="w-8 h-8 rounded-full border-2 border-white dark:border-slate-950 bg-slate-200 dark:bg-slate-700" />
                  ))}
                </div>
                <p>Trusted by 200+ Safety Officers</p>
              </div>
            </div>
            
            {/* 3D Viewer Mockup */}
            <div className="relative">
              {/* Background glow - adjusted opacity */}
              <div className="absolute -inset-4 bg-gradient-to-r from-blue-100 to-indigo-100 rounded-3xl transform rotate-2 blur-lg opacity-70 dark:from-blue-900/30 dark:to-indigo-900/30"></div>
              
              {/* Image Container - REMOVED aspect-[4/3] and REMOVED bg-slate-950 */}
              <div className="relative rounded-2xl overflow-hidden shadow-2xl border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900">
                <Image
                  width={1200}  // Use high res width
                  height={800}  // Use high res height (defines the natural aspect ratio)
                  src="/cesium_tilset.png"
                  alt="AI4Safety 3D Viewer with AI Detections"
                  className="w-full h-auto" // This ensures it fills width and adjusts height automatically
                  priority
                />
              </div>
            </div>
          </div>
      </header>

      {/* Features Grid */}
      <section id="features" className="py-24 bg-slate-50 dark:bg-slate-900">
        <div className="max-w-7xl mx-auto px-6">
          <div className="text-center max-w-3xl mx-auto mb-16">
            <h2 className="text-3xl md:text-4xl font-bold text-slate-900 dark:text-white mb-4">Everything you need to secure your site</h2>
            <p className="text-slate-600 dark:text-slate-400 text-lg">Replace manual checklists with automated intelligence. Our platform handles the heavy lifting from data collection to final reporting.</p>
          </div>

          <div className="grid md:grid-cols-3 gap-8">
            <div className="bg-white dark:bg-slate-800 p-8 rounded-2xl border border-slate-200 dark:border-slate-700 hover:shadow-lg dark:hover:shadow-xl dark:hover:shadow-slate-800/50 transition group">
              <div className="w-12 h-12 bg-blue-100 dark:bg-blue-900/30 rounded-xl flex items-center justify-center mb-6 group-hover:scale-110 transition">
                <Drone className="w-6 h-6 text-blue-600 dark:text-blue-400" />
              </div>
              <h3 className="text-xl font-bold text-slate-900 dark:text-white mb-3">Drone & Mobile Capture</h3>
              <p className="text-slate-600 dark:text-slate-400 leading-relaxed">
                Upload images from any drone (DJI, Autel) or use our mobile app. We process the data into orthomosaics and 3D models automatically.
              </p>
            </div>

            <div className="bg-white dark:bg-slate-800 p-8 rounded-2xl border border-slate-200 dark:border-slate-700 hover:shadow-lg dark:hover:shadow-xl dark:hover:shadow-slate-800/50 transition group">
              <div className="w-12 h-12 bg-orange-100 dark:bg-orange-900/30 rounded-xl flex items-center justify-center mb-6 group-hover:scale-110 transition">
                <Layers className="w-6 h-6 text-orange-600 dark:text-orange-400" />
              </div>
              <h3 className="text-xl font-bold text-slate-900 dark:text-white mb-3">3D Digital Twins</h3>
              <p className="text-slate-600 dark:text-slate-400 leading-relaxed">
                Visualize your site in high-fidelity 3D. Measure distances, areas, and volumes directly on the digital twin using our Cesium-powered viewer.
              </p>
            </div>

            <div className="bg-white dark:bg-slate-800 p-8 rounded-2xl border border-slate-200 dark:border-slate-700 hover:shadow-lg dark:hover:shadow-xl dark:hover:shadow-slate-800/50 transition group">
              <div className="w-12 h-12 bg-green-100 dark:bg-green-900/30 rounded-xl flex items-center justify-center mb-6 group-hover:scale-110 transition">
                <BarChart3 className="w-6 h-6 text-green-600 dark:text-green-400" />
              </div>
              <h3 className="text-xl font-bold text-slate-900 dark:text-white mb-3">AI Defect Detection</h3>
              <p className="text-slate-600 dark:text-slate-400 leading-relaxed">
                Our AI spots rust, cracks, leaks, and missing PPE automatically. Receive severity scores and generate compliance reports in seconds.
              </p>
            </div>
          </div>
        </div>
      </section>

      {/* How it Works */}
      <section id="how-it-works" className="py-24 px-6">
        <div className="max-w-7xl mx-auto">
            <div className="grid lg:grid-cols-2 gap-16 items-center">
                <div className="order-2 lg:order-1">
                    <div className="space-y-12">
                        <div className="flex gap-6">
                            <div className="flex-shrink-0 w-10 h-10 rounded-full bg-blue-600 text-white font-bold flex items-center justify-center">1</div>
                            <div>
                                <h3 className="text-xl font-bold text-slate-900 dark:text-white mb-2">Upload Your Data</h3>
                                <p className="text-slate-600 dark:text-slate-400">Drag and drop drone imagery or connect your CCTV feed directly to our secure cloud dashboard.</p>
                            </div>
                        </div>
                        <div className="flex gap-6">
                            <div className="flex-shrink-0 w-10 h-10 rounded-full bg-blue-600 text-white font-bold flex items-center justify-center">2</div>
                            <div>
                                <h3 className="text-xl font-bold text-slate-900 dark:text-white mb-2">AI Processing & Reconstruction</h3>
                                <p className="text-slate-600 dark:text-slate-400">Our engine runs photogrammetry to build 3D models while simultaneously scanning for over 50+ types of safety hazards.</p>
                            </div>
                        </div>
                        <div className="flex gap-6">
                            <div className="flex-shrink-0 w-10 h-10 rounded-full bg-blue-600 text-white font-bold flex items-center justify-center">3</div>
                            <div>
                                <h3 className="text-xl font-bold text-slate-900 dark:text-white mb-2">Act on Insights</h3>
                                <p className="text-slate-600 dark:text-slate-400">Access the interactive 3D map, annotate issues, assign tasks to your maintenance team, and export PDF reports.</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div className="order-1 lg:order-2 bg-slate-100 dark:bg-slate-800 rounded-3xl p-8 h-full min-h-[400px] flex items-center justify-center">
                    <div className="text-slate-400 dark:text-slate-500 text-center">
                        <Box className="w-24 h-24 mx-auto mb-4 opacity-20" />
                        <p className="font-medium">Interactive Dashboard Preview</p>
                    </div>
                </div>
            </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="py-24 px-6 bg-blue-900 text-white rounded-t-[3rem] mt-12 dark:bg-blue-800">
        <div className="max-w-4xl mx-auto text-center space-y-8">
            <h2 className="text-4xl md:text-5xl font-bold leading-tight dark:text-white">Ready to modernize your inspection workflow?</h2>
            <p className="text-blue-200 text-lg max-w-2xl mx-auto dark:text-blue-300">Join forward-thinking facility managers and safety officers saving 40% of their inspection time.</p>
            <div className="flex flex-col sm:flex-row gap-4 justify-center pt-4">
              <button className="bg-white text-blue-900 px-8 py-4 rounded-full text-base font-bold hover:bg-blue-50 transition dark:bg-slate-200 dark:hover:bg-slate-50">
                Start Your Free Trial
              </button>
              <button className="bg-transparent border border-white/30 text-white px-8 py-4 rounded-full text-base font-bold hover:bg-white/10 transition">
                Schedule a Demo
              </button>
            </div>
            <div className="flex items-center justify-center gap-6 pt-8 text-sm text-blue-300">
                <span className="flex items-center gap-2"><CheckCircle2 className="w-4 h-4" /> No credit card required</span>
                <span className="flex items-center gap-2"><CheckCircle2 className="w-4 h-4" /> Cancel anytime</span>
            </div>
        </div>
      </section>

      {/* Footer */}
      <footer className="bg-slate-950 text-slate-400 py-12 px-6 dark:bg-gray-900">
        <div className="max-w-7xl mx-auto grid md:grid-cols-4 gap-8 mb-12">
            <div>
                <div className="flex items-center gap-2 mb-4">
                    <div className="w-6 h-6 bg-blue-600 rounded flex items-center justify-center">
                        <ShieldCheck className="text-white w-4 h-4" />
                    </div>
                    <span className="text-lg font-bold text-white">AI4Safety</span>
                </div>
                <p className="text-sm">Empowering industrial safety through artificial intelligence and spatial computing.</p>
            </div>
            <div>
                <h4 className="text-white font-bold mb-4">Product</h4>
                {/* IMPROVEMENT: Used Link components instead of a tags */}
                <ul className="space-y-2 text-sm">
                    <li><Link href="/features" className="hover:text-white">Features</Link></li>
                    <li><Link href="/integrations" className="hover:text-white">Integrations</Link></li>
                    <li><Link href="/pricing" className="hover:text-white">Pricing</Link></li>
                </ul>
            </div>
            <div>
                <h4 className="text-white font-bold mb-4">Company</h4>
                <ul className="space-y-2 text-sm">
                    <li><Link href="/about" className="hover:text-white">About Us</Link></li>
                    <li><Link href="/contact" className="hover:text-white">Contact</Link></li>
                    <li><Link href="/privacy" className="hover:text-white">Privacy Policy</Link></li>
                </ul>
            </div>
            <div>
                <h4 className="text-white font-bold mb-4">Connect</h4>
                <ul className="space-y-2 text-sm">
                    <li><Link href="https://linkedin.com" className="hover:text-white">LinkedIn</Link></li>
                    <li><Link href="https://twitter.com" className="hover:text-white">Twitter</Link></li>
                </ul>
            </div>
        </div>
        <div className="max-w-7xl mx-auto pt-8 border-t border-slate-800 dark:border-slate-700 text-center text-xs">
            &copy; 2025 AI4Safety. All rights reserved. Built in Morocco.
        </div>
      </footer>
    </div>
  );
};

export default Home;
</file>

<file path="src/app/(saas)/_navigation/account-dropdown.tsx">
import { User as AuthUser   } from "@prisma/client";
import { signOut } from "@/features/auth/actions/sign-out";
import {  LucideGem, LucideLock, LucideLogOut, LucideUser } from "lucide-react";
import { DropdownMenu } from "@/components/ui/dropdown-menu";
import { DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel, DropdownMenuSeparator, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { passwordPath, pricingPath, profilePath } from "@/path";
import Link from "next/link";

type AccountDropDownProps={
    user: AuthUser
}

export const AccountDropdown = ({user}: AccountDropDownProps) => {
    return ( 
            <DropdownMenu>
                <DropdownMenuTrigger asChild >
                    <Avatar>
                        <AvatarFallback>{user.username[0].toUpperCase()}</AvatarFallback>
                    </Avatar>
                </DropdownMenuTrigger>
                <DropdownMenuContent className="w-56">
                    <DropdownMenuLabel>My Account</DropdownMenuLabel>
                    <DropdownMenuSeparator />

                    <DropdownMenuItem asChild>
                    <Link href={profilePath()}>
                        <LucideUser className="mr-2 h-4 w-4" />
                        <span>Profile</span>
                    </Link>
                    </DropdownMenuItem>
                    <DropdownMenuItem asChild>
                    <Link href={passwordPath()}>
                        <LucideLock className="mr-2 h-4 w-4" />
                        <span>Password</span>
                    </Link>
                    </DropdownMenuItem>
                    <DropdownMenuSeparator />

                    <DropdownMenuItem asChild>
                        <Link href={pricingPath()}>
                            <LucideGem className="mr-2 h-4 w-4" />
                            <span>Pricing</span>
                        </Link>
                    </DropdownMenuItem>

                    <DropdownMenuSeparator />
                    <DropdownMenuItem asChild>
                    <form action={signOut}>
                        <LucideLogOut className="mr-2 h-4 w-4" />
                        <button type="submit">Sign Out</button>
                    </form>
                    </DropdownMenuItem>
                </DropdownMenuContent>
            </DropdownMenu>
        
     );
}
</file>

<file path="src/app/(saas)/_navigation/header.tsx">
'use client';
import { homePath, signInPath, signUpPath } from "@/path";
import Link from "next/link";
import {  } from "next/navigation";
import { buttonVariants } from "@/components/ui/button";
import {  LucideKanban } from "lucide-react";
import { ThemeSwitcher } from "@/components/theme/theme-switcher";

import { useAuth } from "@/features/auth/hooks/use-auth";
import { AccountDropdown } from "./account-dropdown";

const Header =  () => {
    const {user, isFetched}= useAuth( );

    if(!isFetched){
        return null;
    }

    const navItems= user ? (
        <AccountDropdown user={user} />
        
    ) : (<> 
            <Link href={signUpPath()} className={buttonVariants({
                variant:'outline',})} >Sign Up
            </Link>   
            <Link href={signInPath()} className={buttonVariants({
                variant:'outline',})} >Sign In
            </Link>   
        </>
    )
    return ( 
        <>
            <nav className="flex justify-between items-center px-5 border-b h-[60px]" >
                <div>
                    <Link href={homePath()} className={buttonVariants({
                    variant:'ghost',
                    })} >
                    <LucideKanban />
                    <h1 className="ml-2 text-lg font-semibold" >Ai4Safety</h1>
                    </Link>
                </div>
                <div className="flex gap-x-1 items-center" >
                    <ThemeSwitcher />
                    {navItems}
                </div>
            </nav>
        </>
     );
}
 
export default Header;
</file>

<file path="src/app/(saas)/_navigation/sidebar/components/sidebar-item.tsx">
import Link from "next/link";
import { cloneElement, ReactElement } from "react";
import { buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { closedClassName } from "../constants";
import { NavItem } from "../types";
import { Separator } from "@/components/ui/separator";

type SidebarItemProps = {
  isOpen: boolean;
  navItem: NavItem;
  isActive: boolean;
};

const SidebarItem = ({ isOpen,  isActive, navItem }: SidebarItemProps) => {

  return (
    <>
      {navItem.separator && <Separator />}
      <Link
        href={navItem.href}
        className={cn(
          buttonVariants({ variant: "ghost" }),
          "group relative flex h-12 justify-start",
          isActive && "bg-muted font-bold hover:bg-muted"
        )}
      >
        {cloneElement(navItem.icon  as ReactElement<{ className?: string }>, {
          className: "h-5 w-5",
        })}
        <span
          className={cn(
            "absolute left-12 text-base duration-200",
            isOpen ? "md:block hidden" : "w-[78px]",
            !isOpen && closedClassName
          )}
        >
          {navItem.title}
        </span>
      </Link>
    </>
  );
};

export { SidebarItem };
</file>

<file path="src/app/(saas)/_navigation/sidebar/components/sidebar.tsx">
"use client";

import { useState } from "react";
import { useAuth } from "@/features/auth/hooks/use-auth";
import { cn } from "@/lib/utils";

import { navItems } from "../constants";
import { SidebarItem } from "./sidebar-item";
import { usePathname } from "next/navigation";
import { getActivePath } from "@/utils/get-active-path";
import { pricingPath, signInPath, signUpPath } from "@/path";

const Sidebar = () => {
  const { user, isFetched } = useAuth();
  const pathName= usePathname();

  const { activeindex }= getActivePath(
    pathName,
    navItems.map(item=>item.href.split('/')[1]),
    //[signUpPath(), signInPath(), pricingPath()]
  )

  const [isTransition, setTransition] = useState(false);
  const [isOpen, setOpen] = useState(false);

  const handleToggle = (open: boolean) => {
    setTransition(true);
    setOpen(open);
    setTimeout(() => setTransition(false), 200);
  };

  if (!user || !isFetched) {
    return <div className="w-[78px] bg-secondary/20" />;
  }

  return (
    <nav
      className={cn(
        "border-r pt-10 h-full overflow-y-auto no-scrollbar",
        isTransition && "duration-200",
        isOpen ? "md:w-60 w-[78px]" : "w-[78px]"
      )}
      onMouseEnter={() => handleToggle(true)}
      onMouseLeave={() => handleToggle(false)}
    >
      <div className="px-3 py-2">
        <nav className="space-y-2">
          {navItems.map((navItem, index) => (
            <SidebarItem
              key={navItem.title}
              isOpen={isOpen}
              isActive={activeindex === index}
              navItem={navItem}
            />
          ))}
        </nav>
      </div>
    </nav>
  );
};

export { Sidebar };
</file>

<file path="src/app/(saas)/_navigation/sidebar/constants.tsx">
import { LucideBook, LucideBookCopy, LucideCircleUser, 
        LucideLibrary, LucideProjector, LucideUsers } from "lucide-react";
import { NavItem } from "./types";
import { homePath, organizationPath, 
    profilePath, ticketsByOrganizationPath, 
    ticketsPath, projectsPath } from "@/path";

export const navItems: NavItem[] = [
    {
        title: 'Projects',
        icon: <LucideProjector />,
        href: projectsPath(),
    },
    // {
    //     title: 'All Tickets',
    //     icon: <LucideLibrary />,
    //     href: homePath(),
    // },
    // {
    //     title: 'Our Tickets',
    //     icon: <LucideBookCopy />,
    //     href: ticketsByOrganizationPath(),
    // },
    // {
    //     title: 'My tickets',
    //     icon: <LucideBook />,
    //     href: ticketsPath(),
    // },
    {
        separator: true,
        title: 'Account',
        icon: <LucideCircleUser />,
        href:profilePath(),
    },
    {
        title: 'Organization',
        icon: <LucideUsers />,
        href:organizationPath(),
    }
]

export const closedClassName =
  "text-background opacity-0 transition-all duration-300 group-hover:z-40 group-hover:ml-4 group-hover:rounded group-hover:bg-foreground group-hover:p-2 group-hover:opacity-100";
</file>

<file path="src/app/(saas)/_navigation/sidebar/types.ts">
export type NavItem={
    title:string;
    icon:React.ReactElement;
    href:string;
    separator?: boolean
};
</file>

<file path="src/app/(saas)/_providers/react-query/react-query-provider.tsx">
// In Next.js, this file would be called: app/providers.tsx
'use client'

// Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top
import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient()
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

export default function ReactQueryProvider({ children }: {children: React.ReactNode})
  {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient()

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}
</file>

<file path="src/app/(saas)/(authenticated)/account/_navigation/tabs.tsx">
'use client';
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { passwordPath, profilePath } from "@/path";
import Link from "next/link";
import { usePathname } from "next/navigation";

export const AccountTabs = () => {
     const pathName= usePathname();
    return ( 
        <Tabs value={pathName.split('/').at(-1)} >
            <TabsList>
                <TabsTrigger value="profile" asChild >
                    <Link href={profilePath()} >Profile</Link>
                </TabsTrigger>
                <TabsTrigger value="password" asChild >
                    <Link href={passwordPath()} >Password</Link>
                </TabsTrigger>
            </TabsList>
        </Tabs>
     );
}
</file>

<file path="src/app/(saas)/(authenticated)/layout.tsx">
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";


const AuthenticatedLayout = async ({
    children,}: Readonly<{children: React.ReactNode}>) => {
    await getAuthOrRedirect()
    return ( 
        <>{children}</>
     );
}
 
export default AuthenticatedLayout;
</file>

<file path="src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/_navigation/tabs.tsx">
'use client';
import { Breadcrumbs } from "@/components/breadcrumbs";
import { credentialsPath, invitationsPath, membershipsPath, 
    organizationPath, subscriptionPath } from "@/path";
import { useParams, usePathname } from "next/navigation";

export const OrganizationBreadCrumbs = () => {
    const params = useParams<{organizationId: string}>();
    const pathname = usePathname();

    const title = {
        memberships: "Memberships" as const,
        invitations: "Invitations" as const,
        credentials: "Credentials" as const,
        subscription: "Subscription" as const,
    }[
        pathname.split('/').at(-1)  as 
        |  "memberships" 
        |  "invitations" 
        |  "credentials"
        |  "subscription"
    ] ;

    return ( 
        <Breadcrumbs
            breadcrumbs={[
                {title: "Organizations", href:organizationPath()},
                {title,
                    dropdown:[
                        {
                            title: "Memberships",
                            href: membershipsPath(params.organizationId)
                        },
                        {
                            title:"Invitations",
                            href: invitationsPath(params.organizationId)
                        },
                        {
                            title:"Credentials",
                            href: credentialsPath(params.organizationId)
                        },
                        {
                            title:"Subscription",
                            href: subscriptionPath(params.organizationId)
                        }
                    ]
                },
            ]}
        />
     );
}
</file>

<file path="src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/credentials/page.tsx">
import { Suspense } from "react";

import { Spinner } from "@/components/spinner";
import { OrganizationBreadCrumbs } from "../_navigation/tabs";
import Heading from "@/components/heading";
import { CredentialCreateButton } from "@/features/credential/components/credential-create-button";
import { CredentialList } from "@/features/credential/components/credential-list";

type CredentialsPageProps = {
  params: Promise<{
    organizationId: string;
  }>;
};

const CredentialsPage = async ({ params }: CredentialsPageProps) => {
  const { organizationId } = await params;

  return (
    <div className="flex-1 flex flex-col gap-y-8">
      <Heading
        title="Credentials"
        description="Manage your organization's API secrets"
        tabs={<OrganizationBreadCrumbs />}
        actions={<CredentialCreateButton organizationId={organizationId} />}
      />

      <Suspense fallback={<Spinner />}>
        <CredentialList organizationId={organizationId} />
      </Suspense>
    </div>
  );
};

export default CredentialsPage;
</file>

<file path="src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/invitations/page.tsx">
import Heading from "@/components/heading"
import { OrganizationBreadCrumbs } from "../_navigation/tabs"
import { Suspense } from "react"
import { Spinner } from "@/components/spinner"
import { InvitationsList } from "@/features/invitation/components/invitation-list"
import { InvitationCreateButton } from "@/features/invitation/components/invitation-create-button"

type InvitationsPageProps = {
    params: Promise<{
        organizationId: string
    }>
}
const InvitationsPage = async ({params}: InvitationsPageProps) => {
    const {organizationId} = await params
    return ( 
        <div className="flex-1 flex flex-col gap-y-8" >
            <Heading 
                title="Invitations"
                description="Manages your organization's invitations"
                tabs={<OrganizationBreadCrumbs />}
                actions= {<InvitationCreateButton 
                    organizationId={organizationId} />}
            />
            <Suspense fallback={<Spinner />} >
                <InvitationsList organizationId={organizationId} />
            </Suspense>
        </div>
     );
}
 
export default InvitationsPage;
</file>

<file path="src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/layout.tsx">
import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";


const AdminLayout = async ({
    children, params}: Readonly<{children: React.ReactNode , 
        params:Promise<{organizationId: string}>}>) => {

    const {organizationId}= await params;        
    await getAdminOrRedirect(organizationId);
    return ( 
        <>{children}</>
     );
}
 
export default AdminLayout;
</file>

<file path="src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/memberships/page.tsx">
import Heading from "@/components/heading";
import { Spinner } from "@/components/spinner";
import { MembershipList } from "@/features/membership/components/membership-list";
import { Suspense } from "react";
import { OrganizationBreadCrumbs } from "../_navigation/tabs";
import { InvitationCreateButton } from "@/features/invitation/components/invitation-create-button";

type MembershipsPageProps = {
    params: Promise<{organizationId: string}>;
};
const Membershipspage = async({params}:MembershipsPageProps) => {
    const {organizationId}= await params;
    return ( 
        <div className="flex-1 flex flex-col gap-y-8" >
            <Heading 
                title="Memberships"
                description="Manage memberships in your organization"
                tabs={<OrganizationBreadCrumbs />}
                actions= {<InvitationCreateButton 
                    organizationId={organizationId} />}
            />

            <Suspense fallback={<Spinner/>} >
                <MembershipList organizationId={organizationId} />
            </Suspense>
        </div>
     );
}
 
export default Membershipspage;
</file>

<file path="src/app/(saas)/(authenticated)/organization/[organizationId]/(admin)/subscription/page.tsx">
import { LucideSettings } from "lucide-react";
import { Suspense } from "react";
import { Spinner } from "@/components/spinner";
import { Products } from "@/features/stripe/components/products";
import { OrganizationBreadCrumbs } from "../_navigation/tabs";
import Heading from "@/components/heading";
import { CustomerPortalForm } from "@/features/stripe/components/customer-portal-form";

type SubscriptionPageProps = {
  params: Promise<{
    organizationId: string;
  }>;
};

const SubscriptionPage = async ({ params }: SubscriptionPageProps) => {
  const { organizationId } = await params;

  return (
    <div className="flex-1 flex flex-col gap-y-8">
      <Heading
        title="Subscription"
        description="Manage your subscription"
        tabs={<OrganizationBreadCrumbs />}
        actions={
          <CustomerPortalForm organizationId={organizationId}>
            <>
              <LucideSettings className="w-4 h-4" />
              Manage Subscription
            </>
          </CustomerPortalForm>
        }
      />

      <Suspense fallback={<Spinner />}>
        <Products organizationId={organizationId} />
      </Suspense>
    </div>
  );
};

export default SubscriptionPage;
</file>

<file path="src/app/(saas)/(authenticated)/organization/create/page.tsx">
import { CardElement } from "@/components/card-compact";
import { OrganizationCreateForm } from "@/features/organization/components/organization-create-form";

const OrganizationCreatePage = () => {
    return ( 
        <div className="flex-1 flex  flex-col justify-center items-center">
            <CardElement
                title="Create Organization"
                description="Create your organization to get started"
                className="w-full max-w-[420px]"
                content={<OrganizationCreateForm />}
            />
        </div>
     );
}
 
export default OrganizationCreatePage;
</file>

<file path="src/app/(saas)/(authenticated)/organization/page.tsx">
import Heading from "@/components/heading";
import { Spinner } from "@/components/spinner";
import { Button } from "@/components/ui/button";
import { OrganizationList } from "@/features/organization/components/organization-list";
import { organizationCreatePath } from "@/path";
import { LucidePlus } from "lucide-react";
import Link from "next/link";
import { Suspense } from "react";

const OrganizationPage =  () => {

    return ( 
        <div className="flex-1 flex-col gap-y-8" >
            <Heading title="Organizations" 
                description="All your organizations" 
                actions= {
                    <Button asChild>
                        <Link href={organizationCreatePath()} >
                            <LucidePlus className="w-4 h-4" />
                            Create Organization
                        </Link>
                    </Button>
                }/>
            
            <Suspense fallback={<Spinner />} >
                <OrganizationList />
            </Suspense>
        </div>
     );
}
 
export default OrganizationPage;
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/inspections/[inspectionId]/analysis/_navigation/tabs.tsx">
'use client';
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { tabular_analysis_Path, three_D_viewer_Path } from "@/path";
import Link from "next/link";
import { usePathname } from "next/navigation";

export const AnalysisTabs = ({projectId, inspectionId}: {projectId: string, inspectionId:string}) => {
     const pathName= usePathname();
    return ( 
        <Tabs value={pathName.split('/').at(-1)} >
            <TabsList>
                <TabsTrigger value="3d_viewer" asChild >
                    <Link href={three_D_viewer_Path(projectId, inspectionId)} >3D Viewer</Link>
                </TabsTrigger>
                <TabsTrigger value="table" asChild >
                    <Link href={tabular_analysis_Path(projectId, inspectionId)} >Tabular Results</Link>
                </TabsTrigger>
            </TabsList>
        </Tabs>
     );
}
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/layout.tsx">
import { ProjectBreadCrumbs } from "./_navigation/tabs";

const Layout =  ({children}: Readonly<{children: React.ReactNode , 
        params:Promise<{projectId: string}>}>) => {
   
   
    return ( 
        <div className='flex-1 flex flex-col gap-y-8'>
            {/* <ProjectBreadCrumbs/> */}
           
            {children}
        </div>
     );
}
 
export default Layout;
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/loading.tsx">
import { Spinner } from "@/components/spinner";

export default function Loading (){
    return ( 
        <Spinner />
     );
}
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/not-found.tsx">
import {Placeholder} from "@/components/placeholder";
import { Button } from "@/components/ui/button";
import { projectsPath } from "@/path";
import Link from "next/link";

export default function NotFound()  {
    return ( 
        <Placeholder label="We could not find your projects"
         button={
            <Button asChild variant="outline" >
                <Link href={projectsPath()} >Go To Projects</Link>
            </Button>
            } 
        />
     );
}
</file>

<file path="src/app/(saas)/(authenticated)/projects/create/page.tsx">
import { CardElement } from "@/components/card-compact";
import { ProjectUpsertForm } from "@/features/project/components/project-form-upsert";

const ProjectCreatePage = () => {
    return ( 
        <div className="flex-1 flex  flex-col justify-center items-center">
            <CardElement
                title="Create Project"
                description="Create your project to get your inspection results"
                className="w-full max-w-[420px]"
                content={<ProjectUpsertForm />}
            />
        </div>
     );
}
 
export default ProjectCreatePage;
</file>

<file path="src/app/(saas)/(authenticated)/projects/error.tsx">
"use client"
import {Placeholder} from "@/components/placeholder";

const Error = ({error}: {error:Error}) => {
    return ( 
        <Placeholder 
        label= {error.message ||"Something went wrong !"} />
     );
}
 
export default Error;
</file>

<file path="src/app/(saas)/api/aws/s3/supplements/[supplementId]/route.ts">
import { GetObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import { NextRequest, NextResponse } from "next/server";
import * as attachmentData from "@/features/supplements/data";
import * as attachmentSubjectDTO from "@/features/supplements/dto/attachment-subject-dto";
import { generateS3Key } from "@/features/supplements/utils/generate-s3-key";
import { s3 } from "@/lib/aws";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ supplementId: string }> }
) {
  await getAuthOrRedirect();

  const { supplementId } = await params;

  const attachment = await attachmentData.getAttachment(supplementId);

  let subject;
  switch (attachment?.entity) {
    case "INSPECTION":
      subject = attachmentSubjectDTO.fromInspection(attachment.inspection);
      break;
    case "ANALYSIS":
      subject = attachmentSubjectDTO.fromAnalysis(attachment.analysis);
      break;
    case "DETECTION":
      subject = attachmentSubjectDTO.fromDetection(attachment.detection);
      break;
    case "COMMENT":
      subject = attachmentSubjectDTO.fromComment(attachment.comment);
      break;
  }

  if (!subject || !attachment) {
    return new NextResponse("Subject not found", { status: 404 });
  }

  if (!subject.organizationId) {
    return new NextResponse("Organization ID missing", { status: 400 });
  }

  const presignedUrl = await getSignedUrl(
    s3,
    new GetObjectCommand({
      Bucket: process.env.AWS_BUCKET_NAME,
      Key: attachment.url!,
      ResponseContentDisposition: `attachment; filename="${attachment.name}"`
    }),
    { expiresIn: 5 * 60 }
  );

  // const response = await fetch(presignedUrl);

  // const headers = new Headers();
  // headers.append(
  //   "content-disposition",
  //   `attachment; filename="${attachment.name}"`
  // );

  // return   new Response(response.body, {
  //   headers,
  // });

  return NextResponse.redirect(presignedUrl);
}
</file>

<file path="src/app/(saas)/api/stripe/route.ts">
import { headers } from "next/headers";
import { NextResponse } from "next/server";
import Stripe from "stripe";
import * as stripeData from "@/features/stripe/data";
import { stripe } from "@/lib/stripe";

const handleSubscriptionCreated = async (
  subscription: Stripe.Subscription,
  eventAt: number
) => {
  await stripeData.updateStripeSubscription(subscription, eventAt);
};

const handleSubscriptionUpdated = async (
  subscription: Stripe.Subscription,
  eventAt: number
) => {
  await stripeData.updateStripeSubscription(subscription, eventAt);
};

const handleSubscriptionDeleted = async (
  subscription: Stripe.Subscription,
  eventAt: number
) => {
  await stripeData.deleteStripeSubscription(subscription, eventAt);
};

export async function POST(req: Request) {
  const body = await req.text();
  const signature = (await headers()).get("Stripe-Signature");
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

  if (!webhookSecret) {
    return new NextResponse("Missing Webhook Secret", {
      status: 500,
    });
  }

  if (!signature) {
    return new NextResponse("Missing Stripe Signature", {
      status: 400,
    });
  }

  let event: Stripe.Event | null = null;

  try {
    event = stripe.webhooks.constructEvent(body, signature, webhookSecret);

    switch (event.type) {
      case "customer.subscription.created":
        handleSubscriptionCreated(event.data.object, event.created);
        break;
      case "customer.subscription.updated":
        handleSubscriptionUpdated(event.data.object, event.created);
        break;
      case "customer.subscription.deleted":
        handleSubscriptionDeleted(event.data.object, event.created);
        break;
      default:
       // console.log(`Unhandled event type ${event.type}.`);
    }

    return new NextResponse(null, { status: 200 });
  } catch {
    return new NextResponse("Invalid Stripe Signature", {
      status: 400,
    });
  }
}
</file>

<file path="src/app/(saas)/api/tiles/[organizationId]/[projectId]/[inspectionId]/[...path]/route.ts">
import { GetObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import { NextRequest, NextResponse } from "next/server";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { s3 } from "@/lib/aws";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ 
    organizationId: string; 
    projectId: string; 
    inspectionId: string; 
    path: string[] 
  }> }
) {
  // Auth Check
  await getAuthOrRedirect();

  const { organizationId, projectId, inspectionId, path } = await params;

  // Reconstruct the filename from the URL path segments
  let filename = path.join("/");

  // 2. AUTO-DETECT S3 FOLDER
  // We switch the "subFolder" based on what file extension is requested.
  let subFolder = "assets/unzipped_assets/"; // Default fallback

  if (filename.endsWith("shots.geojson")) {
      // Logic: Camera positions usually live in the 'odm_report' folder
      subFolder = "assets/unzipped_assets/odm_report/"; 

  } else if (filename.endsWith(".json") || filename.endsWith(".b3dm") ) {
      // Logic: 3D Tile files live in the 'model' folder
      subFolder = "assets/unzipped_assets/3d_tiles/model/";

  } else if (filename.match(/\.(jpg|jpeg|png|JPG|PNG)$/)) {
      // Logic: Raw images usually live in 'uploaded_images' (or wherever you store raw drone photos)
      subFolder = ""; 
      //  CASE SENSITIVITY FIX:
      // If the request is lowercase 'dji_...jpg' but S3 has 'DJI_...JPG', swap it.
      if (filename.includes("dji_") && filename.endsWith(".jpg")) {
          filename = filename.replace("dji_", "DJI_").replace(".jpg", ".JPG");
      }
  }

  //const relativePath = path.join("/");

  // 2. Construct the S3 Key dynamically
  //const s3Key = `organizations/${organizationId}/projects/${projectId}/INSPECTION/${inspectionId}/assets/unzipped_assets/3d_tiles/model/${relativePath}`;
  //const s3Key = `organizations/${organizationId}/projects/${projectId}/INSPECTION/${inspectionId}/assets/unzipped_assets/${relativePath}`;
  const s3Key = `organizations/${organizationId}/projects/${projectId}/INSPECTION/${inspectionId}/${subFolder}${filename}`;

  //console.log("Generatign Tile Proxy for:", s3Key); 

  try {
    const command = new GetObjectCommand({
      Bucket: process.env.AWS_BUCKET_NAME,
      Key: s3Key,
    });

    const signedUrl = await getSignedUrl(s3, command, { expiresIn: 60 });

    return NextResponse.redirect(signedUrl);

  } catch (error) {
    //console.error("Tile error:", error);
    return new NextResponse("Error generating tile URL", { status: 500 });
  }
}
</file>

<file path="src/app/(saas)/email-invitation/[tokenId]/page.tsx">
import { CardElement } from "@/components/card-compact";
import { InvitationAcceptForm } from "@/features/invitation/components/invitation-accept-form";

type EmailInvitationPageProps = {
  params: Promise<{
    tokenId: string;
  }>;
};

const EmailInvitationPage = async ({ params }: EmailInvitationPageProps) => {
  const { tokenId } = await params;

  return (
    <div className="flex-1 flex flex-col justify-center items-center">
      <CardElement
        title="Invitation to Organization"
        description="Accept the invitation to join the organization"
        className="w-full max-w-[420px] animate-fade-from-top"
        content={<InvitationAcceptForm tokenId={tokenId} />}
      />
    </div>
  );
};

export default EmailInvitationPage;
</file>

<file path="src/app/(saas)/email-verification/page.tsx">
import { CardElement } from "@/components/card-compact";
import { EmailVerificationForm } from "@/features/auth/components/email-verification-form";
import { EmailVerificationResendForm } from "@/features/auth/components/email-verification-resend-form";



const EmailVerificationPage = () => {
    return ( 
        
        <div className="flex-1 flex flex-col
         justify-center items-center" >
            <CardElement title="Email Verification" 
            description="Verify your account to get started"
            className="w-full max-w-[420px]"
            content={
            <div className="flex flex-col gap-y-2" >
                <EmailVerificationForm /> 
                <EmailVerificationResendForm /> 
            </div>
           } 
            />
        </div>
     );
}
 
export default EmailVerificationPage;
</file>

<file path="src/app/(saas)/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "../globals.css";
import { NuqsAdapter } from 'nuqs/adapters/next/app'

import Header from "@/app/(saas)/_navigation/header";
import { ThemeProvider } from "@/components/theme/theme-provider";
import { Toaster } from "@/components/ui/sonner";
import { Sidebar } from "@/app/(saas)/_navigation/sidebar/components/sidebar";
import ReactQueryProvider from "./_providers/react-query/react-query-provider";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Ai4Safety",
  description: "Generated by NextJS",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
      <NuqsAdapter>
      <ThemeProvider>
      <ReactQueryProvider>
        <div className="flex flex-col h-screen bg-background overflow-hidden">
          <Header />
          <div className="flex flex-1 overflow-hidden">
            <Sidebar />
            <main className="
            flex-1
            overflow-y-auto overflow-x-hidden
            py-8 px-8
            pb-10
            bg-secondary/20
            flex flex-col
                " >
            {children}
            </main>
          </div>
          <Toaster expand />
        </div>
      </ReactQueryProvider>
      </ThemeProvider>
      </NuqsAdapter>
    
    
  );
}
</file>

<file path="src/app/(saas)/onboarding/page.tsx">
import { CardElement } from "@/components/card-compact";
import { OrganizationCreateForm } from "@/features/organization/components/organization-create-form";

const onboardingPage = () => {
    return ( 
        <div className="flex-1 flex  flex-col justify-center items-center">
            <CardElement
                title="Create Organization"
                description="Create your organization to get started"
                className="w-full max-w-[420px]"
                content={<OrganizationCreateForm />}
            />
        </div>
     );
}
 
export default onboardingPage;
</file>

<file path="src/app/(saas)/onboarding/select-active-organization/page.tsx">
import Heading from "@/components/heading";
import { Spinner } from "@/components/spinner";
import { Button } from "@/components/ui/button";
import { OrganizationList } from "@/features/organization/components/organization-list";
import { getOrganizationsByUserId } from "@/features/organization/queries/get-organizations-by-user";
import { onboardingPath, organizationPath } from "@/path";
import { LucidePlus } from "lucide-react";
import Link from "next/link";
import { redirect } from "next/navigation";
import { Suspense } from "react";

const SelectActiveOrganizationPage = async () => {
    const organizations= await getOrganizationsByUserId();

    const hasActive= organizations.some(org=>org.membershipByUser.isActive);
    if(hasActive){
        redirect(organizationPath());
    }

    return ( 
        <div className="flex-1 flex-col gap-y-8" >
            <Heading title="Select an Organizations" 
                description="Pick an organization to work with" 
                actions= {
                    <Button asChild>
                        <Link href={onboardingPath()} >
                            <LucidePlus className="w-4 h-4" />
                            Create Organization
                        </Link>
                    </Button>
                }/>
            
            <Suspense fallback={<Spinner />} >
                <OrganizationList limitedAccess />
            </Suspense>
        </div>
     );
}
 
export default SelectActiveOrganizationPage;
</file>

<file path="src/app/(saas)/password-forgot/page.tsx">
import { CardElement } from "@/components/card-compact";
import { PasswordForgotForm } from "@/features/password/components/password-forgot-form";


const PasswordForgot = () => {
    return ( 
        <>
        <div className="flex-1 flex flex-col
         justify-center items-center" >
            <CardElement title="Forgot Password" 
            description="Enter your email address to reset your password"
            className="w-full max-w-[420px]"
            content={<PasswordForgotForm />} 
           />
        </div>
        </>
     );
}
 
export default PasswordForgot;
</file>

<file path="src/app/(saas)/password-reset/[tokenId]/page.tsx">
import { CardElement } from "@/components/card-compact";
import { PasswordResetForm } from "@/features/password/components/password-reset-form";

type PasswordResetPageProps = {
    params: Promise<{
        tokenId: string;
    }>
}

const PasswordResetPage = async ({params}: PasswordResetPageProps) => {
    const {tokenId}= await params;
    return ( 
        <>
        <div className="flex-1 flex flex-col
         justify-center items-center" >
            <CardElement title="New Password" 
            description="Enter your new password"
            className="w-full max-w-[420px]"
            content={<PasswordResetForm  tokenId = {tokenId} />} 
           />
        </div>
        </>
     );
}
 
export default PasswordResetPage;
</file>

<file path="src/app/(saas)/pricing/page.tsx">
import { getActiveOrganization } from "@/features/organization/queries/get-active-organization";
import { Products } from "@/features/stripe/components/products";

const PricingPage = async () => {
  const activeOrganization = await getActiveOrganization();

  return <Products organizationId={activeOrganization?.id} />;
};

export default PricingPage;
</file>

<file path="src/app/(saas)/sign-in/page.tsx">
import { CardElement } from "@/components/card-compact";
import { SignInForm } from "@/features/auth/components/sign-in-form";

import { passwordForgotPath, signUpPath } from "@/path";
import Link from "next/link";

const SignInPage = () => {
    return ( 
        <>
        <div className="flex-1 flex flex-col
         justify-center items-center" >
            <CardElement title="Sign In" 
            description="Sign In to your account to get started"
            className="w-full max-w-[420px]"
            content={<SignInForm />} 
            footer={<><Link className="text-sm text-muted-foreground" 
            href={signUpPath()} > No account yet? </Link>
            <Link className="text-sm text-muted-foreground ml-auto" 
                href={passwordForgotPath()} > 
            Forgot Password? 
            </Link>
            </>
            } />
        </div>
        </>
     );
}
 
export default SignInPage;
</file>

<file path="src/app/(saas)/sign-up/page.tsx">
import { CardElement } from "@/components/card-compact";
import { SignUpForm } from "@/features/auth/components/sign-up-form";
import { signInPath } from "@/path";
import Link from "next/link";

const SignUpPage = () => {
    return ( 
        <>
        <div className="flex-1 flex flex-col
         justify-center items-center" >
            <CardElement title="Sign Up" 
            description="Create an account to get started"
            className="w-full max-w-[420px]"
            content={<SignUpForm />} 
            footer={
                <Link className="text-sm text-muted-foreground" 
                    href={signInPath()} > Have an account? Sign In 
                </Link>
            } />
        </div>
        </>
     );
}
 
export default SignUpPage;
</file>

<file path="src/app/(saas)/template.tsx">
import { RedirectToast } from "@/components/redirect-toast";

type RootTemplateProps = {
    children: React.ReactNode
}
export default function Template({children} : RootTemplateProps){
    return (<>
    <>
     {children}
    </>
    <RedirectToast />
    </>);
}
</file>

<file path="src/components/3D_Viewer/auto-align-tileset.ts">
import { Cesium3DTileset, Viewer } from "cesium";
import { RefObject } from "react";

/**
 * Auto-align  tilesets to Cesium.
 * - Fixes Z-up → ENU orientation
 * - Allows height correction
 * - Rotates about model center so geometry stays intact
 *
 * @param tileset Cesium3DTileset
 * @param viewer Cesium Viewer
 * @param Cesium Cesium namespace
 * @param opt options { xRotDeg, heightOffset, debug }
 */
export interface AlignOptions {
  xRotDeg?: number;
  heightOffset?: number;
  debug?: boolean;
}

export function autoAlignTileset(
    tileset: Cesium3DTileset,
    viewer: RefObject<Viewer | null>,
    Cesium: typeof import("cesium"),
    opt:AlignOptions = {}
) {
    const ROT_X_DEG = opt.xRotDeg ?? -90;   // ODM Z-up → ENU
    const HEIGHT_OFFSET = opt.heightOffset ?? 2; // Adjust as needed
    const DEBUG = opt.debug ?? true;

    // STEP 1 — Build full world matrix for the tile root
    const worldFromTile = Cesium.Matrix4.multiply(
        tileset.modelMatrix,
        tileset.root.transform,
        new Cesium.Matrix4()
    );

    // STEP 2 — Find a stable pivot point for rotation
    let pivotWorld;

    if (tileset.boundingSphere) {
        pivotWorld = tileset.boundingSphere.center;
    } else if (tileset.root?.boundingSphere?.center) {
        const localCenter = tileset.root.boundingSphere.center;
        pivotWorld = Cesium.Matrix4.multiplyByPoint(
            worldFromTile,
            localCenter,
            new Cesium.Cartesian3()
        );
    } else {
        pivotWorld = Cesium.Matrix4.getTranslation(
            worldFromTile,
            new Cesium.Cartesian3()
        );
    }

    // STEP 3 — Create local ENU frame at pivot
    const enu = Cesium.Transforms.eastNorthUpToFixedFrame(pivotWorld);
    const enuR = Cesium.Matrix4.getMatrix3(enu, new Cesium.Matrix3());
    const enuR_T = Cesium.Matrix3.transpose(enuR, new Cesium.Matrix3());

    // STEP 4 — Local rotation (ODM Z-up → ENU)
    const localR = Cesium.Matrix3.fromRotationX(
        Cesium.Math.toRadians(ROT_X_DEG)
    );

    // Convert local rotation to world coordinates: Rw = ENU * R_local * ENU^T
    const tmp = new Cesium.Matrix3();
    const R_world3 = Cesium.Matrix3.multiply(
        enuR,
        Cesium.Matrix3.multiply(localR, enuR_T, tmp),
        new Cesium.Matrix3()
    );
    const R_world4 = Cesium.Matrix4.fromRotationTranslation(R_world3);

    // STEP 5 — Translate tile to pivot → rotate → translate back
    const T_toPivot = Cesium.Matrix4.fromTranslation(
        Cesium.Cartesian3.negate(pivotWorld, new Cesium.Cartesian3())
    );
    const T_fromPivot = Cesium.Matrix4.fromTranslation(pivotWorld);

    let rotationFix = Cesium.Matrix4.multiply(
        T_fromPivot,
        R_world4,
        new Cesium.Matrix4()
    );
    rotationFix = Cesium.Matrix4.multiply(
        rotationFix,
        T_toPivot,
        rotationFix
    );

    // STEP 6 — Apply height offset along local ENU "Up"
    const upENU = Cesium.Matrix3.getColumn(
        enuR, 2, new Cesium.Cartesian3()
    );
    const moveWorld = Cesium.Cartesian3.multiplyByScalar(
        upENU,
        HEIGHT_OFFSET,
        new Cesium.Cartesian3()
    );
    const heightFix = Cesium.Matrix4.fromTranslation(moveWorld);

    // STEP 7 — Compose final correction
    const A = Cesium.Matrix4.multiply(
        heightFix,
        rotationFix,
        new Cesium.Matrix4()
    );

    // Apply final correction to modelMatrix
    tileset.root.transform = Cesium.Matrix4.multiply(
        A,
        tileset.root.transform,
        new Cesium.Matrix4()
    );

    if (DEBUG) {
        console.log("WebODM auto-alignment applied:");
        console.log("Rotation X:", ROT_X_DEG);
        console.log("Height offset:", HEIGHT_OFFSET);
        console.log("Pivot world:", pivotWorld);
    }

    return {
        rotationDeg: ROT_X_DEG,
        heightOffset: HEIGHT_OFFSET,
        pivotWorld,
        finalModelMatrix: tileset.modelMatrix
    };
}
</file>

<file path="src/components/3D_Viewer/camera-transform.ts">
/**
 * Compute the local-to-ECEF transformation matrix for the reconstruction
 * This should match how WebODM/OpenSfM geo-referenced the model
 */
export const computeLocalToECEFTransform = (
    CesiumJs: any,
    referencePoint: { lon: number; lat: number; alt: number }
): any => {
    // Create an East-North-Up (ENU) frame at the reference point
    const origin = CesiumJs.Cartesian3.fromDegrees(
        referencePoint.lon,
        referencePoint.lat,
        referencePoint.alt
    );
    
    // Get the ENU to ECEF transform at this location
    const enuTransform = CesiumJs.Transforms.eastNorthUpToFixedFrame(origin);
    
    return enuTransform;
};

/**
 * Alternative: If  WebODM output uses UTM coordinates,
 * you need to compute the UTM zone and transform
 */
// export const computeUTMToECEFTransform = async (
//     CesiumJs: any,
//     utmZone: number,
//     isNorthernHemisphere: boolean,
//     referencePoint: { easting: number; northing: number; altitude: number }
// ): Promise<any> => {
//     // This requires a UTM to WGS84 conversion
//     // For now, we'll use the ENU approach which works if the reference is correct
    
//     // we might need to use proj4js for accurate UTM conversion
    
//     const proj4 = (await import('proj4')).default;
    
//     // Define UTM projection
//     const utmProj = `+proj=utm +zone=${utmZone} ${isNorthernHemisphere ? '+north' : '+south'} +datum=WGS84`;
//     const wgs84 = '+proj=longlat +datum=WGS84';
    
//     // Convert reference point to WGS84
//     const [lon, lat] = proj4(utmProj, wgs84, [referencePoint.easting, referencePoint.northing]);
    
//     return computeLocalToECEFTransform(CesiumJs, { 
//         lon, 
//         lat, 
//         alt: referencePoint.altitude 
//     });
// };
</file>

<file path="src/components/3D_Viewer/components/defect-search.tsx">
'use client';

import { useState, useRef, useEffect } from "react";
import { Search, X } from "lucide-react";
import { Detection } from "@prisma/client";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

type DefectSearchProps = {
  defects: Detection[];
  onSelectDefect: (id: string) => void;
};

export const DefectSearch = ({ defects, onSelectDefect }: DefectSearchProps) => {
  const [query, setQuery] = useState("");
  const [isExpanded, setIsExpanded] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Filter logic
  const filteredDefects = defects.filter((d) => {
    if (!query) return false;
    const searchStr = `${d.type} ${d.severity} ${d.notes || ""}`.toLowerCase();
    return searchStr.includes(query.toLowerCase());
  });

  const handleSelect = (id: string) => {
    onSelectDefect(id);
    setIsExpanded(false); // Collapse on select? Or keep open?
    setQuery(""); 
  };

  const handleExpand = () => {
      setIsExpanded(true);
      // Wait for animation/render then focus
      setTimeout(() => inputRef.current?.focus(), 100);
  }

  const handleCollapse = () => {
      setIsExpanded(false);
      setQuery("");
  }

  // Click outside to collapse
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        if (!query) { // Only collapse if empty, otherwise keep results open
            setIsExpanded(false);
        }
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [query]);

  return (
    <div ref={containerRef} className={cn(
        "relative flex items-center transition-all duration-300 ease-in-out",
        isExpanded ? "w-64" : "w-10" // Animate width
    )}>
      
      {/* The Search Icon Button (Always Visible or part of input) */}
      <div className={cn(
          "absolute inset-y-0 left-0 flex items-center justify-center z-20",
          isExpanded ? "pointer-events-none" : "cursor-pointer"
      )}
        onClick={!isExpanded ? handleExpand : undefined}
      >
          <Button 
            variant={isExpanded ? "ghost" : "secondary"} 
            size="icon" 
            className={cn(
                "h-10 w-10 shadow-md transition-all", 
                isExpanded ? "bg-transparent shadow-none hover:bg-transparent" : ""
            )}
          >
            <Search className={cn("h-4 w-4", isExpanded ? "text-muted-foreground" : "")} />
          </Button>
      </div>

      {/* The Input Field (Hidden/Shown) */}
      <Input
          ref={inputRef}
          placeholder="Find defects..."
          className={cn(
           "pl-10 pr-8 bg-card/90 backdrop-blur border-border shadow-md h-10 transition-all duration-300",
            isExpanded ? "opacity-100 w-full" : "opacity-0 w-0 p-0 border-none"
          )}
          value={query}
          onChange={(e) => setQuery(e.target.value)}
      />

      {/* Close Button (Only when expanded) */}
      {isExpanded && (
          <button 
              onClick={handleCollapse}
              className="absolute right-2 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground z-20"
          >
              <X className="h-4 w-4" />
          </button>
      )}

      {/* Results Dropdown */}
      {isExpanded && query.length > 0 && (
        <div className="absolute top-full right-0 mt-2 w-full bg-card border border-border rounded-md shadow-xl max-h-60 overflow-y-auto z-50">
          {filteredDefects.length === 0 ? (
            <div className="p-3 text-sm text-muted-foreground text-center">No results found.</div>
          ) : (
            <ul className="py-1">
              {filteredDefects.map((defect) => (
                <li
                  key={defect.id}
                  onClick={() => handleSelect(defect.id)}
                  className="px-3 py-2 hover:bg-accent cursor-pointer text-sm flex items-center justify-between group border-b border-border/50 last:border-0"
                >
                  <div className="flex flex-col overflow-hidden">
                    <span className="font-medium truncate">{defect.type!.replace('_', ' ')}</span>
                    {defect.notes && (
                        <span className="text-xs text-muted-foreground truncate">
                            {defect.notes}
                        </span>
                    )}
                  </div>
                  <span className={cn(
                      "text-[10px] px-1.5 py-0.5 rounded font-bold shrink-0 ml-2",
                      defect.severity === 'CRITICAL' ? "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400" :
                      defect.severity === 'HIGH' ? "bg-orange-100 text-orange-700 dark:bg-orange-900/30 dark:text-orange-400" :
                      "bg-slate-100 text-slate-700 dark:bg-slate-800 dark:text-slate-400"
                  )}>
                      {defect.severity}
                  </span>
                </li>
              ))}
            </ul>
          )}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/3D_Viewer/components/layer-control.tsx">
'use client';

import { useState, useRef, useEffect } from "react";
import { Layers, Cuboid, AlertCircle, X, ChevronDown, ChevronRight } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";

export type SeverityVisibility = {
    CRITICAL: boolean;
    HIGH: boolean;
    MEDIUM: boolean;
    LOW: boolean;
};


type LayerControlProps = {
  showTileset: boolean;
  toggleTileset: () => void;
  severityVisibility: SeverityVisibility;
  toggleSeverity: (severity: keyof SeverityVisibility) => void;
  toggleAllDefects: (show: boolean) => void;
};

export const LayerControl = ({
  showTileset,
  toggleTileset,
  severityVisibility,
  toggleSeverity,
  toggleAllDefects
}: LayerControlProps) => {
  const [isOpen, setIsOpen] = useState(false);
  const [isDefectsExpanded, setIsDefectsExpanded] = useState(true); // Start expanded
  const menuRef = useRef<HTMLDivElement>(null);

  // Check if all are true or some are true
  const allDefectsVisible = Object.values(severityVisibility).every(Boolean);
  const someDefectsVisible = Object.values(severityVisibility).some(Boolean);

  // Close when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  return (
    <div className="relative" ref={menuRef}>
      <Button 
        variant={isOpen ? "secondary" : "outline"}
        size="icon" 
        className="h-8 w-8"
        onClick={() => setIsOpen(!isOpen)}
        title="Layers"
      >
        <Layers className="h-4 w-4" />
      </Button>

      {isOpen && (
        <div className={cn(
            "absolute top-0 left-12 w-64 p-4 z-50 ml-2", // Positioned to the right of the toolbar
            "bg-card/95 backdrop-blur border border-border",
            "rounded-lg shadow-xl animate-in fade-in zoom-in-95 duration-100"
        )}>
          <div className="flex items-center justify-between mb-4">
            <h4 className="font-medium text-sm text-foreground">Map Layers</h4>
            <Button variant="ghost" size="icon" onClick={() => setIsOpen(false)} className="h-6 w-6">
                <X className="h-3 w-3" />
            </Button>
          </div>
          
          <div className="space-y-4">
            {/* 1. 3D Model Toggle (Simple) */}
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                  <div className="p-1.5 bg-blue-100 dark:bg-blue-900/30 rounded-md">
                    <Cuboid className="h-4 w-4 text-blue-600 dark:text-blue-400" />
                  </div>
                  <Label htmlFor="tileset" className="cursor-pointer text-sm font-medium">3D Model</Label>
              </div>
              <input 
                  id="tileset"
                  type="checkbox" 
                  checked={showTileset} 
                  onChange={toggleTileset}
                  className="h-4 w-4 rounded border-input text-primary focus:ring-ring cursor-pointer"
              />
            </div>

            <div className="h-px bg-border" />

            {/* 2.  Defects Group (Expandable) */}
            <div>
                <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-1">
                        <Button 
                            variant="ghost" 
                            size="icon" 
                            className="h-5 w-5 p-0 hover:bg-transparent"
                            onClick={() => setIsDefectsExpanded(!isDefectsExpanded)}
                        >
                            {isDefectsExpanded ? <ChevronDown className="h-3 w-3" /> : <ChevronRight className="h-3 w-3" />}
                        </Button>
                        
                        <div className="flex items-center gap-2 ml-1">
                            <div className="p-1.5 bg-red-100 dark:bg-red-900/30 rounded-md">
                                <AlertCircle className="h-4 w-4 text-red-600 dark:text-red-400" />
                            </div>
                            <Label htmlFor="defects-group" className="cursor-pointer text-sm font-medium">Defects</Label>
                        </div>
                    </div>
                    
                    {/* Master Checkbox */}
                    <input 
                        id="defects-group"
                        type="checkbox" 
                        checked={allDefectsVisible}
                        // Indeterminate visual logic usually requires a custom checkbox component, 
                        // but logic-wise: if not all visible, clicking makes them all visible.
                        onChange={() => toggleAllDefects(!allDefectsVisible)} 
                        className="h-4 w-4 rounded border-input text-primary focus:ring-ring cursor-pointer"
                    />
                </div>

                {/* 3. Nested Severity Toggles */}
                {isDefectsExpanded && (
                    <div className="ml-9 space-y-2 border-l border-border pl-3">
                        
                        {/* Critical */}
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <div className="w-2 h-2 rounded-full bg-red-600 shadow-sm" />
                                <span className="text-xs text-muted-foreground">Critical</span>
                            </div>
                            <input 
                                type="checkbox"
                                checked={severityVisibility.CRITICAL}
                                onChange={() => toggleSeverity("CRITICAL")}
                                className="h-3 w-3 rounded border-input cursor-pointer"
                            />
                        </div>

                        {/* High */}
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <div className="w-2 h-2 rounded-full bg-orange-500 shadow-sm" />
                                <span className="text-xs text-muted-foreground">High</span>
                            </div>
                            <input 
                                type="checkbox"
                                checked={severityVisibility.HIGH}
                                onChange={() => toggleSeverity("HIGH")}
                                className="h-3 w-3 rounded border-input cursor-pointer"
                            />
                        </div>

                        {/* Medium */}
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <div className="w-2 h-2 rounded-full bg-yellow-400 shadow-sm" />
                                <span className="text-xs text-muted-foreground">Medium</span>
                            </div>
                            <input 
                                type="checkbox"
                                checked={severityVisibility.MEDIUM}
                                onChange={() => toggleSeverity("MEDIUM")}
                                className="h-3 w-3 rounded border-input cursor-pointer"
                            />
                        </div>

                        {/* Low */}
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <div className="w-2 h-2 rounded-full bg-green-500 shadow-sm" />
                                <span className="text-xs text-muted-foreground">Low</span>
                            </div>
                            <input 
                                type="checkbox"
                                checked={severityVisibility.LOW}
                                onChange={() => toggleSeverity("LOW")}
                                className="h-3 w-3 rounded border-input cursor-pointer"
                            />
                        </div>

                    </div>
                )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/3D_Viewer/debug-projection.ts">
import { Cartesian3 } from 'cesium';
import { getRayFromPixel, rodriguesToMatrix } from './get-Ray-From-Pixel';

export const debugCameraProjection = (
    CesiumJs: any,
    viewer: any,
    cameraData: any,
    localToWorld: any,
    dataSource: any
) => {
    if (!viewer || !cameraData || !dataSource) {
        console.error("Missing required parameters for debug");
        return;
    }

    console.log("=== DEBUG CAMERA PROJECTION ===");
    console.log("Camera Data:", JSON.stringify(cameraData, null, 2));

    // Get camera position from GPS
    const cameraPosECEF = CesiumJs.Cartesian3.fromDegrees(
        cameraData.gpsPosition.lon,
        cameraData.gpsPosition.lat,
        cameraData.gpsPosition.alt
    );

    // Create fresh ENU transform at camera position
    const enuTransform = CesiumJs.Transforms.eastNorthUpToFixedFrame(cameraPosECEF);

    console.log("Camera Position ECEF:", {
        x: cameraPosECEF.x,
        y: cameraPosECEF.y,
        z: cameraPosECEF.z
    });

    // Clear previous debug entities
    const entitiesToRemove: any[] = [];
    dataSource.entities.values.forEach((entity: any) => {
        if (entity.id && entity.id.startsWith('debug_')) {
            entitiesToRemove.push(entity);
        }
    });
    entitiesToRemove.forEach((e: any) => dataSource.entities.remove(e));

    // Draw camera position
    dataSource.entities.add({
        id: `debug_cam_pos_${Date.now()}`,
        position: cameraPosECEF,
        point: {
            pixelSize: 20,
            color: CesiumJs.Color.MAGENTA,
            outlineColor: CesiumJs.Color.WHITE,
            outlineWidth: 3,
            disableDepthTestDistance: Number.POSITIVE_INFINITY
        },
        label: {
            text: 'Camera',
            font: '14px sans-serif',
            fillColor: CesiumJs.Color.WHITE,
            showBackground: true,
            backgroundColor: CesiumJs.Color.MAGENTA.withAlpha(0.8),
            pixelOffset: new CesiumJs.Cartesian2(0, -30),
            disableDepthTestDistance: Number.POSITIVE_INFINITY
        }
    });

    // Draw frustum corners
    const testPoints = [
        { x: cameraData.width / 2, y: cameraData.height / 2, name: 'CENTER', color: CesiumJs.Color.WHITE },
        { x: 0, y: 0, name: 'TL', color: CesiumJs.Color.RED },
        { x: cameraData.width, y: 0, name: 'TR', color: CesiumJs.Color.GREEN },
        { x: cameraData.width, y: cameraData.height, name: 'BR', color: CesiumJs.Color.BLUE },
        { x: 0, y: cameraData.height, name: 'BL', color: CesiumJs.Color.YELLOW },
    ];

    const rayLength = 100; // meters

    testPoints.forEach((testPoint, idx) => {
        const ray = getRayFromPixel(
            CesiumJs,
            { x: testPoint.x, y: testPoint.y },
            cameraData,
            cameraPosECEF,
            enuTransform
        );

        if (ray) {
            const endPoint = CesiumJs.Cartesian3.add(
                ray.origin,
                CesiumJs.Cartesian3.multiplyByScalar(
                    ray.direction, 
                    rayLength, 
                    new CesiumJs.Cartesian3()
                ),
                new CesiumJs.Cartesian3()
            );

            // Draw ray line
            dataSource.entities.add({
                id: `debug_ray_${testPoint.name}_${Date.now()}`,
                polyline: {
                    positions: [ray.origin, endPoint],
                    width: 3,
                    material: testPoint.color,
                    arcType: CesiumJs.ArcType.NONE
                }
            });

            // Draw endpoint
            dataSource.entities.add({
                id: `debug_rayend_${testPoint.name}_${Date.now()}`,
                position: endPoint,
                point: {
                    pixelSize: 10,
                    color: testPoint.color,
                    outlineColor: CesiumJs.Color.BLACK,
                    outlineWidth: 2,
                    disableDepthTestDistance: Number.POSITIVE_INFINITY
                },
                label: {
                    text: testPoint.name,
                    font: '12px sans-serif',
                    fillColor: CesiumJs.Color.WHITE,
                    showBackground: true,
                    backgroundColor: testPoint.color.withAlpha(0.8),
                    pixelOffset: new CesiumJs.Cartesian2(0, -20),
                    disableDepthTestDistance: Number.POSITIVE_INFINITY
                }
            });

            // Try to pick the scene
            const scene = viewer.scene;
            const pickResult = scene.pickFromRay(ray);
            
            if (pickResult && pickResult.position) {
                dataSource.entities.add({
                    id: `debug_hit_${testPoint.name}_${Date.now()}`,
                    position: pickResult.position,
                    point: {
                        pixelSize: 15,
                        color: CesiumJs.Color.LIME,
                        outlineColor: CesiumJs.Color.BLACK,
                        outlineWidth: 3,
                        disableDepthTestDistance: Number.POSITIVE_INFINITY
                    }
                });
                console.log(`✅ ${testPoint.name} HIT:`, pickResult.position);
            } else {
                console.log(`❌ ${testPoint.name} MISS`);
            }
        } else {
            console.error(`❌ Failed to create ray for ${testPoint.name}`);
        }
    });

    // Draw coordinate axes at camera position
    const axisLength = 20;
    const axes = [
        { dir: new CesiumJs.Cartesian3(1, 0, 0), color: CesiumJs.Color.RED, name: 'X (East)' },
        { dir: new CesiumJs.Cartesian3(0, 1, 0), color: CesiumJs.Color.GREEN, name: 'Y (North)' },
        { dir: new CesiumJs.Cartesian3(0, 0, 1), color: CesiumJs.Color.BLUE, name: 'Z (Up)' },
    ];

    const enuRotation = CesiumJs.Matrix4.getMatrix3(enuTransform, new CesiumJs.Matrix3());

    axes.forEach(axis => {
        const dirWorld = CesiumJs.Matrix3.multiplyByVector(
            enuRotation,
            axis.dir,
            new CesiumJs.Cartesian3()
        );
        CesiumJs.Cartesian3.normalize(dirWorld, dirWorld);

        const endPoint = CesiumJs.Cartesian3.add(
            cameraPosECEF,
            CesiumJs.Cartesian3.multiplyByScalar(dirWorld, axisLength, new CesiumJs.Cartesian3()),
            new CesiumJs.Cartesian3()
        );

        dataSource.entities.add({
            id: `debug_axis_${axis.name}_${Date.now()}`,
            polyline: {
                positions: [cameraPosECEF, endPoint],
                width: 5,
                material: axis.color
            }
        });
    });

    console.log("=== DEBUG COMPLETE ===");
    viewer.scene.requestRender();
};
</file>

<file path="src/components/3D_Viewer/example_utils/date.ts">
import { CesiumType } from "../types/cesium";
import type { JulianDate } from "cesium";

export function dateToJulianDate(CesiumJs: CesiumType, date: Date): JulianDate {
    return CesiumJs.JulianDate.fromDate(date)
}
</file>

<file path="src/components/3D_Viewer/get-Orientation-From-Rodrigues.ts">
// Helper: Convert Rodrigues Vector (from shots.geojson) to Cesium Orientation
export const getOrientationFromRodrigues = (CesiumJs: any, rotVec: number[]): any => {
    const [rx, ry, rz] = rotVec;
    const theta = Math.sqrt(rx * rx + ry * ry + rz * rz);
    
    if (theta < 1e-10) {
        return CesiumJs.Matrix3.IDENTITY.clone();
    }
    
    // Normalized axis
    const kx = rx / theta;
    const ky = ry / theta;
    const kz = rz / theta;
    
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const v = 1 - c;
    
    // Rodrigues formula: R = I + sin(θ)K + (1-cos(θ))K²
    // where K is the skew-symmetric matrix of the axis
    const m=  new CesiumJs.Matrix3(
        c + kx * kx * v,      kx * ky * v - kz * s, kx * kz * v + ky * s,
        ky * kx * v + kz * s, c + ky * ky * v,      ky * kz * v - kx * s,
        kz * kx * v - ky * s, kz * ky * v + kx * s, c + kz * kz * v
    );

    return CesiumJs.Quaternion.fromRotationMatrix(m);
};
</file>

<file path="src/components/3D_Viewer/imagery_basemaps.ts">
import { CesiumType } from "./types/cesium";


export const basemapsLayers =  ( CesiumJs: CesiumType,)=>{

        /* Per Carto's website regarding basemap attribution: https://carto.com/help/working-with-data/attribution/#basemaps */
    const CartoAttribution = 'Map tiles by <a href="https://carto.com">Carto</a>, under CC BY 3.0. Data by <a href="https://www.openstreetmap.org/">OpenStreetMap</a>, under ODbL.'

    // Create ProviderViewModel based on different imagery sources
    // - these can be used without CesiumJs Ion
    const imageryViewModels = [];

    imageryViewModels.push(new CesiumJs.ProviderViewModel({
        name: 'OpenStreetMap',
        iconUrl: CesiumJs.buildModuleUrl('Widgets/Images/ImageryProviders/openStreetMap.png'),
        tooltip: 'OpenStreetMap (OSM) is a collaborative project to create a free editable \
                    map of the world.\nhttp://www.openstreetmap.org',
        creationFunction: function() {
        return new CesiumJs.UrlTemplateImageryProvider({
            url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            subdomains: 'abc',
            minimumLevel: 0,
            maximumLevel: 19
        });
        }
    }));
    imageryViewModels.push(new CesiumJs.ProviderViewModel({
        name: 'Positron',
        tooltip: 'CartoDB Positron basemap',
        iconUrl: 'http://a.basemaps.cartocdn.com/light_all/5/15/12.png',
        creationFunction: function() {
        return new CesiumJs.UrlTemplateImageryProvider({
            url: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
            credit: CartoAttribution,
            minimumLevel: 0,
            maximumLevel: 18
        });
        }
    }));
    imageryViewModels.push(new CesiumJs.ProviderViewModel({
        name: 'Positron without labels',
        tooltip: 'CartoDB Positron without labels basemap',
        iconUrl: 'http://a.basemaps.cartocdn.com/rastertiles/light_nolabels/5/15/12.png',
        creationFunction: function() {
        return new CesiumJs.UrlTemplateImageryProvider({
            url: 'https://{s}.basemaps.cartocdn.com/rastertiles/light_nolabels/{z}/{x}/{y}.png',
            credit: CartoAttribution,
            minimumLevel: 0,
            maximumLevel: 18
        });
        }
    }));
    imageryViewModels.push(new CesiumJs.ProviderViewModel({
        name: 'Dark Matter',
        tooltip: 'CartoDB Dark Matter basemap',
        iconUrl: 'http://a.basemaps.cartocdn.com/rastertiles/dark_all/5/15/12.png',
        creationFunction: function() {
        return new CesiumJs.UrlTemplateImageryProvider({
            url: 'https://{s}.basemaps.cartocdn.com/rastertiles/dark_all/{z}/{x}/{y}.png',
            credit: CartoAttribution,
            minimumLevel: 0,
            maximumLevel: 18
        });
        }
    }));
    imageryViewModels.push(new CesiumJs.ProviderViewModel({
        name: 'Dark Matter without labels',
        tooltip: 'CartoDB Dark Matter without labels basemap',
        iconUrl: 'http://a.basemaps.cartocdn.com/rastertiles/dark_nolabels/5/15/12.png',
        creationFunction: function() {
        return new CesiumJs.UrlTemplateImageryProvider({
            url: 'https://{s}.basemaps.cartocdn.com/rastertiles/dark_nolabels/{z}/{x}/{y}.png',
            credit: CartoAttribution,
            minimumLevel: 0,
            maximumLevel: 18
        });
        }
    }));
    imageryViewModels.push(new CesiumJs.ProviderViewModel({
        name: 'Voyager',
        tooltip: 'CartoDB Voyager basemap',
        iconUrl: 'http://a.basemaps.cartocdn.com/rastertiles/voyager_labels_under/5/15/12.png',
        creationFunction: function() {
        return new CesiumJs.UrlTemplateImageryProvider({
            url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}.png',
            credit: CartoAttribution,
            minimumLevel: 0,
            maximumLevel: 18
        });
        }
    }));
    imageryViewModels.push(new CesiumJs.ProviderViewModel({
        name: 'Voyager without labels',
        tooltip: 'CartoDB Voyager without labels basemap',
        iconUrl: 'http://a.basemaps.cartocdn.com/rastertiles/voyager_nolabels/5/15/12.png',
        creationFunction: function() {
        return new CesiumJs.UrlTemplateImageryProvider({
            url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}.png',
            credit: CartoAttribution,
            minimumLevel: 0,
            maximumLevel: 18
        });
        }
    }));
    imageryViewModels.push(new CesiumJs.ProviderViewModel({
        name: 'National Map Satellite',
        tooltip: 'National Map Satellite',
        iconUrl: 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/4/6/4',
        creationFunction: function() {
        return new CesiumJs.UrlTemplateImageryProvider({
            url: 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}',
            credit: 'Tile data from <a href="https://basemap.nationalmap.gov/">USGS</a>',
            minimumLevel: 0,
            maximumLevel: 16
        });
        }
    }));

    return imageryViewModels;

};
</file>

<file path="src/components/3D_Viewer/types/cesium.ts">
export type CesiumType = typeof import('cesium');
</file>

<file path="src/components/3D_Viewer/types/map.ts">
export type MapLayer = {
  id: string;
  name: string;
  type: '3D_TILES' | 'IMAGERY' | 'POINT_CLOUD';
  url: string;
  visible: boolean;
  opacity?: number; // Useful for orthophotos
  isBaseLayer?: boolean; // To know which one to "Zoom To"
};
</file>

<file path="src/components/3D_Viewer/types/position.ts">
export type Position = {
    lat: number,
    lng: number
  }
</file>

<file path="src/components/3D_Viewer/utils/camera-math.ts">
// utils/camera-math.ts (or put at top of cesium.tsx)
import { Cartesian3, Math as CesiumMath, Entity, Cartesian2, Scene, defined, Quaternion, Matrix4, Matrix3 } from 'cesium';
import { CesiumType } from '../types/cesium'; // Your type definition

interface CameraScore {
  entity: Entity;
  score: number;
}

/**
 * Calculates the surface normal at a picked location by sampling neighboring pixels.
 */
export const getSurfaceNormal = (scene: Scene, windowPosition: Cartesian2): Cartesian3 | null => {
    // 1. Pick the center point
    const center = scene.pickPosition(windowPosition);
    if (!defined(center)) return null;

    // 2. Pick two neighbors (1 pixel right, 1 pixel up)
    const right = scene.pickPosition(new Cartesian2(windowPosition.x + 1, windowPosition.y));
    const up = scene.pickPosition(new Cartesian2(windowPosition.x, windowPosition.y + 1));

    if (!defined(right) || !defined(up)) return null;

    // 3. Create vectors
    const v1 = Cartesian3.subtract(right, center, new Cartesian3());
    const v2 = Cartesian3.subtract(up, center, new Cartesian3());

    // 4. Cross Product = Normal Vector
    // Note: The order (v1 x v2) vs (v2 x v1) depends on coordinate system, 
    // usually Cesium creates an outward normal with this order.
    const normal = Cartesian3.cross(v1, v2, new Cartesian3());
    
    return Cartesian3.normalize(normal, new Cartesian3());
};

/**
 * Ranks all drone cameras to find which one has the best view of the target point.
 */
export const findBestCamera = (
  CesiumJs: any,
  targetPoint: Cartesian3,
  surfaceNormal: Cartesian3 | null, // <--- New Parameter
  cameraEntities: Entity[]
): Entity | null => {
  let bestCamera: Entity | null = null;
  let bestScore = -Infinity;

  cameraEntities.forEach((camera) => {
    const camPos = camera.position?.getValue(CesiumJs.JulianDate.now());
    if (!camPos) return;

    // 1. Distance Vector (Target -> Camera)
    // Note: We want the vector pointing FROM target TO camera to compare with normal
    const targetToCamera = CesiumJs.Cartesian3.subtract(camPos, targetPoint, new CesiumJs.Cartesian3());
    const distance = CesiumJs.Cartesian3.magnitude(targetToCamera);
    const targetToCameraNorm = CesiumJs.Cartesian3.normalize(targetToCamera, new CesiumJs.Cartesian3());

    if (distance > 100) return;

    // 2. Alignment (Is point in center of image?)
    // Camera View Vector (Camera -> Target)
    const cameraLookDir = CesiumJs.Cartesian3.negate(targetToCameraNorm, new CesiumJs.Cartesian3()); 
    
    // Get actual Camera Orientation
    const orientation = camera.orientation?.getValue(CesiumJs.JulianDate.now());
    const transform = CesiumJs.Matrix3.fromQuaternion(orientation);
    const cameraForward = CesiumJs.Matrix3.multiplyByVector(transform, CesiumJs.Cartesian3.UNIT_Z, new CesiumJs.Cartesian3());

    const viewAlignment = CesiumJs.Cartesian3.dot(cameraForward, cameraLookDir);
    if (viewAlignment < 0.5) return; // Must be somewhat in front of camera

    // 3. Incidence Angle (Are we facing the wall?)
    let incidenceScore = 0;
    if (surfaceNormal) {
        // Dot product of (Surface Normal) and (Vector To Camera)
        // 1.0 = Camera is directly perpendicular to surface (Best)
        // 0.0 = Camera is looking down the edge of the wall (Bad)
        const dot = CesiumJs.Cartesian3.dot(surfaceNormal, targetToCameraNorm);
        incidenceScore = Math.max(0, dot); 
    }

    // 4. FINAL SCORE FORMULA
    // We give HUGE weight (x200) to Incidence to force oblique views for inclined roofs
    const score = (viewAlignment * 100) - (distance * 0.5) + (incidenceScore * 200);

    if (score > bestScore) {
      bestScore = score;
      bestCamera = camera;
    }
  });

  return bestCamera;
};


// --- MATH HELPER: Project 3D World Point to 2D Image Pixel ---
export function projectWorldToImage(
    worldPosition: { x: number, y: number, z: number },
    cameraPose: { position: Cartesian3, orientation: Quaternion },
    intrinsics: { width: number, height: number, focal: number }
) {
    // 1. Convert World Point to Cesium Cartesian3
    const pointWS = new Cartesian3(worldPosition.x, worldPosition.y, worldPosition.z);

    // 2. Create View Matrix (World -> Camera) from Position & Orientation
    const viewMatrix = Matrix4.fromRotationTranslation(
        Matrix3.fromQuaternion(cameraPose.orientation),
        cameraPose.position
    );
    const inverseView = Matrix4.inverse(viewMatrix, new Matrix4());

    // 3. Transform Point to Camera Local Space
    // In Cesium (and standard GL), Camera looks down -Z. Right is +X, Up is +Y.
    const pointCamera = Matrix4.multiplyByPoint(inverseView, pointWS, new Cartesian3());

    // 4. Check Visibility (Is point behind camera?)
    // Note: Depending on your coordinate system convention (Y-up vs Z-up), 
    // "Forward" might be -Z or +Z. Standard Photogrammetry often uses -Z forward.
    if (pointCamera.z > 0) return null; // Behind the camera (assuming -Z view)

    // 5. Project to Image Plane (Pinhole Model)
    // x_screen = (focal * x_local) / -z_local
    // Note: We need focal length in PIXELS. If your focal is in mm, you need sensor width.
    // Assuming 'focal' passed here is already scaled to pixels (common in SfM outputs like Colmap/ODM)
    
    // If focal is 0 or missing, approximate using a standard FOV (e.g. 60 deg)
    const effectiveFocal = intrinsics.focal || (intrinsics.width * 0.8); 

    const u = (pointCamera.x / -pointCamera.z) * effectiveFocal;
    const v = (pointCamera.y / -pointCamera.z) * effectiveFocal;

    // 6. Map to Pixel Coordinates (Center is 0,0 -> TopLeft is 0,0)
    // Adjust signs based on coordinate system (Y is usually inverted in images)
    const xPixel = (intrinsics.width / 2) + u;
    const yPixel = (intrinsics.height / 2) - v; 

    // 7. Bounds Check
    if (xPixel < 0 || xPixel > intrinsics.width || yPixel < 0 || yPixel > intrinsics.height) {
        return null;
    }

    return { x: xPixel, y: yPixel };
}
</file>

<file path="src/components/3D_Viewer/utils/intersection-utils.ts">
import { rodriguesToMatrix } from "../get-Ray-From-Pixel";

export const intersectRayWithPlane = (
    CesiumJs: any,
    ray: any,
    planeHeight: number
): any | null => {
    // 1. Calculate the surface normal (Up direction) at the ray origin
    const normal = CesiumJs.Ellipsoid.WGS84.geodeticSurfaceNormal(ray.origin);
    
    // 2. Define a point at the target height
    // We project the camera position to the correct altitude to anchor the plane
    const originCarto = CesiumJs.Cartographic.fromCartesian(ray.origin);
    const pointOnPlane = CesiumJs.Cartesian3.fromRadians(
        originCarto.longitude,
        originCarto.latitude,
        planeHeight
    );
    
    // 3. Create the mathematical plane
    const plane = CesiumJs.Plane.fromPointNormal(pointOnPlane, normal);
    
    // 4. Find intersection
    // ⚠️ FIX: This returns a Cartesian3 POINT, not a distance number!
    const intersectionPoint = CesiumJs.IntersectionTests.rayPlane(ray, plane);
    
    // If intersectionPoint is defined, return it directly.
    return intersectionPoint || null;
};

// Put these helpers near your other utils (or above handleCrackProjection)

// Set Cesium camera to the drone camera pose and FOV so depth buffer aligns with the image
export async function setCesiumCameraToDrone(CesiumJs:any, scene:any, cameraData:any, cameraPosECEF:any, localToWorldTransform:any) {
    // Compute forward (camera center - camera frame forward) and up vector
    // Use the same math used to compute dir for pixels but use center pixel (xn=0, yn=0)
    const cx = cameraData.width / 2;
    const cy = cameraData.height / 2;
    const f_pixels = cameraData.focal * Math.max(cameraData.width, cameraData.height);

    // Rotation matrix (world->camera), transpose to get camera->world
    const R_world_to_cam = rodriguesToMatrix(CesiumJs, cameraData.rotation);
    const R_cam_to_world = CesiumJs.Matrix3.transpose(R_world_to_cam, new CesiumJs.Matrix3());

    // camera forward in camera coords (OpenSfM): (0, 0, 1)
    const forwardCam = new CesiumJs.Cartesian3(0, 0, 1);
    const upCam = new CesiumJs.Cartesian3(0, -1, 0); // Y is down in OpenSfM -> up = -Y

    // Rotate to local/world (camera->world)
    const forwardLocal = CesiumJs.Matrix3.multiplyByVector(R_cam_to_world, forwardCam, new CesiumJs.Cartesian3());
    const upLocal = CesiumJs.Matrix3.multiplyByVector(R_cam_to_world, upCam, new CesiumJs.Cartesian3());

    // Apply tileset/world transform (localToWorldTransform) to get ECEF vectors
    const enuRot = CesiumJs.Matrix4.getMatrix3(localToWorldTransform, new CesiumJs.Matrix3());
    const forwardECEF = CesiumJs.Matrix3.multiplyByVector(enuRot, forwardLocal, new CesiumJs.Cartesian3());
    const upECEF = CesiumJs.Matrix3.multiplyByVector(enuRot, upLocal, new CesiumJs.Cartesian3());

    CesiumJs.Cartesian3.normalize(forwardECEF, forwardECEF);
    CesiumJs.Cartesian3.normalize(upECEF, upECEF);

    // Compute vertical FOV from focal (assumes focal in pixels when multiplied)
    const verticalFov = 2 * Math.atan(cameraData.height / (2 * f_pixels));

    // Apply to Cesium camera
    try {
        // Use a fresh PerspectiveFrustum with matching fov + aspect
        const canvas = scene.canvas;
        const aspect = canvas.clientWidth / canvas.clientHeight;
        scene.camera.frustum = new CesiumJs.PerspectiveFrustum({ fovy: verticalFov, aspectRatio: aspect });

        // Set view with direction/up (direction vector points FROM camera towards scene in Cesium terminology)
        scene.camera.setView({
            destination: cameraPosECEF,
            orientation: {
                direction: forwardECEF,
                up: upECEF
            }
        });

        // Ensure render & depth buffer warmed
        scene.requestRender();
    } catch (e) {
        console.warn("Failed to set Cesium camera to drone pose:", e);
    }
}

// Convert a point on the ray -> window coordinates (Cartesian2) if possible
export function getScreenPosFromRayPoint(CesiumJs:any, scene:any, ray:any, distance:any) {
    const testPoint = CesiumJs.Ray.getPoint(ray, distance);
    const screenPos = CesiumJs.SceneTransforms.worldToWindowCoordinates(scene, testPoint); // <-- fix below
    return screenPos ? new CesiumJs.Cartesian2(screenPos.x, screenPos.y) : null;
}
</file>

<file path="src/components/breadcrumbs.tsx">
import { LucideChevronDown, LucideSlash } from "lucide-react";
import Link from "next/link";
import { Fragment } from "react";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "./ui/breadcrumb";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "./ui/dropdown-menu";


type BreadcrumbsProps = {
  breadcrumbs: {
    title: string;
    href?: string;
    dropdown?:{
      title:string;
      href:string
    }[];
  }[];
};

const Breadcrumbs = ({ breadcrumbs }: BreadcrumbsProps) => {
  return (
    <Breadcrumb>
      <BreadcrumbList>
        {breadcrumbs.map((breadcrumb, index) => {
          let breadcrumbItem = (
            <BreadcrumbPage>{breadcrumb.title}</BreadcrumbPage>
          );

          if (breadcrumb.href) {
            breadcrumbItem = (
              <BreadcrumbLink asChild>
                <Link
                  href={breadcrumb.href}
                  className="flex items-center gap-1"
                >
                  {breadcrumb.title}
                </Link>
              </BreadcrumbLink>
            );
          }

          if(breadcrumb.dropdown){
            breadcrumbItem = (
              <DropdownMenu>
                <DropdownMenuTrigger className="flex items-center gap-1">
                  {breadcrumb.title}
                  <LucideChevronDown className="h-4 w-4" />
                </DropdownMenuTrigger>
                <DropdownMenuContent align="start" >
                  {breadcrumb.dropdown.map((item)=>(
                    <DropdownMenuItem asChild key={item.href} >
                      <Link href={item.href} >{item.title}</Link>
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>
            )
          }


          return (
            <Fragment key={breadcrumb.title}>
              <BreadcrumbItem>{breadcrumbItem}</BreadcrumbItem>
              {index < breadcrumbs.length - 1 && (
                <BreadcrumbSeparator>
                  <LucideSlash className="h-4 w-4" />
                </BreadcrumbSeparator>
              )}
            </Fragment>
          );
        })}
      </BreadcrumbList>
    </Breadcrumb>
  );
};

export { Breadcrumbs };
</file>

<file path="src/components/card-compact.tsx">
import { Card, 
CardContent, 
CardDescription, 
CardFooter, 
CardHeader, CardTitle } from "./ui/card";

type CardElemProps = {
title: string;
description: string;
content: React.ReactNode;
className?: string;
footer?: React.ReactNode;
}

export const CardElement = ({title, description, 
    content, className, footer}:CardElemProps ) => {
    return ( 
    <Card className={className} >
        <CardHeader>
            <CardTitle>{title}</CardTitle>
            <CardDescription>{description}</CardDescription>
        </CardHeader>
        <CardContent>
                    {content}
        </CardContent>
        {footer && <CardFooter>{footer}</CardFooter>}
    </Card>
     );
}
</file>

<file path="src/components/confirm-dialogue.tsx">
import React, { cloneElement, useActionState, useEffect, useRef, useState } from "react";


import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"
import { Button } from "./ui/button";
import { ActionState, EMPTY_ACTION_STATE } from "./forms/utils/to-action-state";
import { toast } from "sonner";
import { useActionFeedBack } from "./forms/hooks/use-actions-feedback";


type ConfirmDialogProps = {
    title ?: string;
    description ?: string;
    action: () =>  Promise<ActionState>;
    trigger: React.ReactElement<React.HTMLAttributes<HTMLElement>> | 
    ( (isPending: boolean)=> React.ReactElement<React.HTMLAttributes<HTMLElement>> ) ;
    onSuccess?: (actionState: ActionState) => void;
};
 
const useConfirmDialog = ({
    title='Are you absolutely sure?',
    description='This action cannot be undone.',
    action, trigger, onSuccess}: ConfirmDialogProps) => {
    
    const [isOpen, setIsOpen] = useState(false);

    const [actionState, formAction, isPending]= useActionState(action, EMPTY_ACTION_STATE)

    const dialogTrigger = cloneElement( typeof trigger === 'function' ? 
        trigger(isPending): trigger, {
        onClick: () => setIsOpen((state)=> !state),
    });

    const toastRef = useRef<string | number | null>(null);
    
    useEffect(()=>{
        if(isPending){
            toastRef.current = toast.loading('Deleting ...');
        } else if(toastRef.current){
            toast.dismiss(toastRef.current);
        }
        return () => {
            if(toastRef.current){
                toast.dismiss(toastRef.current);
            }
        }
    }, [isPending])

    useActionFeedBack(actionState, {
        onSuccess:({actionState})=>{
            if (actionState.message){
                toast.success(actionState.message);
            }
            onSuccess?.(actionState);
           },
        onError:({actionState})=>{
            if (actionState.message){
                toast.error(actionState.message);
                
            }  
        },
    });
    const dialog= (
        <AlertDialog open= {isOpen} onOpenChange={setIsOpen} >
            <AlertDialogContent>
                <AlertDialogHeader>
                <AlertDialogTitle>{title}</AlertDialogTitle>
                <AlertDialogDescription>
                    {description}
                </AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction asChild>
                    <form action={formAction}>
                        <Button type="submit" >Confirm</Button>
                    </form>
                </AlertDialogAction>
                </AlertDialogFooter>
            </AlertDialogContent>
        </AlertDialog>
    )
    
    return [dialogTrigger, dialog];
};


export {useConfirmDialog};
</file>

<file path="src/components/content.tsx">
import Linkify from "linkify-react";
import { IntermediateRepresentation } from "linkifyjs";
import Link from "next/link";
import { getBaseUrl } from "@/utils/url";

const renderLink = ({ attributes, content }: IntermediateRepresentation) => {
  const { href, ...props } = attributes;

  const isInternal = href.includes(getBaseUrl());
  const url = isInternal ? href.replace(getBaseUrl(), "") : href;

  const handleClick = (event: React.SyntheticEvent) => {
    if (isInternal) return;
    if (!confirm("Are you sure you want to leave this page?")) {
      event.preventDefault();
    }
  };

  let maybeParsedContent = content;
  if (url.startsWith("/tickets/")) {
    maybeParsedContent = url.replace("/tickets/", "Ticket: #");
  }

  // add other feature paths if needed

  return (
    <Link href={url} {...props} onClick={handleClick} className="underline">
      {maybeParsedContent}
    </Link>
  );
};

type ContentProps = {
  children: string;
};

const Content = ({ children }: ContentProps) => {
  return (
    <Linkify
      as="p"
      className="whitespace-pre-line"
      options={{ render: renderLink }}
    >
      {children}
    </Linkify>
  );
};

export { Content };
</file>

<file path="src/components/data-table.tsx">
"use client"
import * as React from "react"

import {
  ColumnDef,
  SortingState,
  VisibilityState,
  ColumnFiltersState,
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  useReactTable,
} from "@tanstack/react-table"

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"

import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"

import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from "lucide-react"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "./ui/select"

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[]
  data: TData[]
}

export function DataTable<TData, TValue>({
  columns,
  data,
}: DataTableProps<TData, TValue>) {
  const [sorting, setSorting] = React.useState<SortingState>([])
  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>(
    []
  )

  const [columnVisibility, setColumnVisibility] =React.useState<VisibilityState>({})
  const [rowSelection, setRowSelection] = React.useState({})

  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    onSortingChange: setSorting,
    getSortedRowModel: getSortedRowModel(),
    onColumnFiltersChange: setColumnFilters,
    getFilteredRowModel: getFilteredRowModel(),
    onColumnVisibilityChange: setColumnVisibility,
    onRowSelectionChange: setRowSelection,
    initialState: {
      pagination: {
        pageSize: 10,
      },
    },
    state: {
      sorting,
      columnFilters,
      columnVisibility,
      rowSelection,
    },
  })

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex flex-1 items-center space-x-2">
          <Input
            placeholder="Filter by defect type..."
            value={(table.getColumn("type")?.getFilterValue() as string) ?? ""}
            onChange={(event) =>
              table.getColumn("type")?.setFilterValue(event.target.value)
            }
            className="h-8 w-[150px] lg:w-[250px]"
          />
        </div>
        <div className="flex items-center space-x-2" >
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" className="ml-auto">
                Columns
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {table
                .getAllColumns()
                .filter(
                  (column) => column.getCanHide()
                )
                .map((column) => {
                  return (
                    <DropdownMenuCheckboxItem
                      key={column.id}
                      className="capitalize"
                      checked={column.getIsVisible()}
                      onCheckedChange={(value) =>
                        column.toggleVisibility(!!value)
                      }
                    >
                      {column.id}
                    </DropdownMenuCheckboxItem>
                  )
                })}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
      {/* overflow-hidden  */}
      
      <div className="rounded-md border overflow-hidden">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  return (
                    <TableHead key={header.id}>
                      {header.isPlaceholder
                        ? null
                        : flexRender(
                            header.column.columnDef.header,
                            header.getContext()
                          )}
                    </TableHead>
                  )
                })}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={columns.length} className="h-24 text-center">
                  No results.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>
      {/* <div className="flex items-center justify-end space-x-2 py-4">
          <Button
            variant="outline"
            size="sm"
            onClick={() => table.previousPage()}
            disabled={!table.getCanPreviousPage()}
          >
            Previous
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => table.nextPage()}
            disabled={!table.getCanNextPage()}
          >
            Next
          </Button>
      </div> */}
            {/* Pagination Controls  sticky bottom-0 */}
      <div className="flex items-center justify-between px-2 py-4 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 z-10 border-t">
        <div className="flex-1 text-sm text-muted-foreground">
          {table.getFilteredSelectedRowModel().rows.length} of{" "}
          {table.getFilteredRowModel().rows.length} row(s) selected.
        </div>
        <div className="flex items-center space-x-6 lg:space-x-8">
          <div className="flex items-center space-x-2">
            <p className="text-sm font-medium">Rows per page</p>
            <Select
              value={`${table.getState().pagination.pageSize}`}
              onValueChange={(value) => {
                table.setPageSize(Number(value))
              }}
            >
              <SelectTrigger className="h-8 w-[70px]">
                <SelectValue placeholder={table.getState().pagination.pageSize} />
              </SelectTrigger>
              <SelectContent side="top">
                {[5, 10, 20, 30, 40, 50].map((pageSize) => (
                  <SelectItem key={pageSize} value={`${pageSize}`}>
                    {pageSize}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <div className="flex w-[100px] items-center justify-center text-sm font-medium">
            Page {table.getState().pagination.pageIndex + 1} of{" "}
            {table.getPageCount()}
          </div>
          <div className="flex items-center space-x-2">
            <Button
              variant="outline"
              className="hidden h-8 w-8 p-0 lg:flex"
              onClick={() => table.setPageIndex(0)}
              disabled={!table.getCanPreviousPage()}
            >
              <span className="sr-only">Go to first page</span>
              <ChevronsLeft className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              className="h-8 w-8 p-0"
              onClick={() => table.previousPage()}
              disabled={!table.getCanPreviousPage()}
            >
              <span className="sr-only">Go to previous page</span>
              <ChevronLeft className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              className="h-8 w-8 p-0"
              onClick={() => table.nextPage()}
              disabled={!table.getCanNextPage()}
            >
              <span className="sr-only">Go to next page</span>
              <ChevronRight className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              className="hidden h-8 w-8 p-0 lg:flex"
              onClick={() => table.setPageIndex(table.getPageCount() - 1)}
              disabled={!table.getCanNextPage()}
            >
              <span className="sr-only">Go to last page</span>
              <ChevronsRight className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/date-picker.tsx">
"use client"

import * as React from "react"
import { ChevronDownIcon } from "lucide-react"

import { Button } from "@/components/ui/button"
import { Calendar } from "@/components/ui/calendar"

import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover"
import { format } from "date-fns"
import { useImperativeHandle } from "react"

export type ImperativeHandleFromDatePicker = {
  reset: () => void;
};

type DatePickerProps = {
    id:  string;
    name: string;
    defaultValue?: string | undefined;
    imperativeHandleRef?: React.RefObject<ImperativeHandleFromDatePicker | null>;
};

const DatePicker = ({id, name, defaultValue,imperativeHandleRef,}: DatePickerProps)  => {
  const [open, setOpen] = React.useState(false)
  const [date, setDate] = React.useState<Date | undefined>(
    defaultValue ?  new Date(defaultValue) : new Date()
  );

useImperativeHandle(imperativeHandleRef, () => ({
    reset: () => setDate(new Date()),
  }));

const formattedDate = date ? format(date, 'yyyy-MM-dd') : "";

  return (
    <div className="flex flex-col gap-3">
      <Popover open={open} onOpenChange={setOpen}>
        <PopoverTrigger className="w-full" id={id} asChild>
          <Button
            variant="outline"
           
            className="justify-start text-left-font-normal"
          >
            {formattedDate}
            <input type="hidden" name={name} value={formattedDate}  />
            <ChevronDownIcon />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-auto overflow-hidden p-0" align="start">
          <Calendar
            mode="single"
            selected={date}
            captionLayout="dropdown"
            onSelect={(date) => {
              setDate(date)
              setOpen(false)
            }}
          />
        </PopoverContent>
      </Popover>
    </div>
  )
};

export { DatePicker};
</file>

<file path="src/components/forms/field-error.tsx">
import { ActionState } from "./utils/to-action-state";

type FieldsErrorProp= {
    actionState: ActionState;
    name: string;
}

const FieldErrorMsg = ({actionState, name}: FieldsErrorProp) => {

    const msg= actionState.fieldErrors[name]?.[0];
    if (!msg) return null;
    console.log(actionState.fieldErrors[name])

    return ( 
        <span className="text-xs  text-red-500" >
            {msg}
        </span>
     );
}

export {FieldErrorMsg};
</file>

<file path="src/components/forms/form.tsx">
import { toast, ToastT } from "sonner";
import { useActionFeedBack } from "./hooks/use-actions-feedback";
import { ActionState } from "./utils/to-action-state";

type FormProps= {
    action: (payload: FormData)=>void;
    actionState: ActionState;
    children: React.ReactNode;
    onSuccess? : (actionState: ActionState) => void;
    onError? : (actionState: ActionState) => void;
    toastOptions?: Omit<ToastT, "id"> | undefined;
}

const Form = ({action, actionState, children,
    onSuccess, onError, toastOptions}: FormProps) => {
    useActionFeedBack(actionState, {
        onSuccess:({actionState})=>{
            if (actionState.message){
                toast.success(actionState.message, toastOptions);
            }
            onSuccess?.(actionState);
           },
        onError:({actionState})=>{
            if (actionState.message){
                toast.error(actionState.message, toastOptions);
                
            }
            onError?.(actionState); 
        },
    });
    return ( 
        <form action={action} 
            className="flex flex-col gap-y-2" >
                {children}
        </form>
     );
}

export {Form};
</file>

<file path="src/components/forms/hooks/use-actions-feedback.ts">
'use client';
import { useEffect, useRef } from "react";
import { ActionState } from "../utils/to-action-state";

type OnArgs = {
    actionState: ActionState;
}

type UseActionsFeedBackOptions = {
    onSuccess?: (onArgs: OnArgs)=> void;
    onError?: (onArgs: OnArgs)=> void;
}

const useActionFeedBack = (actionState: ActionState,
     options: UseActionsFeedBackOptions) => {
    
    const prevTimestamp = useRef(actionState.timestamp);
    const isUpdate =prevTimestamp.current  !== actionState.timestamp;
    
    useEffect(()=>{
        if(!isUpdate) return;

        if(actionState.status === 'Success'){
            //options.onSuccess?.(); 
            if(options.onSuccess){
                options.onSuccess({actionState}); 
            }
        } 
        if(actionState.status === 'Error'){
             //options.onError?.(); 
            if(options.onError){
                options.onError({actionState});
            }
        }

        prevTimestamp.current = actionState.timestamp;

    }, [isUpdate, actionState, options])
    
};

export { useActionFeedBack };
</file>

<file path="src/components/forms/utils/to-action-state.ts">
import { ZodError } from "zod";

export type ActionState <T = undefined> = {
     status?: 'Success' | 'Error';
     message:string; 
     payload?: FormData;
     fieldErrors: Record<string, string[] | undefined>;
     timestamp: number;
     data?:T;
};

export const EMPTY_ACTION_STATE: ActionState = {
     message: '',
     fieldErrors: {},
     timestamp: Date.now(),
};

export const formErrorToActionState = (
    error: unknown,
    formData?: FormData
): ActionState => {

     if(error instanceof ZodError){
           const zodError = error as ZodError;
          return {
               status: 'Error',
               message: '',
               fieldErrors: zodError.flatten().fieldErrors,
               payload: formData,
               timestamp: Date.now(),
          };
          
     } else if ( error instanceof Error){
          return {
               status: 'Error',
               message: error.message,
               fieldErrors: {},
               payload: formData,
               timestamp: Date.now(),
          };
     }
     
     else {
          return {
               status: 'Error',
               message: "An unknown error went wrong", 
               fieldErrors: {},
               payload: formData,
               timestamp: Date.now(),
          };
     }

    };
 
export const toActionState = ( status: ActionState['status'] ,
     message:string,  formData?: FormData, data?:unknown ):ActionState =>{
     return {status ,message,
           fieldErrors: {},payload: formData,
           timestamp: Date.now(),}
}
</file>

<file path="src/components/heading.tsx">
import { Separator } from '@/components/ui/separator';

type HeadingProps={
    title: string;
    description?: string;
    tabs?: React.ReactNode;
    actions?: React.ReactNode;
};


const Heading = ({title, description, tabs, actions}: HeadingProps) => {
    return ( 
        <>
        {tabs}
        <div className='flex items-center justify-between px-8' >
            <div>
                <h2 className="text-3xl font-bold tracking-tight" >
                                 {title}
                </h2>
                { description && 
                (<p className="text-sm text-muted-foreground" >
                    {description}
                  </p>)
                }
            </div>
            <div className='flex gap-x-2' >{actions}</div>
        </div>
            
        <Separator />
        </>
     );
}
 
export default Heading;
</file>

<file path="src/components/pagination/constants.ts">
export const PAGE_SIZES = [5, 10, 25, 50, 100];
</file>

<file path="src/components/pagination/pagination.tsx">
import { paginationData } from "./types";
import { Button } from "../ui/button";
import { Select, SelectContent, SelectItem, SelectValue } from "../ui/select";
import { SelectTrigger } from "@radix-ui/react-select";
import { useTransition } from "react";
import { PAGE_SIZES } from "./constants";

type Page_Size={
    page: number,
    size: number,
};

type PaginationProps={
    pagination:Page_Size,
    onPagination:(page: Page_Size)=>void,
    paginationMetadata:paginationData<unknown>["metadata"],
}

export const Pagination = ({pagination, onPagination, paginationMetadata}: PaginationProps) => {
    const startOffset= pagination.page * pagination.size + 1;
    const endOffset = startOffset  - 1  + pagination.size;
    const actualEndOffset = Math.min(endOffset, paginationMetadata.count)
    const label = `${startOffset} - ${actualEndOffset} of ${paginationMetadata.count}`;

    const [isPending, startTransition]= useTransition()

    const handlePreviousPage =()=>{
        startTransition(()=>{
        onPagination({...pagination, page: pagination.page-1});
        })
    };

    const handleChangeSize = (size: string)=>{
        onPagination({page: 0, size:parseInt(size)})
    }

    const prevButton = (
        <Button variant='outline'
        size='sm'
        disabled={pagination.page < 1 || isPending}
        onClick={handlePreviousPage} 
        >
        Previous
        </Button>
    );
    const handleNextPage =()=>{
        startTransition(()=>{
        onPagination({...pagination, page: pagination.page+1})
        })
    }
    const nextButton = (
        <Button variant='outline'
        size='sm'
        disabled={!paginationMetadata.hasNextPage || isPending }
        onClick={handleNextPage} 
        >
        Next
        </Button>
    );

    const sizeButton =(
        <Select defaultValue={pagination.size.toString()} 
           onValueChange={handleChangeSize}  >
            <SelectTrigger className="h-[36px]" >
                <SelectValue/>
            </SelectTrigger>
            <SelectContent>
                {PAGE_SIZES.map((size) => (
                <SelectItem key={size} value={size.toString()}>
                    {size}
                </SelectItem>
                ))}
            </SelectContent>
        </Select>
    )

    return ( 
    <div className="flex justify-between items-center" >
        <p className="text-sm text-muted-foreground" >{label}</p>
        <div className="flex gap-x-2" >
            {sizeButton}
            {prevButton}
            {nextButton}
        </div>
    </div> );
}
</file>

<file path="src/components/pagination/types.ts">
export type paginationData<T> =  {list: T[]; 
                        metadata: {count: number, hasNextPage: boolean,
                            cursor?:string
                        }}
</file>

<file path="src/components/placeholder.tsx">
import { LucideMessageSquareWarning } from "lucide-react";
import { cloneElement, ReactElement } from "react";

type PlaceholderProps<IconType extends ReactElement<{ className?: string }>, ButtonType extends ReactElement<{ className?: string }>> = {
  label: string;
  icon?: IconType;
  button?: ButtonType;
};

const Placeholder = <IconType extends ReactElement<{ className?: string }>, ButtonType extends ReactElement<{ className?: string }>>({
  label,
  icon = <LucideMessageSquareWarning /> as IconType,
  button = <div /> as ButtonType,
}: PlaceholderProps<IconType, ButtonType>) => {
  return (
    <div className="flex-1 self-center flex flex-col items-center justify-center gap-y-2">
      {icon && cloneElement(icon, {
        className: `w-16 h-16 ${icon.props.className || ''}`,
      })}
      <h2 className="text-lg text-center">{label}</h2>
      {button && cloneElement(button, {
        className: `h-10 ${button.props.className || ''}`,
      })}
    </div>
  );
};

export { Placeholder };
</file>

<file path="src/components/portal.tsx">
'use client';

import { useEffect, useState } from 'react';
import { createPortal } from 'react-dom';

type PortalProps = {
  children: React.ReactNode;
};

const Portal = ({ children }: PortalProps) => {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  if (!mounted) return null;

  return createPortal(children, document.body);
};

export { Portal };
</file>

<file path="src/components/redirect-toast.tsx">
'use client';
import { deleteCookieByKey, getCookieByKey } from "@/actions/cookies";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { useEffect } from "react";
import { toast } from "sonner";


const tryParseJsonObject = (value: string) => {
  try {
    return JSON.parse(value);
  } catch {
    return value;
  }
};


export const RedirectToast = () => {
    const pathname= usePathname();

    useEffect(()=>{
        const showCookieToast = async ()=>{
            const message=  await getCookieByKey('toast');

            if(message){
                const toastData = tryParseJsonObject(message);
                toast.success(  typeof toastData === "string" ? (
            message
          ) : (
            <span>
              <Link href={toastData.link} className="underline">
                {toastData.message}
              </Link>
            </span>
          ));
                deleteCookieByKey('toast');
            }
        };
        showCookieToast();
    }, [pathname]);

    return null;
}
</file>

<file path="src/components/sort-select.tsx">
'use client';

import { Select, SelectContent, SelectItem,
         SelectTrigger, SelectValue } from "./ui/select";

         

export type SortSelectOptions={
    sortKey: string,
    sortValue:string,
    label: string,
};

type SortObject={
    sortKey: string;
    sortValue: string;
}


type SortInputProps={
    options:SortSelectOptions[];
    value: SortObject;
    onChange:(sort: SortObject)=>void;
};


export const SortSelect = ({ options, value, onChange}: SortInputProps) => {


    const handleSort=(compositeKey: string)=>{
        const[sortKey, sortValue] = compositeKey.split('_')
        onChange({
            sortKey,
            sortValue,
        })
    }
    return ( 
        <Select defaultValue={value.sortKey + '_' + value.sortValue}  
        onValueChange={handleSort} >
            <SelectTrigger>
                <SelectValue />
            </SelectTrigger>
            <SelectContent>
                {options.map((option)=>(
                    <SelectItem key={option.sortKey + option.sortValue} 
                        value={option.sortKey +'_'+ option.sortValue} >
                        {option.label}
                    </SelectItem>
                )
              )
            }
            </SelectContent>
        </Select>
    );
    
}
</file>

<file path="src/components/spinner.tsx">
import { LucideLoaderCircle } from "lucide-react";

export const Spinner = () => {
    return ( 
        <div className="flex-1 flex  flex-col items-center self-center" >
            <LucideLoaderCircle className="h-16 w-16 animate-spin" />
        </div>
     );
}
</file>

<file path="src/components/ui/alert-dialog.tsx">
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src/components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        xs: 'h-6 px-2 py-1',
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="src/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from "lucide-react"
import { DayButton, DayPicker, getDefaultClassNames } from "react-day-picker"

import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = "label",
  buttonVariant = "ghost",
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>["variant"]
}) {
  const defaultClassNames = getDefaultClassNames()

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        "bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent",
        String.raw`rtl:**:[.rdp-button\_next>svg]:rotate-180`,
        String.raw`rtl:**:[.rdp-button\_previous>svg]:rotate-180`,
        className
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) =>
          date.toLocaleString("default", { month: "short" }),
        ...formatters,
      }}
      classNames={{
        root: cn("w-fit", defaultClassNames.root),
        months: cn(
          "flex gap-4 flex-col md:flex-row relative",
          defaultClassNames.months
        ),
        month: cn("flex flex-col w-full gap-4", defaultClassNames.month),
        nav: cn(
          "flex items-center gap-1 w-full absolute top-0 inset-x-0 justify-between",
          defaultClassNames.nav
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_previous
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_next
        ),
        month_caption: cn(
          "flex items-center justify-center h-(--cell-size) w-full px-(--cell-size)",
          defaultClassNames.month_caption
        ),
        dropdowns: cn(
          "w-full flex items-center text-sm font-medium justify-center h-(--cell-size) gap-1.5",
          defaultClassNames.dropdowns
        ),
        dropdown_root: cn(
          "relative has-focus:border-ring border border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] rounded-md",
          defaultClassNames.dropdown_root
        ),
        dropdown: cn(
          "absolute bg-popover inset-0 opacity-0",
          defaultClassNames.dropdown
        ),
        caption_label: cn(
          "select-none font-medium",
          captionLayout === "label"
            ? "text-sm"
            : "rounded-md pl-2 pr-1 flex items-center gap-1 text-sm h-8 [&>svg]:text-muted-foreground [&>svg]:size-3.5",
          defaultClassNames.caption_label
        ),
        table: "w-full border-collapse",
        weekdays: cn("flex", defaultClassNames.weekdays),
        weekday: cn(
          "text-muted-foreground rounded-md flex-1 font-normal text-[0.8rem] select-none",
          defaultClassNames.weekday
        ),
        week: cn("flex w-full mt-2", defaultClassNames.week),
        week_number_header: cn(
          "select-none w-(--cell-size)",
          defaultClassNames.week_number_header
        ),
        week_number: cn(
          "text-[0.8rem] select-none text-muted-foreground",
          defaultClassNames.week_number
        ),
        day: cn(
          "relative w-full h-full p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md group/day aspect-square select-none",
          defaultClassNames.day
        ),
        range_start: cn(
          "rounded-l-md bg-accent",
          defaultClassNames.range_start
        ),
        range_middle: cn("rounded-none", defaultClassNames.range_middle),
        range_end: cn("rounded-r-md bg-accent", defaultClassNames.range_end),
        today: cn(
          "bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none",
          defaultClassNames.today
        ),
        outside: cn(
          "text-muted-foreground aria-selected:text-muted-foreground",
          defaultClassNames.outside
        ),
        disabled: cn(
          "text-muted-foreground opacity-50",
          defaultClassNames.disabled
        ),
        hidden: cn("invisible", defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          )
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === "left") {
            return (
              <ChevronLeftIcon className={cn("size-4", className)} {...props} />
            )
          }

          if (orientation === "right") {
            return (
              <ChevronRightIcon
                className={cn("size-4", className)}
                {...props}
              />
            )
          }

          return (
            <ChevronDownIcon className={cn("size-4", className)} {...props} />
          )
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="flex size-(--cell-size) items-center justify-center text-center">
                {children}
              </div>
            </td>
          )
        },
        ...components,
      }}
      {...props}
    />
  )
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames()

  const ref = React.useRef<HTMLButtonElement>(null)
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus()
  }, [modifiers.focused])

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        "data-[selected-single=true]:bg-primary data-[selected-single=true]:text-primary-foreground data-[range-middle=true]:bg-accent data-[range-middle=true]:text-accent-foreground data-[range-start=true]:bg-primary data-[range-start=true]:text-primary-foreground data-[range-end=true]:bg-primary data-[range-end=true]:text-primary-foreground group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-ring/50 dark:hover:text-accent-foreground flex aspect-square size-auto w-full min-w-(--cell-size) flex-col gap-1 leading-none font-normal group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:ring-[3px] data-[range-end=true]:rounded-md data-[range-end=true]:rounded-r-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md data-[range-start=true]:rounded-l-md [&>span]:text-xs [&>span]:opacity-70",
        defaultClassNames.day,
        className
      )}
      {...props}
    />
  )
}

export { Calendar, CalendarDayButton }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="src/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="grid place-content-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="src/components/ui/resizable.tsx">
"use client"

import * as React from "react"
import { GripVerticalIcon } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        className
      )}
      {...props}
    />
  )
}

function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />
}

function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) {
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:translate-x-0 data-[panel-group-direction=vertical]:after:-translate-y-1/2 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        className
      )}
      {...props}
    >
      {withHandle && (
        <div className="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border">
          <GripVerticalIcon className="size-2.5" />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  )
}

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="src/components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="src/components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }
</file>

<file path="src/components/ui/table.tsx">
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="src/emails/auth/email-verification.tsx">
import { Body, Head, Html, Container,
     Section, Tailwind, Text } from "@react-email/components";

type EmailVerificationProps = {
    toName: string,
    code: string,
}
const EmailVerification = ({ toName, code }: EmailVerificationProps) => {
    return (
        <Html>
            <Head />
            <Tailwind>
                <Body className="font-sans m-8 text-center" >
                    <Container>
                        <Section>
                            <Text>
                                Hello {toName}, Please verify your code 
                                by using the code below
                            </Text>
                        </Section>
                        <Section>
                            <Text 
                                className="bg-black rounded text-white p-2 m-2" >
                                {code}
                            </Text>
                        </Section>
                    </Container>
                </Body>
            </Tailwind>
        </Html>
    );
}

export default EmailVerification;
</file>

<file path="src/emails/invitation/email-invitation.tsx">
import {
  Body,
  Button,
  Container,
  Head,
  Html,
  Section,
  Tailwind,
  Text,
} from "@react-email/components";

type EmailInvitationProps = {
  fromUser: string;
  fromOrganization: string;
  url: string;
};

const EmailInvitation = ({
  fromUser,
  fromOrganization,
  url,
}: EmailInvitationProps) => {
  return (
    <Html>
      <Head />
      <Tailwind>
        <Body className="font-sans m-8 text-center">
          <Container>
            <Section>
              <Text>
                Hello there, {fromUser} invited you to join {fromOrganization}.
                Click the link below to accept the invitation.
              </Text>
            </Section>
            <Section>
              <Button
                href={url}
                className="bg-black rounded text-white p-2 m-2"
              >
                Accept Invitation
              </Button>
            </Section>
          </Container>
        </Body>
      </Tailwind>
    </Html>
  );
};

EmailInvitation.PreviewProps = {
  fromUser: "Youssef Arhrib",
  fromOrganization: "Ai4Safety Inc.",
  url: "http://localhost:3000/email-invitation/abc123",
} as EmailInvitationProps;

export default EmailInvitation;
</file>

<file path="src/emails/password/email-password-reset.tsx">
import {Body, Head, Html, Container, Section, Tailwind, Text, Button} from "@react-email/components";

type EmailPasswordResetProps ={
    toName:string,
    url:string,
}
const EmailPasswordReset = ({toName, url}:EmailPasswordResetProps) => {
    return ( 
        <Html>
            <Head />
            <Tailwind>
                <Body className="font-sans m-8 text-center" >
                    <Container>
                        <Section>
                            <Text>
                            Hello {toName}, you have requested to change your password
                            </Text>
                        </Section>
                        <Section>
                            <Button href={url}
                                className="bg-black rounded text-white p-2 m-2" >
                                Reset Password
                            </Button>
                        </Section>
                    </Container>
                </Body>
            </Tailwind>
        </Html>
     );
}
 
export default EmailPasswordReset;
</file>

<file path="src/features/analysis/actions/get-analysis.ts">
'use server';

import { getAuthOrRedirect } from '@/features/auth/queries/get-auth-or-rerdirect';
import {prisma} from '@/lib/prisma'
import { AnalysisType } from '@prisma/client';


export const getAnalysis = async(inspectionId:string ) => {
    
    const {user,activeOrganization} = await getAuthOrRedirect();

    if (!user || !activeOrganization){
        return null;
    }

    const analysis= await prisma.analysis.findFirst({
        where: {
            inspectionId,
            // job:{
            //     type: AnalysisType.CRACK_DETECTION,
            // },

            inspection:{
                project:{
                    organizationId: activeOrganization.id,
                }
            }
        },
        include: {
            job:true,
            detections: {
                include:{
                    attachments: true
                }
            },
            inspection:{
                select:{
                    title:true,
                    project:{
                        select:{
                            name:true,
                            address: true
                        }
                    }
                }
            }
        }
    });

    if(!analysis){
        return null;
    };



    return {...analysis};
};
</file>

<file path="src/features/analysis/components/inspection-analytics.tsx">
'use client';

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ResponsiveContainer, PieChart, Pie, Cell, Tooltip, Legend } from 'recharts';

// Mock Data for the chart
const SEVERITY_DATA = [
  { name: 'Critical', value: 2, color: '#ef4444' },
  { name: 'High', value: 5, color: '#f97316' },
  { name: 'Medium', value: 12, color: '#eab308' },
  { name: 'Low', value: 8, color: '#22c55e' },
];

const TYPE_DATA = [
  { name: 'Spalling', value: 10, color: '#3b82f6' },
  { name: 'Rust', value: 8, color: '#8b5cf6' },
  { name: 'Cracks', value: 5, color: '#ec4899' },
  { name: 'Leaks', value: 4, color: '#14b8a6' },
];

export const InspectionAnalytics = () => {
    return (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 h-full p-4">
            <Card className="h-full border-none shadow-none bg-transparent">
                <CardHeader className="pb-2">
                    <CardTitle className="text-sm font-medium">Severity Distribution</CardTitle>
                </CardHeader>
                <CardContent className="h-[200px]">
                    <ResponsiveContainer width="100%" height="100%">
                        <PieChart>
                            <Pie
                                data={SEVERITY_DATA}
                                cx="50%"
                                cy="50%"
                                innerRadius={40}
                                outerRadius={60}
                                paddingAngle={5}
                                dataKey="value"
                            >
                                {SEVERITY_DATA.map((entry, index) => (
                                    <Cell key={`cell-${index}`} fill={entry.color} />
                                ))}
                            </Pie>
                            <Tooltip 
                                contentStyle={{ borderRadius: '8px', border: 'none' }}
                                itemStyle={{ color: '#1e293b' }}
                            />
                            <Legend verticalAlign="bottom" height={36} iconType="circle" />
                        </PieChart>
                    </ResponsiveContainer>
                </CardContent>
            </Card>

            <Card className="h-full border-none shadow-none bg-transparent">
                <CardHeader className="pb-2">
                    <CardTitle className="text-sm font-medium">Defect Types</CardTitle>
                </CardHeader>
                <CardContent className="h-[200px]">
                    <ResponsiveContainer width="100%" height="100%">
                        <PieChart>
                            <Pie
                                data={TYPE_DATA}
                                cx="50%"
                                cy="50%"
                                innerRadius={40}
                                outerRadius={60}
                                paddingAngle={5}
                                dataKey="value"
                            >
                                {TYPE_DATA.map((entry, index) => (
                                    <Cell key={`cell-${index}`} fill={entry.color} />
                                ))}
                            </Pie>
                            <Tooltip 
                                contentStyle={{ borderRadius: '8px', border: 'none' }}
                                itemStyle={{ color: '#1e293b' }}
                            />
                            <Legend verticalAlign="bottom" height={36} iconType="circle"/>
                        </PieChart>
                    </ResponsiveContainer>
                </CardContent>
            </Card>
        </div>
    );
}
</file>

<file path="src/features/auth/actions/email-verification-resend.ts">
'use server';

import { formErrorToActionState, 
    toActionState } from "@/components/forms/utils/to-action-state";
 

import { getAuthOrRedirect } from '../queries/get-auth-or-rerdirect';
import { sendEmailVerification } from "../emails/send-email-verification";
import { generateEmailVerificationCode } from "../utils/generate-email-verification-code";
import { canResendVerificationEmail } from "../utils/can-resend-verification-email";



const emailVerificationResend =  async () => {
    const {user} = await getAuthOrRedirect({
        checkEmailVerified:false,
        checkOrganization: false,
        checkActiveOrganization: false,
    });
    
    try {
        const canResend = await canResendVerificationEmail(user.id);
            if (!canResend) {
            return toActionState(
                "Error",
                "You can only resend the verification email once every minute."
            );
            }
        const verificationCode= await generateEmailVerificationCode(
            user.id, 
            user.email);
        
        const result = await sendEmailVerification(user.username, 
            user.email, 
            verificationCode);
        
        if(result.error){
            return toActionState("Error", 'Failed to send verification email');
        };

    } catch (error) {
      return  formErrorToActionState(error)
    }   

    return toActionState('Success', 'Verification email sent');

};

export { emailVerificationResend }
</file>

<file path="src/features/auth/actions/sign-out.ts">
'use server';

import { redirect } from "next/navigation"
import { getAuth } from "../queries/get-auth"
import { signInPath } from "@/path"
import {invalidateSession} from '@/lib/lucia';
import { deleteSessionCookie } from "../utils/session-cookie";

const signOut =  async () => {
    const {session}= await getAuth()

    if(!session){
        redirect(signInPath());
    }

    await invalidateSession(session.id);
    await deleteSessionCookie();

    redirect(signInPath());
};

export {signOut}
</file>

<file path="src/features/auth/emails/send-email-verification.tsx">
import EmailVerification from "@/emails/auth/email-verification";
import { resend } from "@/lib/resend"

export const sendEmailVerification = async (username: string,
    email: string,
    code: string
) => {
    return await resend.emails.send({
        from:'no-reply@updates.offerjet.store',
        to: email,
        subject: "Email Verification",
        react: <EmailVerification toName={username} code={code} />
    });
}
</file>

<file path="src/features/auth/events/event-email-verification.ts">
import { inngest } from "@/lib/inngest";
import { prisma } from "@/lib/prisma";
import { sendEmailVerification } from "../emails/send-email-verification";
import { generateEmailVerificationCode } from "../utils/generate-email-verification-code";

export type EmailVeriificationEventArgs={
    data:{
        userId: string;
    }
}


export const emailVerificationEvent = inngest.createFunction(
    {id: "email-verification"},
    {event: 'app/auth.sign-up'},
    async ({event}) => {const {userId} = event.data;
        const user = await prisma.user.findUniqueOrThrow( {
            where: {id: userId}
        })
        const verificationCode= await generateEmailVerificationCode(
            user.id, 
            user.email);
        
        const result = await sendEmailVerification(
            user.username, user.email, verificationCode);
        
        if(result.error){
            throw new Error(`${result.error.name}: ${result.error.message}`);
        }

        return {event, body: result};
    }
)
</file>

<file path="src/features/auth/queries/get-auth-or-rerdirect.ts">
import { emailVerificationPath, onboardingPath, 
    selectActiveOrganizationPath, signInPath } from "@/path";
import { redirect } from "next/navigation";
import { getAuth } from "./get-auth";
import { getOrganizationsByUserId } from "@/features/organization/queries/get-organizations-by-user";


type GetAuthOrRedirectOptions = {
    checkEmailVerified?:boolean,
    checkOrganization?:boolean,
    checkActiveOrganization?:boolean,
}

export const getAuthOrRedirect = async (options?: GetAuthOrRedirectOptions) => {
    const { checkEmailVerified = true ,
            checkOrganization = true ,
            checkActiveOrganization = true } = options ?? {};

    const authUser = await getAuth();
    if(!authUser.user){
        redirect(signInPath());
        
    };
    
    if( checkEmailVerified && !authUser.user.emailVerified){
        redirect(emailVerificationPath());
    };

    let activeOrganization;
    
    if( checkOrganization || checkActiveOrganization ){
        const organizations = await getOrganizationsByUserId();

        if(checkOrganization && !organizations.length){
            redirect(onboardingPath());
        };
        
        activeOrganization = organizations.find((org)=>{
            return org.membershipByUser.isActive})
        
        const hasActiveOrganization= !!activeOrganization;
        
        if( checkActiveOrganization && !hasActiveOrganization){
            redirect(selectActiveOrganizationPath())
        }
    };

    return {...authUser, activeOrganization};
};
</file>

<file path="src/features/auth/queries/get-auth.ts">
'use server';
import { cookies } from "next/headers"
import { SESSION_COOKIE_NAME } from "../utils/session-cookie";
import { validateSession } from "@/lib/lucia";
import { cache } from "react";

export const getAuth = cache(async () => {
    const sessionToken =  
        (await cookies()).get(SESSION_COOKIE_NAME)?.value ?? null;
    if(!sessionToken){
        return {
            user: null,
            session:null,
        };
    }

    return await validateSession(sessionToken)

});
</file>

<file path="src/features/auth/utils/can-resend-verification-email.ts">
import { differenceInSeconds } from "date-fns";
import { prisma } from "@/lib/prisma";

export const canResendVerificationEmail = async (userId: string) => {
  const databaseCode = await prisma.emailVerificationToken.findFirst({
    where: {
      userId,
    },
  });

  if (!databaseCode) {
    return true;
  }

  const diff = differenceInSeconds(
    new Date(),
    new Date(databaseCode.createdAt)
  );

  return diff > 60;
};
</file>

<file path="src/features/auth/utils/generate-email-verification-code.ts">
import { prisma } from "@/lib/prisma";
import { generateRandomCod } from "@/utils/crypto"

const EMAIL_VERIFICATION_CODE_LIFETIME_MS = 1000*60*10.

export const generateEmailVerificationCode = async (
    userId: string,
    email: string
) => {

    await prisma.emailVerificationToken.deleteMany({
        where:{
            userId,
        }
    })

    const code = generateRandomCod();
    
    await prisma.emailVerificationToken.create({
        data:{
            code,
            userId,
            email,
            expiresAt: new Date(Date.now() + EMAIL_VERIFICATION_CODE_LIFETIME_MS),
        },
    });

    return code;

}
</file>

<file path="src/features/auth/utils/session-cookie.ts">
import { cookies } from "next/headers";

export const SESSION_COOKIE_NAME = "session";

export const setSessionCookie = async (
  sessionToken: string,
  expiresAt: Date
) => {
  const cookie = {
    name: SESSION_COOKIE_NAME,
    value: sessionToken,
    attributes: {
      httpOnly: true,
      sameSite: "lax" as const,
      secure: process.env.NODE_ENV === "production",
      path: "/",
      expires: expiresAt,
    },
  };

  (await cookies()).set(cookie.name, cookie.value, cookie.attributes);
};

export const deleteSessionCookie = async () => {
  const cookie = {
    name: SESSION_COOKIE_NAME,
    value: "",
    attributes: {
      httpOnly: true,
      sameSite: "lax" as const,
      secure: process.env.NODE_ENV === "production",
      path: "/",
      maxAge: 0,
    },
  };

  (await cookies()).set(cookie.name, cookie.value, cookie.attributes);
};
</file>

<file path="src/features/auth/utils/validate-email-verification-code.ts">
import { prisma } from "@/lib/prisma";

export const validateEmailVerificationCode = async (userId:string,
     useremail:string, usercode: string)=>{
            
        const emailVerificationToken= await prisma.emailVerificationToken.findFirst({
                        where:{
                            userId: userId,
                        },
                    });
        if(!emailVerificationToken || emailVerificationToken.code !== usercode){
            return false;
        }
        await prisma.emailVerificationToken.delete({
            where:{
                id: emailVerificationToken.id
            },
        });
        const isExpired = Date.now() > emailVerificationToken.expiresAt.getTime();
        if(isExpired){
            return false;
        };

        if(emailVerificationToken.email !== useremail){
            return false;
        }

        return true;
};
</file>

<file path="src/features/credential/actions/create-credential.ts">
"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";

import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";

import { ActionState, formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { credentialsPath } from "@/path";
import { generateCredential } from "../utils/generate-credential";

const createCredentialSchema = z.object({
  name: z.string().min(1, { message: "Is required" }).max(191),
});

export const createCredential = async (
  organizationId: string,
  _actionState: ActionState,
  formData: FormData
) => {
  await getAdminOrRedirect(organizationId);

  let secret;

  try {
    const { name } = createCredentialSchema.parse({
      name: formData.get("name"),
    });

    secret = await generateCredential(organizationId, name);
  } catch (error) {
    return formErrorToActionState(error);
  }

  revalidatePath(credentialsPath(organizationId));

  return toActionState(
    "Success",
    `Copy the secret, we will not show it again: ${secret}`
  );
};
</file>

<file path="src/features/credential/components/credential-list.tsx">
import { format } from "date-fns";
import { Placeholder } from "@/components/placeholder";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { getCredentials } from "../queries/get-credentials";


type CredentialListProps = {
  organizationId: string;
};

const CredentialList = async ({ organizationId }: CredentialListProps) => {
  const credentials = await getCredentials(organizationId);

  if (!credentials.length) {
    return <Placeholder label="No credentials for this organization" />;
  }

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Name</TableHead>
          <TableHead>Created At</TableHead>
          <TableHead>Last Used</TableHead>
          <TableHead />
        </TableRow>
      </TableHeader>
      <TableBody>
        {credentials.map((credential) => {
          const buttons = <></>; // TODO add revoke credential button

          return (
            <TableRow key={credential.id}>
              <TableCell>{credential.name}</TableCell>
              <TableCell>
                {format(credential.createdAt, "yyyy-MM-dd, HH:mm")}
              </TableCell>
              <TableCell>
                {credential.lastUsed
                  ? format(credential.lastUsed, "yyyy-MM-dd, HH:mm")
                  : "Never"}
              </TableCell>
              <TableCell className="flex justify-end gap-x-2">
                {buttons}
              </TableCell>
            </TableRow>
          );
        })}
      </TableBody>
    </Table>
  );
};

export { CredentialList };
</file>

<file path="src/features/credential/queries/get-credentials.ts">
import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";
import { prisma } from "@/lib/prisma";

export const getCredentials = async (organizationId: string) => {
  await getAdminOrRedirect(organizationId);

  return await prisma.credential.findMany({
    where: {
      organizationId,
    },
    select: {
      id: true,
      createdAt: true,
      name: true,
      lastUsed: true,
    },
  });
};
</file>

<file path="src/features/credential/utils/generate-credential.ts">
import { prisma } from "@/lib/prisma";
import { generateRandomToken, hashToken } from "@/utils/crypto";

export const generateCredential = async (
  organizationId: string,
  name: string
) => {
  const secret = generateRandomToken();
  const secretHash = hashToken(secret);

  await prisma.credential.create({
    data: {
      secretHash,
      organizationId,
      name,
    },
  });

  return secret;
};
</file>

<file path="src/features/defects/permissions/get-defect-permissions.ts">
import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";
import { prisma } from "@/lib/prisma";
import { MembershipRole } from "@prisma/client";

type DefectPermissionProps = {
    organizationId: string | undefined;
    userId: string | undefined;
}
export const getDefectPermissions = async({
    organizationId,
    userId,
}: DefectPermissionProps)  => {
    
    if( ! organizationId || !userId ){
        return {
            canDeleteDefect: false,
            canEditDefect: false
        };
    }


    const membership = await prisma.membership.findUnique({
        where:{
            MembershipId:{
                userId,
                organizationId,
            }
        },
    });

    if(!membership){
        return {
            canDeleteDefect: false,
            canEditDefect: false
        };
    };

    if(membership.membershipRole === MembershipRole.ADMIN){
        return {
            canDeleteDefect: true,
            canEditDefect: true
        };
    };
    

    
    return {
        canDeleteDefect: !!membership.canDeleteDefect,
        canEditDefect: !!membership.canEditDefect
    };
}
</file>

<file path="src/features/defects/queries/get-defects.ts">
'use server';
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { prisma } from "@/lib/prisma";

export const getDefects = async (inspectionId: string) => {
    const { activeOrganization } = await getAuthOrRedirect();

    if (!activeOrganization) {
        return [];
    }

    return await prisma.detection.findMany({
        where: {
            // Filter by the specific inspection
            analysis: {
                inspectionId: inspectionId,
                //This inspection belongs to the user's active organization
                inspection: {
                    project: {
                        organizationId: activeOrganization.id
                    }
                }
            }
        },
        // include: {
        //     // Include related analysis info if needed
        //     analysis: {
        //         select: {
        //             id: true,
        //             createdAt: true
        //         }
        //     },
        //     // Include images (DetectionOnImage) if you want to show thumbnails
        //     images: {
        //         select: {
        //             supplement: {
        //                 select: {
        //                     url: true,
        //                     name: true
        //                 }
        //             }
        //         }
        //     }
        // },
        orderBy: {
            createdAt: 'desc'
        }
    });
};
</file>

<file path="src/features/defects/search-params.ts">
import {createSearchParamsCache, parseAsInteger, parseAsString} from "nuqs/server"

export const searchParser = parseAsString.withDefault('').withOptions({
    shallow:false,
    clearOnDefault: true,
});

// export const sortParser = parseAsString.withDefault('newest').withOptions({
//     shallow:false,
//     clearOnDefault: true,
// });

export const sortParser = {
    sortKey:  parseAsString.withDefault('createdAt'),
    sortValue:  parseAsString.withDefault('desc')
};

export const sortOptions = {
    shallow:false,
    clearOnDefault: true,
};


export const paginationParser = {
    page:  parseAsInteger.withDefault(0),
    size:  parseAsInteger.withDefault(5)
}


export const paginationOptions = {
    shallow:false,
    clearOnDefault: true,
};

export const searchParamsCache =createSearchParamsCache({
    search: searchParser,
    ...sortParser,
    ...paginationParser,
});

export type ParsedSearchParams = ReturnType<typeof searchParamsCache.parse>;
</file>

<file path="src/features/inspection/components/inspection-actions.tsx">
"use client"

import { Button } from "@/components/ui/button";
import { Detection } from "@prisma/client";
import { FileDown, Loader2, Printer } from "lucide-react";
import { toast } from "sonner";
import { InspectionPDFTemplate } from "./inspection-pdf-template";
import { useState } from "react";
import { pdf } from "@react-pdf/renderer";
import { saveAs } from "file-saver";


interface InspectionActionsProps {
  inspectionId: string;
  defects: Detection[]; 
  projectName?: string;
}

export function InspectionActions({ inspectionId, defects, projectName }: InspectionActionsProps) {
  const [isExporting, setIsExporting] = useState(false);

  const handleExport = async () => {
    try {
      setIsExporting(true);
      toast.info("Generating report...");

      // 1. Create the PDF instance
      const blob = await pdf(
        <InspectionPDFTemplate 
            inspectionId={inspectionId} 
            defects={defects} 
            projectName={projectName}
        />
      ).toBlob();

      // 2. Save it
      saveAs(blob, `Inspection_Report_${inspectionId}.pdf`);
      
      toast.success("Report downloaded!");
    } catch (error) {
      console.error(error);
      toast.error("Failed to generate PDF");
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <div className="flex items-center gap-2">
      <Button 
        variant="outline" 
        size="sm" 
        className="h-8 border-slate-700 hover:bg-slate-800 hover:text-white"
        onClick={handleExport}
        disabled={isExporting}
      >
        {isExporting ? (
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
        ) : (
            <FileDown className="mr-2 h-4 w-4" />
        )}
        {/* {isExporting ? "Exporting..." : "Export PDF"} */}
      </Button>

      {/* add a secondary action later*/}
      {/* <Button variant="ghost" size="icon" className="h-8 w-8">
         <MoreHorizontal className="h-4 w-4" />
      </Button> */}
    </div>
  );
}
</file>

<file path="src/features/inspection/components/inspection-context-bar.tsx">
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { LucideCloudSun, LucideCpu, LucidePlane, LucideWifi } from "lucide-react";

export type InspectionContextType = {
    weather: string;
    temperature: string;
    droneModel: string;
    aiModelVersion: string;
    aiConfidence: number;
}

export const InspectionContextBar = ({ data }: { data: InspectionContextType }) => {
    return (
        <div className="flex items-center gap-6 px-4 py-2 bg-card border-b border-border text-xs text-muted-foreground">
            <div className="flex items-center gap-2">
                <LucideCloudSun className="h-3.5 w-3.5" />
                <span>{data.weather}, {data.temperature}</span>
            </div>
            <Separator orientation="vertical" className="h-4" />
            <div className="flex items-center gap-2">
                <LucidePlane className="h-3.5 w-3.5" />
                <span>{data.droneModel}</span>
            </div>
            <Separator orientation="vertical" className="h-4" />
            <div className="flex items-center gap-2">
                <LucideCpu className="h-3.5 w-3.5" />
                <span>Model: {data.aiModelVersion}</span>
            </div>
            <div className="ml-auto flex items-center gap-2">
                <span className="hidden sm:inline">AI Confidence Score:</span>
                <Badge variant={data.aiConfidence > 80 ? "default" : "secondary"} className="text-[10px] h-5">
                    {data.aiConfidence}%
                </Badge>
            </div>
        </div>
    );
}
</file>

<file path="src/features/inspection/components/inspection-delete-button.tsx">
'use client';
import { useConfirmDialog } from "@/components/confirm-dialogue";
import { Button } from "@/components/ui/button";
import { LucideLoaderCircle, LucideLogOut, LucideTrash } from "lucide-react";
import { deleteInspection } from "../actions/delete-inspection";
import { useRouter } from "next/navigation";

type InspectionDeleteButtonProps={
    inspectionId:string;
    conductedByUserId: string | null ; 
}
export const InspectionDeleteButton = (
    {inspectionId, conductedByUserId}: InspectionDeleteButtonProps) => {
        const router = useRouter();
        const [deleteButton, deleteDialog]= useConfirmDialog({
            action: deleteInspection.bind(null, {
                inspectionId,
                conductedByUserId
            }),
            trigger: ((isPending)=> (
                <Button variant="destructive" size='icon' >
                    {isPending ? (
                        <LucideLoaderCircle className="h-4 w-4" />
                    ): 
                    (<LucideTrash className="w-4 h-4" />)}
                </Button>
            )),
            onSuccess: (()=>{router.refresh()})
        })

    return ( 
        <>
        {deleteDialog}
        {deleteButton}
        </>
     );
}
</file>

<file path="src/features/inspection/data/connect-referenced-inspections.ts">
import { prisma } from "@/lib/prisma";

export const connectReferencedInspecions = async (
  inspectionId: string,
  inspectionIds: string[]
) => {
  await prisma.inspection.update({
    where: {
      id: inspectionId,
    },
    data: {
      referencedInspections: {
        connect: inspectionIds.map((id) => ({
          id,
        })),
      },
    },
  });
};
</file>

<file path="src/features/inspection/data/create-inspection.ts">
import { AnalysisType } from "@prisma/client";
import { prisma } from "@/lib/prisma";



type CreateInspectionArgs = {
  id: string;
  userId: string;
  projectId: string;
  inspectionDate: string;
  title:string;
  jobs:AnalysisType[];
};

type IncludeOptions = {
  //includeUser?: boolean;
  includeProject?: boolean;
};

export async function createInspection<T extends IncludeOptions>({
  id,
  userId,
  projectId,
  inspectionDate,
  title,
  jobs,
  options,
}: CreateInspectionArgs & { options?: T }) {

  const include = {
    ...(options?.includeProject && { project: true }),
  };

  const inspection = await prisma.inspection.create({
    data: {
      id,
      title,
      conductedByUserId:userId,
      projectId,
      inspectionDate,
      job:{
          create:jobs.map((job)=>({type: job})),
          
            }},
    include
});

  return inspection ;
}
</file>

<file path="src/features/inspection/data/index.ts">
export * from "./create-inspection";
export * from "./connect-referenced-inspections";
</file>

<file path="src/features/inspection/permissions/get-inspection-permissions.ts">
import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";
import { prisma } from "@/lib/prisma";
import { MembershipRole } from "@prisma/client";

type InspectionPermissionProps = {
    organizationId: string | undefined;
    userId: string | undefined;
}
export const getInspectionPermissions = async({
    organizationId,
    userId,
}: InspectionPermissionProps)  => {
    
    if( ! organizationId || !userId ){
        return {
            canDeleteInspection: false,
            canEditInspection: false
        };
    }


    const membership = await prisma.membership.findUnique({
        where:{
            MembershipId:{
                userId,
                organizationId,
            }
        },
    });

    if(!membership){
        return {
            canDeleteInspection: false,
            canEditInspection: false
        };
    };

    if(membership.membershipRole === MembershipRole.ADMIN){
            return {
                canDeleteInspection: true,
                canEditInspection: true
            };
        };

    
    return {
        canDeleteInspection: membership.canDeleteInspection,
        canEditInspection: membership.canEditInspection
    };
}
</file>

<file path="src/features/inspection/queries/get-admin-or-redirect.ts">
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { signInPath } from "@/path";
import { redirect } from "next/navigation";
import { getMembership } from "./get-membership";

export const getAdminOrRedirect = async (organizationId: string) => {
    
    const auth = await getAuthOrRedirect();
    const membership = await getMembership({organizationId, 
        userId: auth.user.id,
    });

    if(!membership){
        redirect(signInPath());
    }

    if(membership.membershipRole !== 'ADMIN'){
        redirect(signInPath());
    }

    return { ...auth, membership };
}
</file>

<file path="src/features/inspection/queries/get-inspection.ts">
'use server';
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect"
import { prisma } from "@/lib/prisma";

export const getInspection = async (inspectionId: string) => {
    await getAuthOrRedirect();

    return await prisma.inspection.findUnique({
        where:{
            id:inspectionId,
        },
        include:{
            project:{
                select:{
                    name:true,
                    organizationId:true,
                }
            },
            conductedByUser:{
                select:{
                    email:true,
                    emailVerified:true,
                }
            }
        },
    });
}
</file>

<file path="src/features/inspection/queries/get-inspections.ts">
'use server';
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect"
import { prisma } from "@/lib/prisma";

export const getInspections = async (projectId: string) => {
    await getAuthOrRedirect();

    return await prisma.inspection.findMany({
        where:{
            projectId,
        },
        include:{
            project:{
                select:{
                    name:true,
                    organizationId:true,
                }
            },
            conductedByUser:{
                select:{
                    email:true,
                    emailVerified:true,
                }
            }
        },
    });
}
</file>

<file path="src/features/inspection/queries/get-membership.ts">
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect"
import { prisma } from "@/lib/prisma";

export const getMembership = async ({
    organizationId, userId}:{
        organizationId:string, userId:string
    }) => {
    await getAuthOrRedirect();

    return await prisma.membership.findUnique({
        where:{
            MembershipId:{
                organizationId,
                userId
            }
        },
    });
}
</file>

<file path="src/features/inspection/types.ts">
import { Prisma } from "@prisma/client";

export type InspectionWithMetadata = Prisma.InspectionGetPayload<{
  include: {
    conductedByUser: {
      select: { username: true };
    };

    supplements: true;
  };
}> & { isOwner: boolean };
</file>

<file path="src/features/invitation/actions/accept-invitation.ts">
"use server";

import { redirect } from "next/navigation";
import { setCookieByKey } from "@/actions/cookies";

import { prisma } from "@/lib/prisma";
import { hashToken } from "@/utils/crypto";
import { formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { signInPath } from "@/path";

export const acceptInvitation = async (tokenId: string) => {
  try {
    const tokenHash = hashToken(tokenId);

    const invitation = await prisma.invitation.findUnique({
      where: {
        tokenHash,
      },
    });

    if (!invitation) {
      return toActionState("Error", "Revoked or invalid verification token");
    }

    const user = await prisma.user.findUnique({
      where: {
        email: invitation.email,
      },
    });

    if (user) {
      await prisma.$transaction([
        prisma.invitation.delete({
          where: {
            tokenHash,
          },
        }),
        prisma.membership.create({
          data: {
            organizationId: invitation.organizationId,
            userId: user.id,
            membershipRole: "MEMBER",
            isActive: false,
          },
        }),
      ]);
     } 
       else {
      await prisma.invitation.update({
        where: {
          tokenHash,
        },
        data: {
          status: "ACCEPTED_WITHOUT_ACCOUNT",
        },
      });
    }
  } catch (error) {
    return formErrorToActionState(error);
  }

  await setCookieByKey("toast", "Invitation accepted");
  redirect(signInPath());
};
</file>

<file path="src/features/invitation/actions/create-invitation.ts">
"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";

import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";
import { getStripeProvisioningByOrganization } from "@/features/stripe/queries/get-stripe-provisioning";
import { inngest } from "@/lib/inngest";
import { prisma } from "@/lib/prisma";
import { invitationsPath } from "@/path";
import { ActionState, formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { generateInvitationLink } from "../utils/generate-invitation-link";

const createInvitationSchema = z.object({
  email: z.string().min(1, { message: "Is required" }).max(191).email(),
});

export const createInvitation = async (
  organizationId: string,
  _actionState: ActionState,
  formData: FormData
) => {
  const { user } = await getAdminOrRedirect(organizationId);

  const { allowedMembers, currentMembers } =
    await getStripeProvisioningByOrganization(organizationId);

  if (allowedMembers <= currentMembers) {
    return toActionState(
      "Error",
      "Upgrade your subscription to invite more members"
    );
  }

  try {
    const { email } = createInvitationSchema.parse({
      email: formData.get("email"),
    });

    const targetMembership = await prisma.membership.findFirst({
      where: {
        organizationId,
        user: {
          email,
        },
      },
    });

    if (targetMembership) {
      return toActionState(
        "Error",
        "User is already a member of this organization"
      );
    }

    const emailInvitationLink = await generateInvitationLink(
      user.id,
      organizationId,
      email
    );

    await inngest.send({
      name: "app/invitation.created",
      data: {
        userId: user.id,
        organizationId,
        email,
        emailInvitationLink,
      },
    });
  } catch (error) {
    return formErrorToActionState(error);
  }

  revalidatePath(invitationsPath(organizationId));

  return toActionState("Success", "User invited to organization");
};
</file>

<file path="src/features/invitation/actions/delete-invitation.ts">
"use server";

import { toActionState } from "@/components/forms/utils/to-action-state";
import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";
import { prisma } from "@/lib/prisma";

type DeleteInvitation = {
  email: string;
  organizationId: string;
};

export const deleteInvitation = async ({
  email,
  organizationId,
}: DeleteInvitation) => {
  await getAdminOrRedirect(organizationId);

  const invitation = await prisma.invitation.findUnique({
    where: {
      invitationId: {
        email,
        organizationId,
      },
    },
  });

  if (!invitation) {
    return toActionState("Error", "Invitation not found");
  }

  await prisma.invitation.delete({
    where: {
      invitationId: {
        email,
        organizationId,
      },
    },
  });

  return toActionState("Success", "Invitation deleted");
};
</file>

<file path="src/features/invitation/components/invitation-delete-button.tsx">
"use client";

import { LucideLoaderCircle, LucideTrash } from "lucide-react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { deleteInvitation } from "../actions/delete-invitation";
import { useConfirmDialog } from "@/components/confirm-dialogue";

type InvitationDeleteButtonProps = {
  email: string;
  organizationId: string;
};

const InvitationDeleteButton = ({
  email,
  organizationId,
}: InvitationDeleteButtonProps) => {
  const router = useRouter();

  const [deleteButton, deleteDialog] = useConfirmDialog({
    action: deleteInvitation.bind(null, { email, organizationId }),
    trigger: (isPending) => (
      <Button variant="destructive" size="icon">
        {isPending ? (
          <LucideLoaderCircle className="h-4 w-4 animate-spin" />
        ) : (
          <LucideTrash className="w-4 h-4" />
        )}
      </Button>
    ),
    onSuccess: () => {
      router.refresh();
    },
  });

  return (
    <>
      {deleteDialog}
      {deleteButton}
    </>
  );
};

export { InvitationDeleteButton };
</file>

<file path="src/features/invitation/components/invitation-list.tsx">
import { Placeholder } from "@/components/placeholder";
import { Button } from "@/components/ui/button";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { format } from "date-fns";
import { LucideTrash } from "lucide-react";
import { getInvitations } from "../queries/get-invitations";
import { InvitationDeleteButton } from "./invitation-delete-button";

export const InvitationsList = async ({
    organizationId}:{organizationId:string}) => {
        const invitations  = await getInvitations(organizationId)
    if(!invitations.length){
        return <Placeholder label="No invitations for this organization"/>
    }
    return ( 
        <Table>
            <TableHeader>
                <TableRow>
                    <TableHead>Email</TableHead>
                    <TableHead>Invited At</TableHead>
                    <TableHead>Invited By</TableHead>
                </TableRow>
            </TableHeader>
            <TableBody>
                {
                    invitations.map((invitation)=>{
                    const deleteBtn = (
                        <InvitationDeleteButton
                            email={invitation.email}
                            organizationId={invitation.organizationId}
                        />
                    );

                    const btns = <>{deleteBtn}</>;
                    return(
                        <TableRow key={invitation.email} >
                            <TableCell>{invitation.email}</TableCell>
                            <TableCell>
                                {format(invitation.createdAt, "yyyy-MM-dd, HH:mm")}
                            </TableCell>
                            <TableCell>
                                {invitation.invitedByUser
                                    ? `${invitation.invitedByUser.username} (${invitation.invitedByUser.email})`
                                    : "Deleted User"
                                }
                            </TableCell>
                            <TableCell className="flex justify-end gap-x-2" >
                                {btns}
                            </TableCell>
                        </TableRow>
                    );
                    })
                }
            </TableBody>
        </Table>
     );
}
</file>

<file path="src/features/invitation/emails/send-email-invitation.tsx">
import EmailInvitation from "@/emails/invitation/email-invitation";
import { resend } from "@/lib/resend";

export const sendEmailInvitation = async (
  username: string,
  organizationName: string,
  email: string,
  emailInvitationLink: string
) => {
  return await resend.emails.send({
    // your own custom domain here
    // or your email that you used to sign up at Resend
    from: "no-reply@updates.offerjet.store",
    to: email,
    subject: `Invitation to ${organizationName} from Ai4Safety`,
    react: (
      <EmailInvitation
        fromUser={username}
        fromOrganization={organizationName}
        url={emailInvitationLink}
      />
    ),
  });
};
</file>

<file path="src/features/invitation/events/event-invitation-created.ts">
import { inngest } from "@/lib/inngest";
import { prisma } from "@/lib/prisma";
import { sendEmailInvitation } from "../emails/send-email-invitation";

export type InvitationCreateEventArgs = {
  data: {
    userId: string;
    organizationId: string;
    email: string;
    emailInvitationLink: string;
  };
};

export const invitationCreatedEvent = inngest.createFunction(
  { id: "invitation-created" },
  { event: "app/invitation.created" },
  async ({ event }) => {
    const { userId, organizationId, email, emailInvitationLink } = event.data;

    const user = await prisma.user.findUniqueOrThrow({
      where: {
        id: userId,
      },
    });

    const organization = await prisma.organization.findUniqueOrThrow({
      where: {
        id: organizationId,
      },
    });

    const result = await sendEmailInvitation(
      user.username,
      organization.name,
      email,
      emailInvitationLink
    );
    console.log(result);

    if (result.error) {
      throw new Error(`${result.error.name}: ${result.error.message}`);
    }

    return { event, body: true };
  }
);
</file>

<file path="src/features/invitation/queries/get-invitations.ts">
import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";
import { prisma } from "@/lib/prisma";

export const getInvitations = async (organizationId: string) => {
    await getAdminOrRedirect(organizationId);
    return await prisma.invitation.findMany({
        where:{
            organizationId,
        },
        select: {
            email: true,
            createdAt: true,
            organizationId:true,
            invitedByUser:{
                select:{
                    email:true,
                    username:true,
        
                },
            },
        },
    });
}
</file>

<file path="src/features/invitation/utils/generate-invitation-link.ts">
import { prisma } from "@/lib/prisma";
import { emailInvitationPath } from "@/path";
import { generateRandomToken, hashToken } from "@/utils/crypto";
import { getBaseUrl } from "@/utils/url";

export const generateInvitationLink = async (
  invitedByUserId: string,
  organizationId: string,
  email: string
) => {
  await prisma.invitation.deleteMany({
    where: {
      email,
      organizationId,
    },
  });

  const tokenId = generateRandomToken();
  const tokenHash = hashToken(tokenId);

  await prisma.invitation.create({
    data: {
      tokenHash,
      invitedByUserId,
      organizationId,
      email,
    },
  });

  const pageUrl = getBaseUrl() + emailInvitationPath();
  const emailInvitationLink = pageUrl + `/${tokenId}`;

  return emailInvitationLink;
};
</file>

<file path="src/features/membership/components/membership-delete-button.tsx">
'use client';
import { useConfirmDialog } from "@/components/confirm-dialogue";
import { Button } from "@/components/ui/button";
import { LucideLoaderCircle, LucideLogOut } from "lucide-react";
import { deleteMembership } from "../actions/delete-membership";
import { useRouter } from "next/navigation";

type MembershipDeleteButtonProps={
    organizationId:string;
    userId: string;
}
export const MembershipDeleteButton = (
    {organizationId, userId}: MembershipDeleteButtonProps) => {
        const router = useRouter();
        const [deleteButton, deleteDialog]= useConfirmDialog({
            action: deleteMembership.bind(null, {
                organizationId,
                userId
            }),
            trigger: ((isPening)=> (
                <Button variant="destructive" size='icon' >
                    {isPening ? (
                        <LucideLoaderCircle className="h-4 w-4" />
                    ): 
                    (<LucideLogOut className="w-4 h-4" />)}
                </Button>
            )),
            onSuccess: (()=>{router.refresh()})
        })

    return ( 
        <>
        {deleteDialog}
        {deleteButton}
        </>
     );
}
</file>

<file path="src/features/membership/components/membership-more-menu.tsx">
"use client";
import { Button } from "@/components/ui/button";
import { MembershipRole } from "@prisma/client";
import { LucideUserCog } from "lucide-react";
import { toast } from "sonner";
import { updateMembershipRole } from "../actions/update-membership-role";
import { DropdownMenu, DropdownMenuContent, DropdownMenuLabel,
     DropdownMenuRadioGroup, DropdownMenuRadioItem, 
     DropdownMenuSeparator, DropdownMenuTrigger
     } from "@/components/ui/dropdown-menu";

type MembershipMoreMenuProps={
    organizationId: string;
    userId: string;
    membershipRole: MembershipRole
}
export const MembershipMoreMenu = ({
    organizationId, 
    userId, membershipRole}:MembershipMoreMenuProps) => {
    
    const handleUpdateMembershipRole= async(value: string)=>{
        const promise= updateMembershipRole({
            organizationId,
            userId,
            membershipRole: value as MembershipRole,
        });

        toast.promise(promise, {
            loading: 'Updating membership role...',
        });

        const result= await promise;
        
        if(result.status === 'Error'){
            toast.error(result.message);
        }else{
            toast.success(result.message);
        }
    }
    
    return ( 
        <DropdownMenu>
            <DropdownMenuTrigger asChild >
                <Button variant='outline'  size="icon" >
                    <LucideUserCog className="h-4 w-4" />
                </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent className="w-56" >
                <DropdownMenuLabel>Role</DropdownMenuLabel>
                <DropdownMenuSeparator />
                <DropdownMenuRadioGroup 
                   value={membershipRole} 
                   onValueChange={handleUpdateMembershipRole}
                >
                    <DropdownMenuRadioItem value="ADMIN" >Admin</DropdownMenuRadioItem>
                    <DropdownMenuRadioItem value="MEMBER" >Member</DropdownMenuRadioItem>
                </DropdownMenuRadioGroup>
            </DropdownMenuContent>
        </DropdownMenu>
     );
}
</file>

<file path="src/features/membership/components/permission-manager.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Membership } from "@prisma/client";
import { Shield, ChevronDown } from "lucide-react";
import { PermissionToggle } from "./permission-toggle";

// We define the keys we care about to ensure type safety
type PermissionKey = 
  'canDeleteInspection' | 
  'canEditInspection' |
  'canDeleteDefect' |
  'canEditDefect'

type PermissionManagerProps = {
  membership: Membership;
  isAdmin: boolean;
};

export const PermissionManager = ({ membership, isAdmin }: PermissionManagerProps) => {
  
  // Helper to render a consistent row inside the dropdown
  const renderPermissionRow = (label: string, key: PermissionKey) => (
    <div className="flex items-center justify-between py-2 px-2 hover:bg-muted/50 rounded-sm transition-colors">
      <span className="text-sm font-medium text-slate-700 dark:text-slate-300">
        {label}
      </span>
      <PermissionToggle
        userId={membership.userId}
        organizationId={membership.organizationId}
        permissionKey={key}
        permissionValue={Boolean(membership[key])}
        disabled={isAdmin} // Admins have all rights implicitly
      />
    </div>
  );

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="outline" 
          size="sm" 
          className="h-8 gap-2 border-dashed"
          disabled={isAdmin} // Optional: disable the menu entirely for admins
        >
          <Shield className="h-3.5 w-3.5" />
          <span className="hidden sm:inline">Access</span>
          <ChevronDown className="h-3 w-3 opacity-50" />
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownMenuContent align="end" className="w-64 p-2">
        <DropdownMenuLabel className="text-xs text-muted-foreground uppercase tracking-wider">
            Manage Permissions
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        
        {renderPermissionRow("Edit Inspections", "canEditInspection")}
        {renderPermissionRow("Delete Inspections", "canDeleteInspection")}
        {renderPermissionRow("Edit Defects", "canEditDefect")}
        {renderPermissionRow("Delete Defects", "canDeleteDefect")}
        
      </DropdownMenuContent>
    </DropdownMenu>
  );
};
</file>

<file path="src/features/membership/queries/get-active-membership.ts">
'use server';

import { getAuth } from "@/features/auth/queries/get-auth";
import { getActiveOrganization } from "@/features/organization/queries/get-active-organization";
import { prisma } from "@/lib/prisma";


export const getActiveMembership = async () => {
    
    const {user} = await getAuth();
    const activeOrganization = await getActiveOrganization();

    if(!user){
        return null;
    }

    const activeMembership = await prisma.membership.findFirst({
        where:{
            userId: user.id,
            organizationId: activeOrganization?.id,
            isActive: true
        },
    });

    
    return activeMembership ;
}
</file>

<file path="src/features/membership/queries/get-admin-or-redirect.ts">
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { getMembership } from "./get-membership";
import { signInPath } from "@/path";
import { redirect } from "next/navigation";

export const getAdminOrRedirect = async (organizationId: string) => {
    
    const auth = await getAuthOrRedirect();
    const membership = await getMembership({organizationId, 
        userId: auth.user.id,
    });

    if(!membership){
        redirect(signInPath());
    }

    if(membership.membershipRole !== 'ADMIN'){
        redirect(signInPath());
    }

    return { ...auth, membership };
}
</file>

<file path="src/features/membership/queries/get-membership.ts">
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect"
import { prisma } from "@/lib/prisma";

export const getMembership = async ({
    organizationId, userId}:{
        organizationId:string, userId:string
    }) => {
    await getAuthOrRedirect();

    return await prisma.membership.findUnique({
        where:{
            MembershipId:{
                organizationId,
                userId
            }
        },
    });
}
</file>

<file path="src/features/organization/actions/delete-organization.ts">
'use server';
import { formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { prisma } from "@/lib/prisma";
import { getOrganizationsByUserId } from "../queries/get-organizations-by-user";
import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";

export const deleteOrganization = async (organizationId:string) => {
    await getAdminOrRedirect(organizationId);
    try {
        const organizations = await getOrganizationsByUserId();
        const canDelete= organizations.some((org)=>org.id===organizationId);

        if(!canDelete){
            return toActionState('Error', 'Not a member of this organization');
        };

        await prisma.organization.delete({
            where:{
                id: organizationId,
            },
        });

    } catch (error) {
        formErrorToActionState(error)
    };

    return toActionState('Success', 'Organization deleted');
}
</file>

<file path="src/features/organization/actions/switch-organization.ts">
'use server';
import { formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect"
import { prisma } from "@/lib/prisma";
import { organizationPath } from "@/path";
import { revalidatePath } from "next/cache";
import { getOrganizationsByUserId } from "../queries/get-organizations-by-user";

export const switchOrganization = async (organizationId:string) => {
    const {user}= await getAuthOrRedirect({
        checkActiveOrganization: false});
    try {
        const organizations = await getOrganizationsByUserId();
        const canSwitch= organizations.some((org)=>org.id===organizationId);

        if(!canSwitch){
            return toActionState('Error', 'Not a member of this organization');
        };

        await prisma.$transaction([
        
        prisma.membership.updateMany({
            where:{
                userId: user.id,
                organizationId:{
                    not: organizationId,
                },
            },
            data:{
                isActive:false
            },
        }),

        prisma.membership.update({
            where:{
                MembershipId:{
                    organizationId,
                    userId: user.id,
                },
            },
            data:{
                isActive: true,
            },
        })
        ]);

    } catch (error) {
        formErrorToActionState(error)
    };

    revalidatePath(organizationPath());
    return toActionState('Success', 'Active organization switched');
}
</file>

<file path="src/features/organization/components/organization-delete-button.tsx">
'use client';

import React  from "react";
import { deleteOrganization } from "../actions/delete-organization";
import { useConfirmDialog } from "@/components/confirm-dialogue";

import { LucideLoaderCircle, LucideTrash } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";

type OrganizationDeleteBtnProps = {
    organizationId: string;
}
export const OrganizationDeleteButton = (
    {organizationId}:OrganizationDeleteBtnProps) => {
        const router = useRouter()
        const [deleteButton, deleteDialog]= useConfirmDialog({
            action: deleteOrganization.bind(null, organizationId),
            trigger:(isPending)=>(
                <Button variant="destructive" size="icon">
                    {isPending ? 
                    (<LucideLoaderCircle 
                        className="h-4 w-4 animate-spin" />):
                    (<LucideTrash className="h-4 w-4" />)
                    }
                </Button>
                        ),
            onSuccess: ()=>{router.refresh();}
        });
    return ( 
        <>
        {deleteDialog}
        {deleteButton}
        </>
     );
}
</file>

<file path="src/features/organization/components/organization-switch-button.tsx">
'use client';
import { Form } from "@/components/forms/form";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { useActionState } from "react";
import { switchOrganization } from "../actions/switch-organization";

type OrganizationSwitchBtnProps = {
    organizationId: string;
    trigger: React.ReactElement;
}
export const OrganizationSwichButton = ({organizationId,
     trigger}: OrganizationSwitchBtnProps) => {
        const [actionState, action] = useActionState(
            switchOrganization.bind(null, organizationId),
            EMPTY_ACTION_STATE
        );
    return (
        <Form action={action} actionState={actionState} >{trigger}</Form>
    );
}
</file>

<file path="src/features/organization/events/event-organization-created.ts">
import { inngest } from "@/lib/inngest";
import { prisma } from "@/lib/prisma";
import { stripe } from "@/lib/stripe";

export type OrganizationCreateEventArgs = {
  data: {
    organizationId: string;
    byEmail: string;
  };
};

export const organizationCreatedEvent = inngest.createFunction(
  { id: "organization-created" },
  { event: "app/organization.created" },
  async ({ event }) => {
    const { organizationId, byEmail } = event.data;

    const organization = await prisma.organization.findUniqueOrThrow({
      where: {
        id: organizationId,
      },
      include: {
        memberships: {
          include: {
            user: true,
          },
        },
      },
    });

    const stripeCustomer = await stripe.customers.create({
      name: organization.name,
      email: byEmail,
      metadata: {
        organizationId: organization.id,
      },
    });

    await prisma.stripeCustomer.create({
      data: {
        organizationId,
        customerId: stripeCustomer.id,
      },
    });

    return { event, body: true };
  }
);
</file>

<file path="src/features/organization/queries/get-active-organization.ts">
import { getAuth } from "@/features/auth/queries/get-auth";
import { prisma } from "@/lib/prisma";


export const getActiveOrganization = async() => {
    const {user}= await getAuth();
    if(!user){
        return null;
    }

    const activeOrganization = await prisma.organization.findFirst({
        where:{
            memberships:{
                some:{
                    userId: user.id,
                    isActive: true
                }
            }
        }
    })

    return activeOrganization;
}
</file>

<file path="src/features/organization/queries/get-organizations-by-user.ts">
import { getAuth } from "@/features/auth/queries/get-auth";
import { prisma } from "@/lib/prisma";

export const getOrganizationsByUserId = async () => {
    const {user}= await getAuth();
    if(!user) return [];

    const organizations = await prisma.organization.findMany({
        where:{
            memberships:{
                some:{
                    userId: user.id,
                },
            }
        },
        include:{
            memberships: {
                where:{
                    userId: user.id,
                },
            },
              _count:{
            select:{
                memberships:true,
            },
        },
        },

      
    });

    return organizations.map(({memberships,...organization})=>({
        ...organization,
        membershipByUser: memberships[0],
    }));
}
</file>

<file path="src/features/password/actions/password-change.ts">
'use server';

import { ActionState, 
    formErrorToActionState, 
    toActionState } from "@/components/forms/utils/to-action-state";

 
import z from "zod";
import {  verifyPasswordHash } from "../utils/hash-and-verify";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { redirect } from "next/navigation";
import { signInPath } from "@/path";
import { inngest } from "@/lib/inngest";



const passwordChangeSchema = z.object({

       password: z.string().min(6).max(191),
  });

const passwordChange =  async (_actionState:ActionState, formData: FormData) => {
    const auth = await getAuthOrRedirect();

    if(!auth.user){
            redirect(signInPath());
            
        }

    try {
        const { password } = passwordChangeSchema.parse(
            Object.fromEntries(formData)
        );

        const validPassword = await verifyPasswordHash(
            auth.user.passwordHash, password)
        
        if(!validPassword){
                return toActionState('Error', 'Incorrect Password', formData);
            }
        
        // Send emilwith reset link
        await inngest.send({
            name: 'app/password.password-reset',
            data:{userId: auth.user.id},
        });

        
    } catch (error) {
      return  formErrorToActionState(error, formData)
    }   

    return toActionState('Success', 'Check your email for a reset link');
    

};

export { passwordChange }
</file>

<file path="src/features/password/actions/password-forgot.ts">
'use server';

import { ActionState, 
    formErrorToActionState, 
    toActionState } from "@/components/forms/utils/to-action-state";
import { prisma } from "@/lib/prisma";
 
import z from "zod";
import { inngest } from "@/lib/inngest";



const passwordForgotSchema = z.object({

    email: z.string().min(1, { message: "Is required" }).max(191).email(),
  });

const passwordForgot =  async (_actionState:ActionState, formData: FormData) => {
    try {
        const { email}= passwordForgotSchema.parse(
            Object.fromEntries(formData)
        );

        const user = await prisma.user.findUnique({
            where: {email},
        }
        );

        if(!user){
            return toActionState('Success', 'Check your email for a reset link');
        }

        await inngest.send({
            name: 'app/password.password-reset',
            data:{userId: user.id},
        });


    } catch (error) {
      return  formErrorToActionState(error, formData)
    }   

    return toActionState('Success', 'Check your email for a reset link');
    

};

export { passwordForgot }
</file>

<file path="src/features/password/actions/password-reset.ts">
'use server';

import { setCookieByKey } from "@/actions/cookies";
import { ActionState, 
    formErrorToActionState, 
    toActionState} from "@/components/forms/utils/to-action-state";
import { prisma } from "@/lib/prisma";

import { signInPath } from "@/path";
import { hashToken } from "@/utils/crypto";
import { redirect } from "next/navigation";
 
import z from "zod";
import { hashPassword } from "../utils/hash-and-verify";



const passwordResetSchema = z.object({
        password: z.string().min(6).max(191),
        confirmPassword: z.string().min(6).max(191),
  })  
  .superRefine(({ password, confirmPassword }, ctx) => {
    if (password !== confirmPassword) {
      ctx.addIssue({
        code: "custom",
        message: "Passwords do not match",
        path: ["confirmPassword"],
      });
    }
  });

const passwordReset =  async (tokenId:string,
    _actionState:ActionState, formData: FormData, ) => {
    try {
        const { password}= passwordResetSchema.parse({
            password: formData.get('password'),
            confirmPassword: formData.get('confirmPassword'),
    });

    const tokenHash = hashToken(tokenId);
    const passwordResetToken = await prisma.passwordResetToken.findUnique({
        where: {tokenHash},
    });

    if(passwordResetToken) {
        await prisma.passwordResetToken.delete({
            where:{tokenHash},
        });
    };

    if(!passwordResetToken || Date.now() > passwordResetToken.expiresAt.getTime()){
        return toActionState('Error', 'Expired or Invalid verification token', formData);
    };

    await prisma.session.deleteMany({
        where:{
            userId: passwordResetToken.userId,
        },
    });
    
    const passwordHash = await hashPassword(password);
    
    await prisma.user.update({
        where: {id: passwordResetToken.userId},
        data: {passwordHash},
    })


    } catch (error) {
      return  formErrorToActionState(error, formData)
    }   
    
    await setCookieByKey('toast', 'Succesfully reset password');
    redirect(signInPath())

};

export { passwordReset }
</file>

<file path="src/features/password/emails/send-email-password-resend.tsx">
import EmailPasswordReset from "@/emails/password/email-password-reset"
import { resend } from "@/lib/resend"

export const sendEmailPasswordResend = async (username: string,
    email: string,
    passwordResetLink: string
) => {
    return await resend.emails.send({
        from:'no-reply@updates.offerjet.store',
        to: email,
        subject: "Password Reset From Ai4Safety",
        react: <EmailPasswordReset toName={username} url={passwordResetLink} />
    });
}
</file>

<file path="src/features/password/events/event-password-reset.ts">
import { inngest } from "@/lib/inngest";
import { prisma } from "@/lib/prisma";
import { generatePasswordResetLink } from "../utils/generate-password-reset-link";
import { sendEmailPasswordResend } from "../emails/send-email-password-resend";

export type PasswodResetEventArgs={
    data:{
        userId: string;
    }
}

export const passwordResetEvent = inngest.createFunction(
    {id:'password-reset'},
    {event: 'app/password.password-reset'},
    async ({event}) =>{
        const {userId} = event.data;

        const user = await prisma.user.findUniqueOrThrow({
            where: {id: userId},
        }
        );

        const passwordResetLink = await generatePasswordResetLink(user.id);

        const result= await sendEmailPasswordResend(user.username, user.email, passwordResetLink)

        if(result.error){
            throw new Error(`${result.error.name}: ${result.error.message}`);
        };

        return {event, body: result};

    }
)
</file>

<file path="src/features/password/utils/generate-password-reset-link.ts">
import { prisma } from "@/lib/prisma";
import { passwordResetPath } from "@/path"
import { generateRandomToken, hashToken } from "@/utils/crypto";
import { getBaseUrl } from "@/utils/url"


const PASSWORD_RESET_TOKEN_LIFETIME_MS = 1000 * 60 *60 * 2

export const generatePasswordResetLink = async (userId:string) => {

    await prisma.passwordResetToken.deleteMany({
        where:{
            userId,
        },
    });

    const tokenId = generateRandomToken();
    const tokenHash =  hashToken(tokenId)

    await prisma.passwordResetToken.create({
        data:{
            tokenHash:tokenHash,
            userId,
            expiresAt: new Date(Date.now() + PASSWORD_RESET_TOKEN_LIFETIME_MS)
        },
    })

    const pageUrl = getBaseUrl()+passwordResetPath();
    const passwordResetLink = pageUrl+ `/${tokenId}`;

    return passwordResetLink;
}
</file>

<file path="src/features/password/utils/hash-and-verify.ts">
import { hash, verify } from "@node-rs/argon2";

export const hashPassword = async (password: string) => {
  return await hash(password, {
    memoryCost: 19456,
    timeCost: 2,
    outputLen: 32,
    parallelism: 1,
  });
};

export const verifyPasswordHash = async (
  passwordHash: string,
  password: string
) => {
  return await verify(passwordHash, password);
};
</file>

<file path="src/features/profile/actions/update-profile.ts">
"use server";

import { ActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { z } from "zod";
import { updateUserProfile } from "../queries/get-user-profile";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { revalidatePath } from "next/cache";

// Define the validation schema
const updateProfileSchema = z.object({
  firstName: z.string().min(2, "First name must be at least 2 characters"),
  lastName: z.string().min(2, "Last name must be at least 2 characters"),
  role: z.string().optional(),
});

export const updateProfile = async (
  formState: ActionState,
  formData: FormData
): Promise<ActionState> => {

  const {user , activeOrganization}= await getAuthOrRedirect();
  
  if (!user || !activeOrganization) {
        return toActionState('Error', 'Not Authenticated');
      } ;
  
  try {
    //  Convert FormData to a regular object
    const data = {
      firstName: formData.get("firstName"),
      lastName: formData.get("lastName"),
      role: formData.get("role"),
    };

    // 3. Validate the data
    const validatedFields = updateProfileSchema.safeParse(data);

    if (!validatedFields.success) {
      return toActionState(
        "Error", 
        "Please check your input fields", 
        formData, 
        validatedFields.error
      );
    }

    // 4. TODO: Call your database here (e.g., db.user.update(...))
    console.log("Saving user data:", validatedFields.data);
    try {
    // ============================================================
    // 5. TRIGGER THE QUERY FUNCTIO
    // ============================================================
      await updateUserProfile(user.id, {
        firstName: validatedFields.data.firstName as string,
        lastName: validatedFields.data.lastName as string,
        //username: validatedFields.data.username as string,
        role: validatedFields.data.role as string | undefined,
      });

      // 6. Refresh the page data
      revalidatePath("/account/profile");

      return toActionState("Success", "Profile updated successfully", formData);
    } catch (error) {
      // Handle "Username already taken" error from Prisma
      // if (error.code === 'P2002' && error.meta?.target?.includes('username')) {
      //     return toActionState("Error", "This username is already taken", formData);
      // }

      console.error("Profile Update Error:", error);
      return toActionState("Error", "Failed to update profile", formData);
    }


  } catch (error) {
    return toActionState("Error", "Failed to update profile", formData);
  }
};
</file>

<file path="src/features/profile/components/profile-form.tsx">
"use client";

import { useActionState } from "react";
import { Camera, User } from "lucide-react";

import { updateProfile } from "../actions/update-profile";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Form } from "@/components/forms/form";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";
import { CardContent, CardFooter } from "@/components/ui/card";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { FieldErrorMsg } from "@/components/forms/field-error";

type ProfileFormProps = {
  user: {
    firstName: string | null;
    lastName: string | null;
    username: string;
    email: string;
    role: string | null;
  }
};

const INITIAL_USER = {
  firstName: "Nathan",
  lastName: "Roberts",
  email: "nathan.roberts@ai4safety.com",
  role: "Senior Safety Officer",
  initials: "NR",
};

export const ProfileForm = ({user}: ProfileFormProps) => {
  const [actionState, action] = useActionState(updateProfile, EMPTY_ACTION_STATE);
  
  const getInitials = () => {
    if (user.firstName && user.lastName) {
        return `${user.firstName[0]}${user.lastName[0]}`.toUpperCase();
    }
    return (user.username?.[0] || "U").toUpperCase();
  };

  return (
    <Form action={action} actionState={actionState}>
      <Separator className="mb-6" />

      <CardContent className="space-y-8 px-0">
        
        {/* Avatar Section (Visual Only for now) */}
        <div className="flex items-center gap-x-6">
          <div className="relative flex h-20 w-20 shrink-0 overflow-hidden rounded-full bg-muted border items-center justify-center">
            <span className="text-xl font-medium text-muted-foreground">
              {/* {INITIAL_USER.initials} */}
              {getInitials()}
            </span>
          </div>
          <div className="space-y-2">
            <div className="flex items-center gap-x-3">
              <Button type="button" variant="outline" size="sm">
                <Camera className="mr-2 h-4 w-4" />
                Change Photo
              </Button>
            </div>
            <p className="text-xs text-muted-foreground">
              JPG, GIF or PNG. 1MB max.
            </p>
          </div>
        </div>

        {/* Inputs Grid */}
        <div className="grid gap-6 md:grid-cols-2">
          
          {/* First Name */}
          <div className="grid gap-2">
            <Label htmlFor="firstName">First Name</Label>
            <Input
              id="firstName"
              name="firstName"
              placeholder="First Name"
              defaultValue={
                (actionState.payload?.get("firstName") as string) || user.firstName || ""
              }
            />
            <FieldErrorMsg name="firstName" actionState={actionState} />
          </div>

          {/* Last Name */}
          <div className="grid gap-2">
            <Label htmlFor="lastName">Last Name</Label>
            <Input
              id="lastName"
              name="lastName"
              placeholder="Last Name"
              defaultValue={
                (actionState.payload?.get("lastName") as string) || user.lastName || ""
              }
            />
            <FieldErrorMsg name="lastName" actionState={actionState} />
          </div>

          {/* Email (Read Only) */}
          <div className="grid gap-2 md:col-span-2">
            <Label htmlFor="email">Email Address</Label>
            <div className="relative">
              <User className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                id="email"
                name="email"
                type="email"
                className="pl-9"
                defaultValue={user.email}
                disabled
              />
            </div>
            <p className="text-[0.8rem] text-muted-foreground">
              This is the email you use to login.
            </p>
          </div>

          {/* Job Title */}
          <div className="grid gap-2 md:col-span-2">
            <Label htmlFor="role">Job Title / Role</Label>
            <Input
              id="role"
              name="role"
              placeholder="e.g. Safety Officer"
              defaultValue={
                (actionState.payload?.get("role") as string) || user.role || ""
              }
            />
            <FieldErrorMsg name="role" actionState={actionState} />
          </div>
        </div>
      </CardContent>

      <CardFooter className="flex justify-between border-t pt-6 px-0">
        <p className="text-sm text-muted-foreground">
          Profile information
        </p>
        <SubmitButton label="Save Changes" disabled={false} />
      </CardFooter>
    </Form>
  );
};
</file>

<file path="src/features/profile/queries/get-user-profile.ts">
// Assuming your prisma client instance is exported as 'db' or 'prisma'

import { prisma } from "@/lib/prisma";

export const getUserProfile = async (userId: string) => {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      email: true,
      role: true,
      //image: true,
      username: true,
    },
  });
  return user;
};


export const updateUserProfile = async (
  userId: string, 
  data: { firstName: string; lastName: string; role?: string }
) => {
  const updatedUser = await prisma.user.update({
    where: { id: userId },
    data: {
      firstName: data.firstName,
      lastName: data.lastName,
      role: data.role,
    },
  });
  return updatedUser;
};
</file>

<file path="src/features/project/components/project-pagination.tsx">
'use client';
import { useQueryState, useQueryStates } from "nuqs";
import { paginationOptions, paginationParser, searchParser } from "../search-params";
import { useEffect, useRef } from "react";

import { ProjectWithMetadata } from "../types";
import { Pagination } from "@/components/pagination/pagination";
import { paginationData } from "@/components/pagination/types";

type ProjectPaginationProps =  {
    paginationProjectMetadata:paginationData<ProjectWithMetadata>['metadata']
}

export const ProjectPagination = ({paginationProjectMetadata}: ProjectPaginationProps) => {
    const[pagination, setPagination]= useQueryStates(paginationParser,
                                                    paginationOptions
                                                )
    const [search]= useQueryState('search', searchParser)
    const prevSearch= useRef(search);
    useEffect(()=>{
        if(search === prevSearch.current) return;
        prevSearch.current = search;

        setPagination({...pagination, page: 0});
    }, [pagination, search, setPagination]);

    return ( 
        <Pagination pagination={pagination} 
            onPagination={setPagination}
            paginationMetadata={paginationProjectMetadata} />
     );
}
</file>

<file path="src/features/project/components/project-search-input.tsx">
'use client';
import { useQueryState } from "nuqs";
import { searchParser } from "../search-params";
import { SearchInput } from "@/components/search-input";

type ProjectSearchInputProps={
    placeholder: string
    }

export const ProjectSearchInput = ({placeholder}: ProjectSearchInputProps) => {

    const [search,  setSearch]= useQueryState('search', searchParser)

    return ( 
        <SearchInput 
            placeholder={placeholder} 
            value={search}
            onChange={setSearch} />
     );
}
</file>

<file path="src/features/project/components/project-sort-select.tsx">
'use client';
import { SortSelect, SortSelectOptions } from "@/components/sort-select";
import { useQueryStates } from "nuqs";
import { sortOptions, sortParser } from "../search-params";

type ProjectSortSelectOptions = {
    options: SortSelectOptions[];
    

}

export const ProjectSortSelect = ({options}: ProjectSortSelectOptions) => {
    const [sort, setSort]= useQueryStates(sortParser, sortOptions);
    return ( 
        <SortSelect options={options} value={sort} onChange={setSort} />
     );
}
</file>

<file path="src/features/project/components/project-stats.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { LucideActivity, LucideAlertOctagon, LucideCheckCircle2, LucideTrendingUp, LucideDrone } from "lucide-react";

export type ProjectStatsType = {
    totalInspections: number;
    totalDefects: number;
    criticalCount: number;
    resolvedCount: number;
    healthScore: number;
}

export const ProjectStats = ({ stats }: { stats: ProjectStatsType }) => {
  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4 mb-8">
      {/* 1. Health Score */}
      <Card className="border-l-4 border-l-blue-600 shadow-sm">
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Site Health Score</CardTitle>
          <LucideActivity className="h-4 w-4 text-blue-600" />
        </CardHeader>
        <CardContent>
          <div className="flex items-baseline gap-2">
            <div className={`text-2xl font-bold ${stats.healthScore < 70 ? 'text-red-600' : 'text-slate-900 dark:text-slate-50'}`}>
                {stats.healthScore}%
            </div>
            <span className="text-xs text-muted-foreground">+2.5% from last month</span>
          </div>
          <div className="mt-2 h-1 w-full bg-slate-100 rounded-full overflow-hidden">
             <div className="h-full bg-blue-600 rounded-full" style={{ width: `${stats.healthScore}%` }}></div>
          </div>
        </CardContent>
      </Card>

      {/* 2. Critical Risks */}
      <Card className="shadow-sm">
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Critical Risks</CardTitle>
          <LucideAlertOctagon className="h-4 w-4 text-red-500" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-red-600">{stats.criticalCount}</div>
          <p className="text-xs text-muted-foreground">Requires immediate attention</p>
        </CardContent>
      </Card>

      {/* 3. Total Flights */}
      <Card className="shadow-sm">
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Total Flights</CardTitle>
          <LucideDrone className="h-4 w-4 text-slate-500" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.totalInspections}</div>
          <p className="text-xs text-muted-foreground">Last flight: 2 days ago</p>
        </CardContent>
      </Card>

      {/* 4. Resolution Rate */}
      <Card className="shadow-sm">
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Resolution Rate</CardTitle>
          <LucideCheckCircle2 className="h-4 w-4 text-green-600" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-green-700">
            {stats.totalDefects > 0 ? Math.round((stats.resolvedCount / stats.totalDefects) * 100) : 100}%
          </div>
          <p className="text-xs text-muted-foreground">{stats.resolvedCount} issues fixed</p>
        </CardContent>
      </Card>
    </div>
  );
};
</file>

<file path="src/features/project/components/project-trend-chart.tsx">
'use client';

import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Legend } from 'recharts';

export type ChartDataPoint = {
    date: string;
    critical: number;
    open: number;
    resolved: number;
}

type ProjectTrendChartProps = {
    data: ChartDataPoint[];
}

const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-popover border border-border p-3 rounded-lg shadow-xl text-sm">
          <p className="font-semibold mb-2 text-popover-foreground">{label}</p>
          {payload.map((entry: any, index: number) => (
            <div key={index} className="flex items-center gap-2 mb-1">
                <div className="w-2 h-2 rounded-full" style={{ backgroundColor: entry.color }} />
                <span className="text-muted-foreground capitalize">{entry.name}:</span>
                <span className="font-mono font-bold text-popover-foreground">{entry.value}</span>
            </div>
          ))}
        </div>
      );
    }
    return null;
  };

export const ProjectTrendChart = ({ data }: ProjectTrendChartProps) => {
    return (
        <Card className="col-span-4 lg:col-span-4 h-full shadow-sm">
            <CardHeader>
                <CardTitle>Inspection Defect Trends</CardTitle>
                <CardDescription>
                    Tracking critical vs. resolved issues over the last 6 months.
                </CardDescription>
            </CardHeader>
            <CardContent className="pl-0">
                <ResponsiveContainer width="100%" height={350}>
                    <BarChart data={data} margin={{ top: 10, right: 30, left: 0, bottom: 0 }}>
                        <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="var(--border)" />
                        <XAxis 
                            dataKey="date" 
                            stroke="#888888" 
                            fontSize={12} 
                            tickLine={false} 
                            axisLine={false} 
                            tickMargin={10}
                        />
                        <YAxis 
                            stroke="#888888" 
                            fontSize={12} 
                            tickLine={false} 
                            axisLine={false} 
                            tickFormatter={(value) => `${value}`} 
                        />
                        <Tooltip content={<CustomTooltip />} cursor={{fill: 'var(--accent)', opacity: 0.2}} />
                        <Legend 
                            verticalAlign="top" 
                            height={36} 
                            iconType="circle"
                            formatter={(value) => <span className="text-sm text-muted-foreground ml-1">{value}</span>}
                        />
                        {/* Stacked Bars for a cleaner look */}
                        <Bar dataKey="resolved" name="Resolved" stackId="a" fill="#22c55e" radius={[0, 0, 4, 4]} barSize={32} />
                        <Bar dataKey="open" name="Open Issues" stackId="a" fill="#eab308" barSize={32} />
                        <Bar dataKey="critical" name="Critical" stackId="a" fill="#ef4444" radius={[4, 4, 0, 0]} barSize={32} />
                    </BarChart>
                </ResponsiveContainer>
            </CardContent>
        </Card>
    );
}
</file>

<file path="src/features/project/components/referenced-inspections.tsx">
import { LucideArrowUpRightFromSquare } from "lucide-react";
import Link from "next/link";
import { CardElement } from "@/components/card-compact";
import { projectPath } from "@/path";
import { getReferencedInspections } from "../queries/get-referenced-inspections";
import { format } from "date-fns";

type ReferencedInspectionsProps = {
  inspectionId: string;
};

const ReferencedInspections = async ({ inspectionId }: ReferencedInspectionsProps) => {
  const referencedInspections = await getReferencedInspections(inspectionId);

  if (!referencedInspections.length) return null;

  return (
    <CardElement
      title="Referenced Inspections"
      description="Inspections that have been referenced in comments"
      content={
        <div className="mx-2 mb-4">
          {referencedInspections.map((referencedInspection) => (
            <div key={referencedInspection.id}>
              <Link
                className="flex gap-x-2 items-center text-sm"
                href={projectPath(referencedInspection.id)}
              >
                <LucideArrowUpRightFromSquare className="h-4 w-4" />
                {format(referencedInspection.inspectionDate, "yyyy-MM-dd")}
              </Link>
            </div>
          ))}
        </div>
      }
    />
  );
};

export { ReferencedInspections };
</file>

<file path="src/features/project/data/connect-referenced-inspections.ts">
import { prisma } from "@/lib/prisma";

export const connectReferencedInspections = async (
  inspectionId: string,
  inspectionIds: string[]
) => {
  await prisma.inspection.update({
    where: {
      id: inspectionId,
    },
    data: {
      referencedInspections: {
        connect: inspectionIds.map((id) => ({
          id,
        })),
      },
    },
  });
};
</file>

<file path="src/features/project/data/disconnect-referenced-inspections.ts">
import { prisma } from "@/lib/prisma";

export const disconnectReferencedInspections = async (
  inspectionId: string,
  inspectionIds: string[]
) => {
  await prisma.inspection.update({
    where: {
      id: inspectionId,
    },
    data: {
      referencedInspections: {
        disconnect: inspectionIds.map((id) => ({
          id,
        })),
      },
    },
  });
};
</file>

<file path="src/features/project/data/index.ts">
export * from './connect-referenced-inspections'
export * from './disconnect-referenced-inspections'
</file>

<file path="src/features/project/queries/get-projects.ts">
import {prisma} from '@/lib/prisma'

import { ParsedSearchParams } from '../search-params';
import { getAuth } from '@/features/auth/queries/get-auth';
import { IsOwner } from '@/features/auth/utils/is-owner';
import { getActiveOrganization } from '@/features/organization/queries/get-active-organization';
import { getOrganizationsByUserId } from '@/features/organization/queries/get-organizations-by-user';
import { PAGE_SIZES } from '@/components/pagination/constants';



export const getProjects = async (userId: string | undefined,
    byOrganization:boolean,
    searchParams:ParsedSearchParams)  => {
     const {user} = await getAuth();

    const activeOrganization = await getActiveOrganization()
    
    const params = await (searchParams);

    //console.log("params.size:", params.size, "allowed:", PAGE_SIZES);

    if (!PAGE_SIZES.includes(params.size)) {
    throw new Error("Invalid page size");
    }
   
    const where = {
            userId,
                name:{
                    contains: params.search,
                    mode:'insensitive' as const,
            },
            ...(byOrganization && activeOrganization
                ? {
                    organizationId: activeOrganization.id,
                }:{}
            ),
          
        };
    const take =params.size;
    const skip = params.page * params.size;
 

    const [projects, count]= await prisma.$transaction([  
        prisma.project.findMany({
                    where,
                    skip,
                    take,
                    orderBy:{
                    [params.sortKey]: params.sortValue,
                    },
                    include: {
                        user: {
                            select:{ 
                                username:true
                            },
                        
                        }

                    }
                }),
        prisma.project.count({
        where
        }),
    ]); 

    const organizationsByUser = await getOrganizationsByUserId();

    return{
        list: projects.map((project)=>{

            const organization = organizationsByUser.find(
                (org)=>org.id === project.organizationId
            );

            return{
            ...project,
            isOwner: IsOwner(user, project),
            permissions:{
                canDeleteProject:IsOwner(user, project) &&
                                !!organization?.membershipByUser.canDeleteProject,
            },
        
            }       
        }),
        metadata: {
            count,
            hasNextPage: count > skip + take,
        }
    }
};
</file>

<file path="src/features/project/queries/get-referenced-inspections.ts">
import { prisma } from "@/lib/prisma";

export const getReferencedInspections = async (inspectionId: string) => {
  const inspection = await prisma.inspection.findUnique({
    where: { id: inspectionId },
    include: {
      referencedInspections: true,
    },
  });

  return inspection?.referencedInspections ?? [];
};
</file>

<file path="src/features/project/search-params.ts">
import {createSearchParamsCache, parseAsInteger, parseAsString} from "nuqs/server"

export const searchParser = parseAsString.withDefault('').withOptions({
    shallow:false,
    clearOnDefault: true,
});


export const sortParser = {
    sortKey:  parseAsString.withDefault('createdAt'),
    sortValue:  parseAsString.withDefault('desc')
};

export const sortOptions = {
    shallow:false,
    clearOnDefault: true,
};


export const paginationParser = {
    page:  parseAsInteger.withDefault(0),
    size:  parseAsInteger.withDefault(5)
}


export const paginationOptions = {
    shallow:false,
    clearOnDefault: true,
};

export const searchParamsCache =createSearchParamsCache({
    search: searchParser,
    ...sortParser,
    ...paginationParser,
});

export type ParsedSearchParams = ReturnType<typeof searchParamsCache.parse>;
</file>

<file path="src/features/project/service/disconnect-referenced-inspections.ts">
import { Comment } from "@prisma/client";
import { prisma } from "@/lib/prisma";
import { findIdsFromText } from "@/utils/find-ids-from-text";

export const disconnectReferencedInspectionsViaComment = async (
  comment: Comment
) => {
  const inspectionId = comment.inspectionId;
  const inspectionIds = findIdsFromText("inspections", comment.content);

  if (!inspectionIds.length || !inspectionId) return;

  const comments = await prisma.comment.findMany({
    where: {
      inspectionId: comment.inspectionId,
      id: {
        not: comment.id,
      },
    },
  });

  const allOtherContent = comments.map((comment) => comment.content).join(" ");

  const allOtherInspectionIds = findIdsFromText("inspections", allOtherContent);

  const inspectionIdsToRemove = inspectionIds.filter(
    (inspectionId) => !allOtherInspectionIds.includes(inspectionId)
  );

  await prisma.inspection.update({
    where: {
      id: inspectionId,
    },
    data: {
      referencedInspections: {
        disconnect: inspectionIdsToRemove.map((id) => ({
          id,
        })),
      },
    },
  });
};
</file>

<file path="src/features/project/service/index.ts">
export * from "./disconnect-referenced-inspections";
</file>

<file path="src/features/project/types.ts">
import { Prisma } from "@prisma/client"

export type ProjectWithMetadata = Prisma.ProjectGetPayload<{
        include: { user: {select:{username: true}} }
    }> & { isOwner: boolean , permissions : { canDeleteProject: boolean} }
</file>

<file path="src/features/stripe/actions/create-checkout-session.ts">
"use server";

import { redirect } from "next/navigation";
import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";
import { prisma } from "@/lib/prisma";
import { stripe } from "@/lib/stripe";
import { pricingPath, signInPath, subscriptionPath } from "@/path";
import { getBaseUrl } from "@/utils/url";
import { toActionState } from "@/components/forms/utils/to-action-state";

export const createCheckoutSession = async (
  organizationId: string | null | undefined,
  priceId: string
) => {
  if (!organizationId) {
    redirect(signInPath());
  }

  await getAdminOrRedirect(organizationId);

  const stripeCustomer = await prisma.stripeCustomer.findUnique({
    where: {
      organizationId,
    },
  });

  if (!stripeCustomer) {
    return toActionState("Error", "Stripe customer not found");
  }

  const price = await stripe.prices.retrieve(priceId);

  const session = await stripe.checkout.sessions.create({
    billing_address_collection: "auto",
    line_items: [
      {
        price: price.id,
        quantity: 1,
      },
    ],
    customer: stripeCustomer.customerId,
    mode: "subscription",
    success_url: `${getBaseUrl()}${subscriptionPath(organizationId)}`,
    cancel_url: `${getBaseUrl()}${pricingPath()}`,
    metadata: {
      organizationId,
    },
    subscription_data: {
      metadata: {
        organizationId,
      },
    },
  });

  if (!session.url) {
    return toActionState("Error", "Session URL could not be created");
  }

  redirect(session.url);
};
</file>

<file path="src/features/stripe/actions/create-customer-portal.ts">
"use server";

import { redirect } from "next/navigation";
import { getAdminOrRedirect } from "@/features/membership/queries/get-admin-or-redirect";
import { prisma } from "@/lib/prisma";
import { stripe } from "@/lib/stripe";
import { signInPath, subscriptionPath } from "@/path";
import { getBaseUrl } from "@/utils/url";
import { toActionState } from "@/components/forms/utils/to-action-state";

export const createCustomerPortal = async (
  organizationId: string | null | undefined
) => {
  if (!organizationId) {
    redirect(signInPath());
  }

  await getAdminOrRedirect(organizationId);

  const stripeCustomer = await prisma.stripeCustomer.findUnique({
    where: {
      organizationId,
    },
  });

  if (!stripeCustomer) {
    return toActionState("Error", "Stripe customer not found");
  }

  const productsWithPrices = [];

  const products = await stripe.products.list({
    active: true,
  });

  for (const product of products.data) {
    const prices = await stripe.prices.list({
      active: true,
      product: product.id,
    });

    productsWithPrices.push({
      product,
      prices: prices.data,
    });
  }

  const configuration = await stripe.billingPortal.configurations.create({
    business_profile: {
      privacy_policy_url: "https://example.com/privacy",
      terms_of_service_url: "https://example.com/terms",
    },
    features: {
      payment_method_update: {
        enabled: true,
      },
      customer_update: {
        allowed_updates: ["name", "email", "address", "tax_id"],
        enabled: true,
      },
      invoice_history: {
        enabled: true,
      },
      subscription_cancel: {
        enabled: true,
        mode: "at_period_end",
      },
      subscription_update: {
        default_allowed_updates: ["price"],
        enabled: true,
        proration_behavior: "create_prorations",
        products: productsWithPrices.map(({ product, prices }) => ({
          product: product.id,
          prices: prices.map((price) => price.id),
        })),
      },
    },
  });

  const session = await stripe.billingPortal.sessions.create({
    customer: stripeCustomer.customerId,
    return_url: `${getBaseUrl()}${subscriptionPath(organizationId)}`,
    configuration: configuration.id,
  });

  if (!session.url) {
    return toActionState("Error", "Session URL could not be created");
  }

  redirect(session.url);
};
</file>

<file path="src/features/stripe/components/checkout-session-form.tsx">
"use client";

import clsx from "clsx";
import { useActionState } from "react";import { Button } from "@/components/ui/button";
import { createCheckoutSession } from "../actions/create-checkout-session";
import { createCustomerPortal } from "../actions/create-customer-portal";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Form } from "@/components/forms/form";

type CheckoutSessionFormProps = {
  organizationId: string | null | undefined;
  priceId: string;
  activePriceId: string | null | undefined;
  children: React.ReactNode;
};

const CheckoutSessionForm = ({
  organizationId,
  priceId,
  activePriceId,
  children,
}: CheckoutSessionFormProps) => {
  const [actionState, action] = useActionState(
    !activePriceId
      ? createCheckoutSession.bind(null, organizationId, priceId)
      : createCustomerPortal.bind(null, organizationId),
    EMPTY_ACTION_STATE
  );

  const isActivePrice = activePriceId === priceId;

  return (
    <Form action={action} actionState={actionState}>
      <Button
        type="submit"
        disabled={isActivePrice}
        className={clsx("flex flex-col", {
          "h-16": !!activePriceId,
        })}
      >
        {!activePriceId ? null : isActivePrice ? (
          <span>Current Plan</span>
        ) : (
          <span>Change Plan</span>
        )}
        <div>{children}</div>
      </Button>
    </Form>
  );
};

export { CheckoutSessionForm };
</file>

<file path="src/features/stripe/components/customer-portal-form.tsx">
"use client";

import { useActionState } from "react";
import { Button } from "@/components/ui/button";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Form } from "@/components/forms/form";
import { createCustomerPortal } from "../actions/create-customer-portal";

type CustomerPortalFormProps = {
  organizationId: string | null | undefined;
  children: React.ReactNode;
};

const CustomerPortalForm = ({
  organizationId,
  children,
}: CustomerPortalFormProps) => {
  const [actionState, action] = useActionState(
    createCustomerPortal.bind(null, organizationId),
    EMPTY_ACTION_STATE
  );

  return (
    <Form action={action} actionState={actionState}>
      <Button type="submit">{children}</Button>
    </Form>
  );
};

export { CustomerPortalForm };
</file>

<file path="src/features/stripe/components/products.tsx">
import { LucideBadgeCheck, LucideCheck } from "lucide-react";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { stripe } from "@/lib/stripe";
import { toCurrencyFromCent } from "@/utils/currency";
import { CheckoutSessionForm } from "./checkout-session-form";
import { getStripeCustomerByOrganization } from "../queries/get-stripe-customer";

type PricesProps = {
  organizationId: string | null | undefined;
  productId: string;
  activePriceId: string | null | undefined;
};

const Prices = async ({
  organizationId,
  productId,
  activePriceId,
}: PricesProps) => {
  const prices = await stripe.prices.list({
    active: true,
    product: productId,
  });

  return (
    <div className="flex gap-x-2">
      {prices.data.map((price) => (
        <CheckoutSessionForm
          key={price.id}
          organizationId={organizationId}
          priceId={price.id}
          activePriceId={activePriceId}
        >
          <span className="font-bold text-lg">
            {toCurrencyFromCent(price.unit_amount || 0, price.currency)}
          </span>
          &nbsp;/&nbsp;<span>{price.recurring?.interval}</span>
        </CheckoutSessionForm>
      ))}
    </div>
  );
};

type ProductsProps = {
  organizationId: string | null | undefined;
};

const Products = async ({ organizationId }: ProductsProps) => {
  const stripeCustomer = await getStripeCustomerByOrganization(organizationId);

  const subscriptionStatus = stripeCustomer?.subscriptionStatus;
  const activeSubscription = subscriptionStatus === "active";
  const activeProductId = activeSubscription ? stripeCustomer?.productId : null;
  const activePriceId = activeSubscription ? stripeCustomer?.priceId : null;

  const products = await stripe.products.list({
    active: true,
  });

  return (
    <div className="flex-1 flex justify-center items-center gap-x-4">
      {products.data.map((product) => (
        <Card key={product.id}>
          <CardHeader>
            <CardTitle className="flex justify-between">
              {product.name}
              {activeProductId === product.id ? <LucideBadgeCheck /> : null}
            </CardTitle>
            <CardDescription>{product.description}</CardDescription>
          </CardHeader>
          <CardContent>
            {product.marketing_features.map((feature) => (
              <div key={feature.name} className="flex gap-x-2">
                <LucideCheck /> {feature.name}
              </div>
            ))}
          </CardContent>
          <CardFooter>
            <Prices
              organizationId={organizationId}
              productId={product.id}
              activePriceId={activePriceId}
            />
          </CardFooter>
        </Card>
      ))}
    </div>
  );
};

export { Products };
</file>

<file path="src/features/stripe/data/delete-subscription.ts">
import Stripe from "stripe";
import { prisma } from "@/lib/prisma";

export const deleteStripeSubscription = async (
  subscription: Stripe.Subscription,
  eventAt: number
) => {
  await prisma.stripeCustomer.update({
    where: {
      customerId: subscription.customer as string,
    },
    data: {
      subscriptionId: null,
      subscriptionStatus: null,
      productId: null,
      priceId: null,
      eventAt,
    },
  });
};
</file>

<file path="src/features/stripe/data/index.ts">
export * from "./delete-subscription";
export * from "./update-subscription";
</file>

<file path="src/features/stripe/data/update-subscription.ts">
import Stripe from "stripe";
import { prisma } from "@/lib/prisma";

export const updateStripeSubscription = async (
  subscription: Stripe.Subscription,
  eventAt: number
) => {
  const stripeCustomer = await prisma.stripeCustomer.findUniqueOrThrow({
    where: {
      customerId: subscription.customer as string,
    },
  });

  if (!stripeCustomer.eventAt || stripeCustomer.eventAt < eventAt) {
    await prisma.stripeCustomer.update({
      where: {
        customerId: subscription.customer as string,
      },
      data: {
        subscriptionId: subscription.id,
        subscriptionStatus: subscription.status,
        productId: subscription.items.data[0].price.product as string,
        priceId: subscription.items.data[0].price.id as string,
      },
    });
  }
};
</file>

<file path="src/features/stripe/queries/get-stripe-customer.ts">
import { prisma } from "@/lib/prisma";

export const getStripeCustomerByOrganization = async (
  organizationId: string | null | undefined
) => {
  if (!organizationId) {
    return null;
  }

  return prisma.stripeCustomer.findUnique({
    where: {
      organizationId,
    },
  });
};
</file>

<file path="src/features/stripe/queries/get-stripe-provisioning.ts">
import { prisma } from "@/lib/prisma";
import { stripe } from "@/lib/stripe";

export const getStripeProvisioningByOrganization = async (
  organizationId: string | null | undefined
) => {
  if (!organizationId) {
    return {
      allowedMembers: 0,
      currentMembers: 0,
    };
  }

  const [membershipCount, invitationCount, stripeCustomer] =
    await prisma.$transaction([
      prisma.membership.count({
        where: {
          organizationId,
        },
      }),
      prisma.invitation.count({
        where: {
          organizationId,
        },
      }),
      prisma.stripeCustomer.findUnique({
        where: {
          organizationId,
        },
      }),
    ]);

  const currentMembers = membershipCount + invitationCount;
  const isActive = stripeCustomer?.subscriptionStatus === "active";

  if (!isActive || !stripeCustomer?.productId) {
    return {
      allowedMembers: 1,
      currentMembers,
    };
  }

  const product = await stripe.products.retrieve(stripeCustomer.productId);

  return {
    allowedMembers: Number(product.metadata.allowedMembers),
    currentMembers,
  };
};
</file>

<file path="src/features/supplements/actions/create-attachments.ts">
"use server";

import { SupplementEntity } from "@prisma/client";
import { revalidatePath } from "next/cache";
import { z } from "zod";

import { filesSchema } from "../schema/files";
import * as attachmentService from "../service";
import { IsOwner } from "@/features/auth/utils/is-owner";

import { inspectionsPath } from "@/path";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { ActionState, formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";

const createAttachmentsSchema = z.object({
  files: filesSchema.refine((files) => files.length !== 0, "File is required"),
});

type CreateAttachmentsArgs = {
  entityId: string;
  entity: SupplementEntity;
};

export const createAttachments = async (
  { entityId, entity }: CreateAttachmentsArgs,
  _actionState: ActionState,
  formData: FormData
) => {
  const { user } = await getAuthOrRedirect();

  const subject = await attachmentService.getAttachmentSubject(
    entityId,
    entity
  );

  if (!subject) {
    return toActionState("Error", "Subject not found");
  }

  if (!IsOwner(user, subject)) {
    return toActionState("Error", "Not the owner of this subject");
  }

  try {

    const { files } = createAttachmentsSchema.parse({
      files: formData.getAll("files"),
    });

    await attachmentService.createAttachments({
      subject,
      entity,
      entityId,
      files,
    });
  } catch (error) {
    return formErrorToActionState(error);
  }

  if (subject.inspectionId) {
    revalidatePath(inspectionsPath(subject.inspectionId));
  }

  return toActionState("Success", "Attachment(s) uploaded");
};
</file>

<file path="src/features/supplements/components/attachment-delete-button.tsx">
"use client";

import { LucideLoaderCircle, LucideTrash } from "lucide-react";
import { useRouter } from "next/navigation";

import { deleteAttachment } from "../actions/delete-attachment";
import { useConfirmDialog } from "@/components/confirm-dialogue";
import { Button } from "@/components/ui/button";

type AttachmentDeleteButtonProps = {
  id: string;
  onDeleteAttachment?: (id: string) => void;
};

const AttachmentDeleteButton = ({
  id,
  onDeleteAttachment,
}: AttachmentDeleteButtonProps) => {
  const router = useRouter();

  const [deleteButton, deleteDialog] = useConfirmDialog({
    action: deleteAttachment.bind(null, id),
    trigger: (isPending) => (
      <Button variant="ghost" size="xs">
        {isPending ? (
          <LucideLoaderCircle className="h-4 w-4 animate-spin" />
        ) : (
          <LucideTrash className="w-4 h-4" />
        )}
      </Button>
    ),
    onSuccess: () => {
      onDeleteAttachment?.(id);
      router.refresh();
    },
  });

  return (
    <>
      {deleteDialog}
      {deleteButton}
    </>
  );
};

export { AttachmentDeleteButton };
</file>

<file path="src/features/supplements/components/attachment-item.tsx">
import { attachmentDownloadPath } from "@/path";
import { Supplement } from "@prisma/client";
import { LucideArrowUpRightFromSquare } from "lucide-react";
import Link from "next/link";

type AttachmentItemProps = {
  attachment: Supplement;
  buttons: React.ReactNode[];
};

const AttachmentItem = ({ attachment, buttons }: AttachmentItemProps) => {
  return (
    <div className="flex justify-between items-center">
      <Link
        className="flex gap-x-2 items-center text-sm truncate"
        href={attachmentDownloadPath(attachment.id)}
      >
        <LucideArrowUpRightFromSquare className="h-4 w-4" />
        {attachment.name}
      </Link>

      {buttons}
    </div>
  );
};

export { AttachmentItem };
</file>

<file path="src/features/supplements/components/attachment-list.tsx">
import { Supplement } from "@prisma/client";
import { AttachmentItem } from "./attachment-item";

type AttachmentListProps = {
  attachments: Supplement[];
  buttons: (id: string) => React.ReactNode[];
};

const AttachmentList = ({ attachments, buttons }: AttachmentListProps) => {
  return (
    <div className="mx-2 flex flex-col gap-y-2 mb-4">
      {attachments.map((attachment) => (
        <AttachmentItem
          key={attachment.id}
          attachment={attachment}
          buttons={buttons(attachment.id)}
        />
      ))}
    </div>
  );
};

export { AttachmentList };
</file>

<file path="src/features/supplements/components/attachments.tsx">
import { SupplementEntity } from "@prisma/client";
import {  CardElement } from "@/components/card-compact";
import { AttachmentCreateForm } from "./attachment-create-form";
import { getAttachments } from "../queries/get-attachments";
import { AttachmentList } from "./attachment-list";
import { AttachmentDeleteButton } from "./attachment-delete-button";

type AttachmentsProps = {
  entityId: string;
  entity: SupplementEntity;
  isOwner: boolean;
};

const Attachments = async ({ entityId, entity, isOwner }: AttachmentsProps) => {
  const attachments = await getAttachments(entityId, entity);

  return (
    <CardElement
      title="Attachments"
      description="Attached images or PDFs"
      content={
        <>
          <AttachmentList
            attachments={attachments}
            buttons={(attachmentId: string) => [
              ...(isOwner
                ? [<AttachmentDeleteButton key="0" id={attachmentId} />]
                : []),
            ]}
          />

          {isOwner && (
            <AttachmentCreateForm entityId={entityId} entity={entity} />
          )}
        </>
      }
    />
  );
};

export { Attachments };
</file>

<file path="src/features/supplements/data/create-attachment.ts">
import { SupplementEntity } from "@prisma/client";
import { prisma } from "@/lib/prisma";

type CreateAttachmentArgs = {
  name: string;
  entity: SupplementEntity;
  entityId: string;
  url: string | null;
};

export const createAttachment = async ({
  name,
  entity,
  entityId,
  url
}: CreateAttachmentArgs) => {
  
  return await prisma.supplement.create({
    data: {
      name,
      ...(entity === "INSPECTION" ? { inspectionId: entityId } : {}),
      ...(entity === "ANALYSIS" ? { analysisId: entityId } : {}),
      ...(entity === "COMMENT" ? { commentId: entityId } : {}),
      ...(entity === "DETECTION" ? { detectionId: entityId } : {}),
      entity,
      url
    },
  });
};
</file>

<file path="src/features/supplements/data/get-attachment.ts">
import { prisma } from "@/lib/prisma";

export const getAttachment = async (id: string) => {
  return await prisma.supplement.findUnique({
    where: {
      id,
    },
    include: {
      inspection: {
        include:{
          project:{
            select:{
              organizationId:true,
            }
          }
        }
      },
      detection:{
        include:{
          analysis:{
            include:{
              inspection:{
                include:{
                  project:{
                    select:{
                      organizationId:true,
                    }
                  }
                }
              }
            }
          }
        }
      },
      analysis: {
        include:{
          inspection:{
            include:{
              project:{
                select:{
                  organizationId:true
                }
              }
            }
          }
        }
      },
      comment: {
        include: {
          inspection: {
            include:{
              project:{
                select:{
                  organizationId:true,
                }
              }
            }
          },
         
        },
      },
    },
  });
};
</file>

<file path="src/features/supplements/data/index.ts">
export * from "./create-attachment";
export * from "./get-attachment";
</file>

<file path="src/features/supplements/queries/get-attachments.ts">
import { SupplementEntity } from "@prisma/client";
import { prisma } from "@/lib/prisma";

export const getAttachments = async (
  entityId: string,
  entity: SupplementEntity
) => {
  switch (entity) {
    case "INSPECTION": {
      return await prisma.supplement.findMany({
        where: {
          inspectionId: entityId,
        },
      });
    }
    case "ANALYSIS": {
      return await prisma.supplement.findMany({
        where: {
          analysisId: entityId,
        },
      });
    }
    case "DETECTION": {
      return await prisma.supplement.findMany({
        where: {
          detectionId: entityId,
        },
      });
    }
    case "COMMENT": {
      return await prisma.supplement.findMany({
        where: {
          commentId: entityId,
        },
      });
    }
    default:
      return [];
  }
};
</file>

<file path="src/features/supplements/schema/files.ts">
import { z } from "zod";
import { ACCEPTED, MAX_SIZE } from "../constants";
import { sizeInMB } from "../utils/size";

export const filesSchema = z
  .custom<FileList>()
  .transform((files) => Array.from(files))
  .transform((files) => files.filter((file) => file.size > 0))
  .refine(
    (files) => files.every((file) => sizeInMB(file.size) <= MAX_SIZE),
    `The maximum file size is ${MAX_SIZE}MB`
  )
  .refine(
    (files) => files.every((file) => ACCEPTED.includes(file.type)),
    "File type is not supported"
  );
</file>

<file path="src/features/supplements/service/create-attachments.ts">
import { PutObjectCommand } from "@aws-sdk/client-s3";
import { SupplementEntity } from "@prisma/client";
import { s3 } from "@/lib/aws";
import * as attachmentData from "../data";
import * as attachmentSubjectDTO from "../dto/attachment-subject-dto";
import { generateS3Key } from "../utils/generate-s3-key";

type CreateAttachmentsArgs = {
  subject: attachmentSubjectDTO.Type;
  entity: SupplementEntity;
  entityId: string;
  files: (File | string )[];
};

export const createAttachments = async ({
  subject,
  entity,
  entityId,
  files,
}: CreateAttachmentsArgs) => {
  const attachments = [];

  try {
    for (const file of files) {
      if (typeof file === "string") {
        //item is an S3 key or URL
        const attachment = await attachmentData.createAttachment({
          name: file.split("/").pop() ?? "unknown",
          entityId,
          entity,
          url: file
        });
        attachments.push(attachment);
      } 
      else 
        {
      const buffer = await Buffer.from(await file.arrayBuffer());

      const attachment = await attachmentData.createAttachment({
        name: file.name,
        entity,
        entityId,
        url: null
      });

      attachments.push(attachment);

      await s3.send(
        new PutObjectCommand({
          Bucket: process.env.AWS_BUCKET_NAME,
          Key: generateS3Key({
            organizationId: subject.organizationId,
            projectId: subject.projectId,
            inspectionId: subject.inspectionId,
            entityId,
            entity,
            fileName: file.name,
            attachmentId: attachment.id,
          }),
          Body: buffer,
          ContentType: file.type,
        })
      );
     }
  }
  } catch (error) {
    throw error;
  }

  return attachments;
};
</file>

<file path="src/features/supplements/service/get-attachment-subject.ts">
import { SupplementEntity } from "@prisma/client";
import { prisma } from "@/lib/prisma";
import * as attachmentSubjectDTO from "../dto/attachment-subject-dto";

export const getAttachmentSubject = async (
  entityId: string,
  entity: SupplementEntity
) => {
  switch (entity) {
    case "INSPECTION": {
      const inspection = await prisma.inspection.findUnique({
        where: {
          id: entityId,
        },
        include:{
          project:{
            select:{
              organizationId:true
            }
          }
        }
      });

      if(!inspection) return null;

      return attachmentSubjectDTO.fromInspection(inspection);
    }
  
    case "ANALYSIS": {
      const analysis = await prisma.analysis.findUnique({
        where: {
          id: entityId,
        },
        include: {
          inspection:{
            include:{
              project:{
                select:{
                  organizationId:true
                }
              }
            }
          }
        }
      });

      if(!analysis) return null;

      return attachmentSubjectDTO.fromAnalysis(analysis);
    }
    case "DETECTION": {
          const detection = await prisma.detection.findUnique({
            where: { id: entityId },
            include: {
              analysis: {
                include: {
                  inspection: {
                    include: {
                      project: {
                        select: { organizationId: true }
                      }
                    }
                  }
                }
              }
            }
          });

          if (!detection) return null;
          
          // We need to cast or ensure the import handles the deep type
          // but usually the DTO function handles the structural mapping
          return attachmentSubjectDTO.fromDetection(detection);
        }  
    case "COMMENT": {
      const comment = await prisma.comment.findUnique({
        where: {
          id: entityId,
        },
        include: {
          inspection: {
            include:{
              project:{
                select:{
                  organizationId:true,
                }
              }
            }
          },
        },
      });

      if(!comment) return null;

      return attachmentSubjectDTO.fromComment(comment);
    }
    default:
      return null;
  }
};
</file>

<file path="src/features/supplements/service/index.ts">
export * from "./create-attachments";
export * from "./get-attachment-subject";
</file>

<file path="src/features/supplements/types.ts">
import { Prisma } from "@prisma/client";

type AttachmentSubjectInspection = Prisma.InspectionGetPayload<{
  select: {
    id: true;
    projectId: true;
    conductedByUserId: true;
  };
  include:{
    project:{
      select:{
        organizationId:true;
      }
    }
  }
}>;

type AttachmentSubjectDetection = Prisma.DetectionGetPayload<{
  select: {
    id: true;
    sourceImageId: true;
  };
  include:{
    analysis:{
      include:{
        inspection:{
          include:{
            project:{
              select:{
                organizationId: true;
              }
            }
          }
        }
      }
    }
  }
}>;

type AttachmentSubjectAnalysis = Prisma.AnalysisGetPayload<{
  select: {
    id: true;
    inspectionId: true;
    jobId: true;
  };
  include:{
    inspection:{
      include:{
        project:{
          select:{
            organizationId:true;
          }
        }
      }
    }
  }
}>;

type AttachmentSubjectComment = Prisma.CommentGetPayload<{
  include: {
    inspection: {
      select: {
        id: true;
        projectId: true;
        project:{
          select:{
            organizationId:true;
          };
        }; 
      };
    };
    
  };
}>;

export type AttachmentSubject =
  | AttachmentSubjectInspection
  | AttachmentSubjectAnalysis
  | AttachmentSubjectComment
  | AttachmentSubjectDetection;

export const isInspection = (
  subject: AttachmentSubject
): subject is AttachmentSubjectInspection => {
  return "projectId" in subject  && "project" in subject;
};

export const isDetection = (
  subject: AttachmentSubject
): subject is AttachmentSubjectDetection => {
  return "analysis" in subject;
};

export const isAnalysis = (
  subject: AttachmentSubject
): subject is AttachmentSubjectAnalysis => {
  return  "jobId" in subject;
};

export const isComment = (
  subject: AttachmentSubject
): subject is AttachmentSubjectComment => {
  return "content" in subject;
};
</file>

<file path="src/features/supplements/utils/generate-s3-key.ts">
import { SupplementEntity } from "@prisma/client";

type GenerateKeyArgs = {
  organizationId: string;
  projectId: string | undefined ;
  entityId: string;
  entity: SupplementEntity;
  fileName: string;
  attachmentId: string;
  inspectionId?: string;
};

export const generateS3Key = ({
  organizationId,
  projectId,
  entityId,
  entity,
  fileName,
  attachmentId,
  inspectionId
}: GenerateKeyArgs) => {
  // Custom path for Detection to nest it under inspection
  // if (entity === 'DETECTION' && inspectionId) {
  //    return `${organizationId}/${projectId}/inspections/${inspectionId}/defects/${entityId}/${attachmentId}-${fileName}`;
  // }
  //return `${organizationId}/${projectId}/${entity}/${entityId}/${attachmentId}-${fileName}`;
  return   `organizations/${organizationId}/projects/${projectId}/inspections/${inspectionId}/${entity}/${entityId}/${attachmentId}-${fileName}`;
};
//organizations/cmihkw0hy0003w6hon4uobrd8/projects/cmihoymth0001w6eczl0dwbul/inspections/undefined/DETECTION/7a32439e-e850-4862-bf64-bce669350bed/cmjx6zmz20001w6y8657br2ej-9daffc5b-d904-4ebf-946d-8805d55889a0-4d75fb74-694b-4f57-8f79-36158ab26d63-concrete_crack_detection_report.pdf?
</file>

<file path="src/features/supplements/utils/size.ts">
export const sizeInMB = (sizeInBytes: number, decimalsNum = 2) => {
  const result = sizeInBytes / (1024 * 1024);
  return +result.toFixed(decimalsNum);
};
</file>

<file path="src/lib/aws.ts">
import {S3Client}  from "@aws-sdk/client-s3";

const s3 = new S3Client({
    region: process.env.AWS_BUCKET_REGION,
    credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY,
        secretAccessKey: process.env.AWS_SECRET_KEY
    },
});

export {s3};
</file>

<file path="src/lib/big.ts">
import Big from 'big.js';

Big.DP= 2;
Big.RM= Big.roundHalfEven;

export const MyBig = Big
</file>

<file path="src/lib/lucia.ts">
import { hashToken } from "@/utils/crypto";
import { prisma } from "./prisma";

const SESSION_REFRESH_INTERVAL_MS = 1000 * 60 * 60 * 24 * 15; // 15 days
const SESSION_MAX_DURATION_MS = SESSION_REFRESH_INTERVAL_MS * 2; // 30 days

export const createSession = async (sessionToken: string, userId: string) => {
  const sessionId = hashToken(sessionToken);

  const session = {
    id: sessionId,
    userId,
    expiresAt: new Date(Date.now() + SESSION_MAX_DURATION_MS),
  };

  await prisma.session.create({
    data: session,
  });

  return session;
};

export const validateSession = async (sessionToken: string) => {
  const sessionId = hashToken(sessionToken);

  const result = await prisma.session.findUnique({
    where: {
      id: sessionId,
    },
    include: {
      user: true,
    },
  });

  // if there is no session, return null
  if (!result) {
    return { session: null, user: null };
  }

  const { user, ...session } = result;

  // if the session is expired, delete it
  if (Date.now() >= session.expiresAt.getTime()) {
    // or your ORM of choice
    await prisma.session.delete({
      where: {
        id: sessionId,
      },
    });

    return { session: null, user: null };
  }

  // if 15 days are left until the session expires, refresh the session
  if (Date.now() >= session.expiresAt.getTime() - SESSION_REFRESH_INTERVAL_MS) {
    session.expiresAt = new Date(Date.now() + SESSION_MAX_DURATION_MS);

    await prisma.session.update({
      where: {
        id: sessionId,
      },
      data: {
        expiresAt: session.expiresAt,
      },
    });
  }

  return { session, user };
};

export const invalidateSession = async (sessionId: string) => {
  await prisma.session.delete({
    where: {
      id: sessionId,
    },
  });
};
</file>

<file path="src/lib/resend.ts">
import {Resend} from "resend";

export const resend = new Resend(process.env.RESEND_API_KEY);
</file>

<file path="src/lib/stripe/index.ts">
import Stripe from "stripe"

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
    typescript: true,
});

export { stripe };
</file>

<file path="src/lib/stripe/seed.ts">
import { prisma } from "../prisma";
import { stripe } from "./";

const seed = async () => {
  const t0 = performance.now();
  console.log("Stripe Seed: Started ...");

  // clean up

  const prices = await stripe.prices.list();
  const products = await stripe.products.list();
  const customers = await stripe.customers.list();

  for (const price of prices.data) {
    await stripe.prices.update(price.id, {
      active: false,
    });
  }

  for (const product of products.data) {
    await stripe.products.update(product.id, {
      active: false,
    });
  }

  for (const customer of customers.data) {
    await stripe.customers.del(customer.id);
  }

  // seed

  const organization = await prisma.organization.findFirstOrThrow({
    include: {
      memberships: {
        include: {
          user: true,
        },
      },
    },
  });

  const testClock = await stripe.testHelpers.testClocks.create({
    frozen_time: Math.round(new Date().getTime() / 1000),
  });

  const customer = await stripe.customers.create({
    name: organization.name,
    email: organization.memberships[0].user.email,
    test_clock: testClock.id,
  });

  await prisma.stripeCustomer.create({
    data: {
      customerId: customer.id,
      organizationId: organization.id,
    },
  });

  const productOne = await stripe.products.create({
    name: "Business Plan",
    description: "Your business plan.",
    metadata: {
      allowedMembers: 999,
    },
    marketing_features: [
      {
        name: "Cancel anytime",
      },
      {
        name: "Unlimited members",
      },
    ],
  });

  const productTwo = await stripe.products.create({
    name: "Startup Plan",
    description: "Your startup plan.",
    metadata: {
      allowedMembers: 3,
    },
    marketing_features: [
      {
        name: "Cancel anytime",
      },
      {
        name: "Up to 3 members",
      },
    ],
  });

  await stripe.prices.create({
    product: productTwo.id,
    unit_amount: 19999,
    currency: "usd",
    recurring: {
      interval: "year",
    },
  });

  await stripe.prices.create({
    product: productTwo.id,
    unit_amount: 1999,
    currency: "usd",
    recurring: {
      interval: "month",
    },
  });

  await stripe.prices.create({
    product: productOne.id,
    unit_amount: 39999,
    currency: "usd",
    recurring: {
      interval: "year",
    },
  });

  await stripe.prices.create({
    product: productOne.id,
    unit_amount: 3999,
    currency: "usd",
    recurring: {
      interval: "month",
    },
  });

  const t1 = performance.now();
  console.log(`Stripe Seed: Finished (${t1 - t0}ms)`);
};

seed();
</file>

<file path="src/lib/supabase.ts">
import { createClient } from '@supabase/supabase-js'

  export const supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL, 
                                    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY,
                                  // {
                                  //     realtime: {
                                  //       params: {
                                  //         eventsPerSecond: 10,
                                  //       },
                                  //     },
                                  //   }
                                  )
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/middleware.ts">
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

// 1. Define Public Routes (Everything else is protected)
const publicRoutes = [
  "/",           // Landing page
  "/sign-in",
  "/sign-up",
  "/pricing",
  "/password-forgot",
  "/password-reset",
  "/api/inngest", // Webhooks must be public (they verify signatures internally)
  "/api/stripe",  // Stripe webhooks
];



export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  if (
    pathname.startsWith("/api/inngest") || 
    pathname.startsWith("/_next") || 
    pathname.startsWith("/favicon.ico")
  ) {
    return NextResponse.next();
  }
  // D. SECURITY: Check for Session Cookie
  // (Adjust cookie name based on your auth provider: 'auth_session', 'next-auth.session-token', etc.)
  const sessionCookie = request.cookies.get("session"); 
  //console.log('Middleware Running')

  // A. REDIRECT IF ALREADY LOGGED IN
  // If user has a session and tries to visit Sign-In/Up/Verify, send them to dashboard
  const authRoutes = ["/sign-in", "/sign-up"];
  if (sessionCookie && authRoutes.includes(pathname)) {
    return NextResponse.redirect(new URL("/projects", request.url));
  }

  // B. Bypass for explicitly public routes
    if (
    publicRoutes.includes(pathname) ||
    publicRoutes.some(route => pathname === route || pathname.startsWith(route + "/"))
    ) {
    return NextResponse.next();
    }
  




  if (!sessionCookie) {
    // If trying to access API without session -> 401
    if (pathname.startsWith("/api")) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    // If trying to access UI -> Redirect to Sign In
    const url = request.nextUrl.clone();
    url.pathname = "/sign-in";
    url.searchParams.set("callbackUrl", pathname); // Smart redirect after login
    return NextResponse.redirect(url);
  }

  // E. SECURITY HEADERS (Enterprise Requirement)
  const response = NextResponse.next();
  response.headers.set("X-Frame-Options", "DENY"); // Prevents Clickjacking
  response.headers.set("X-Content-Type-Options", "nosniff");
  response.headers.set("Referrer-Policy", "strict-origin-when-cross-origin");
  response.headers.set("X-XSS-Protection", "1; mode=block");
  response.headers.set("Permissions-Policy", "camera=(), microphone=(), geolocation=()");

  
  return response;
}

export const config = {
    matcher: [
       "/(saas)/(authenticated)/:path*",
  ],
};
</file>

<file path="src/utils/crypto.ts">
import { sha256 } from "@oslojs/crypto/sha2";
import {
  encodeBase32LowerCaseNoPadding,
  encodeHexLowerCase,
} from "@oslojs/encoding";

import { generateRandomString } from "@oslojs/crypto/random";

import type { RandomReader } from "@oslojs/crypto/random";

export const generateRandomToken = () => {
  const bytes = new Uint8Array(20);
  crypto.getRandomValues(bytes);
  return encodeBase32LowerCaseNoPadding(bytes);
};

export const hashToken = (token: string) => {
  return encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
};

const random: RandomReader = {
	read(bytes) {
		crypto.getRandomValues(bytes);
	}
};

const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
export const generateRandomCod = ()=>{
  return generateRandomString(random, alphabet, 8);
}
</file>

<file path="src/utils/currency.tsx">
import {MyBig} from "@/lib/big";  

export const toCent = (amount: number) =>
  new MyBig(amount).mul(100).round(2).toNumber();

export const fromCent = (amount: number) =>
  new MyBig(amount).div(100).round(2).toNumber();

const toCurrencyFromCent = ( amount: number, currency?:string) => 
    new Intl.NumberFormat("en-US", {
        style: 'currency',
        currency: currency ?? 'USD',
    }).format(fromCent(amount))


export {toCurrencyFromCent}
</file>

<file path="src/utils/url.ts">
export const getBaseUrl = () => {
    const environment = process.env.NODE_ENV;

    const baseUrl = environment === "development"
        ? "http://localhost:3000"
        : `https://${process.env.NEXT_PUBLIC_VERCEL_URL}`;

    return baseUrl;
}
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  content: [],
  theme: {
    extend: {},
  },
  plugins: [],
};

export default config;
</file>

<file path="environment.d.ts">
declare global {
    namespace NodeJS {
        interface ProcessEnv {
            NODE_ENV: "development" | "production";
            AWS_ACCESS_KEY: string;
            AWS_SECRET_KEY: string;
            AWS_BUCKET_NAME: string;
            AWS_REGION: string;
            STRIPE_SECRET_KEY: string;
            NEXT_PUBLIC_SUPABASE_URL: string;
            NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY: string;
            //SUPABASE_KEY: string;
            
        }
    }
}

export {};
</file>

<file path="postcss.config.mjs">
export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};
</file>

<file path="src/app/(saas)/(authenticated)/account/password/page.tsx">
import Heading from "@/components/heading";
import { AccountTabs } from "../_navigation/tabs";
import { CardElement } from "@/components/card-compact";
import { PasswordChangeForm } from "@/features/password/components/password-change-form";

const PasswordPage = () => {
   
    return ( 
        
            <div className="flex-1 flex flex-col gap-y-8" >
                    <Heading title="Password" 
                        description="Your account password "
                        tabs={<AccountTabs /> }        
                    />
                <div className="flex-1 flex flex-col items-center" >
                    <CardElement title="Change Password" 
                    description="Enter your current password"
                    className="w-full max-w-lg"
                    content={<PasswordChangeForm />} 
                />
                </div>
            </div>
        
     );
}
 
export default PasswordPage;
</file>

<file path="src/app/(saas)/(authenticated)/account/profile/page.tsx">
'use server';
import Heading from "@/components/heading";
import { AccountTabs } from "../_navigation/tabs";
import { CardElement } from "@/components/card-compact";
import { ProfileForm } from "@/features/profile/components/profile-form"; 
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { toActionState } from "@/components/forms/utils/to-action-state";
import { getUserProfile } from "@/features/profile/queries/get-user-profile";

const ProfilePage = async () => {
    const {user , activeOrganization}= await getAuthOrRedirect();
    if (!user || !activeOrganization) {
                  return toActionState('Error', 'Not Authenticated');
    } ;

    const userData = await getUserProfile(user.id);
    //console.log('userData profile page', userData);
    if(!userData){
        return toActionState('Error', 'User not found');
    }
    return ( 
        <div className="flex-1 flex flex-col gap-y-8">
            <Heading 
                title="Profile" 
                description="All your profile information" 
                tabs={<AccountTabs />}    
            />

            <div className="flex-1 flex flex-col items-center">
                <CardElement 
                    title="Personal Details" 
                    description="Manage your public profile and private information"
                    className="w-full max-w-3xl"
                    content={<ProfileForm user={userData} />} 
                />
            </div>
        </div>
     );
}
 
export default ProfilePage;
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/_navigation/tabs.tsx">
'use client';
import { Breadcrumbs } from "@/components/breadcrumbs";

import {  inspectionsPath,  projectsPath,projectPath } from "@/path";
import { useParams, usePathname } from "next/navigation";

type ProjectBreadCrumbsProps = {
    projectName: string; // Now required for better UX
    inspectionTitle?: string;
}

export const ProjectBreadCrumbs =  ({ projectName, inspectionTitle }: ProjectBreadCrumbsProps) => {
    const params = useParams<{projectId: string}>();
    const pathname = usePathname();
    

    const projectLevel = {
        title: projectName,
        href: projectPath(params.projectId),
        dropdown: [
            { 
                title: "📊 Dashboard", 
                href: projectPath(params.projectId) 
            },
            { 
                title: "📋 Inspection List", 
                href: inspectionsPath(params.projectId) 
            },
        ]
    };

    const breadcrumbs = [
        { title: 'Projects', href: projectsPath() }, // Root
        projectLevel,                                // Project Context
    ];

    if (pathname.endsWith('/inspections')) {
        breadcrumbs.push({
            title: 'Inspections',
            href:''
        });
        if (inspectionTitle) {
            breadcrumbs.push({
                title: inspectionTitle,
                href:''
            });
        }
    }

    return ( 
        <Breadcrumbs
            breadcrumbs={breadcrumbs}
        />
     );
}

// [
//                 {title: 'Projects', href:projectsPath()},
//                 {title: params.projectId,
//                     dropdown:[
//                             {title:"Project Dashboard",
//                             href: projectPath(params.projectId)},
//                             {title: "Inspections",
//                             href: inspectionsPath(params.projectId)},
                        
                        
//                     ]
//                 },
//             ]
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/edit/page.tsx">
import { Breadcrumbs } from "@/components/breadcrumbs";
import { CardElement } from "@/components/card-compact";
import { Separator } from "@/components/ui/separator";
import { ProjectUpsertForm } from "@/features/project/components/project-form-upsert";
import { getProject } from "@/features/project/queries/get-project";

import { projectPath, projectsPath } from "@/path";

import { notFound } from "next/navigation";


type ProjectEditProps = {
  params: Promise<{
    projectId: string;
  }>;
};


const ProjectEditPage = async ({params}:ProjectEditProps) => {
    const { projectId } =  await params;
    const project = await getProject(projectId);


    const isProjectFound= !!project;

    if (!project || typeof project === 'object' && 'serverError' in project || !('isOwner' in project) || !project.isOwner) {
        notFound();
    }

   
    return ( 
        <div className='flex-1 flex flex-col gap-y-8'>
        <Breadcrumbs breadcrumbs={[
            {title: 'Projects', href:projectsPath()},
            {title:project.name, href:projectPath(project.id)},
            {title:'Edit'},
        ]}/>
        <Separator />
        
        <div className="flex-1 flex flex-col
         justify-center items-center" >
            <CardElement title="Edit Project" 
            description="Edit an existing Project"
            className="w-full max-w-[420px]"
            content={<ProjectUpsertForm project={project} />}  />
        </div>    
        </div>
     );
}
 
export default ProjectEditPage;
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/inspections/[inspectionId]/analysis/3d_viewer/page.tsx">
import Heading from "@/components/heading";
import { AnalysisTabs } from "../_navigation/tabs";
import { Analysis3DViewer } from "@/features/analysis/components/analysis_3d_viewer";
import {getAnalysis} from "@/features/analysis/actions/get-analysis"

type TabularAnalysisPageProps = {
    params: Promise<{projectId: string, inspectionId: string}>;
};
const Analysis3DViewerPage = async ({params}:TabularAnalysisPageProps) => {
    
    const {projectId, inspectionId}= await params;
    const tilesetUrl=  "/model/tileset.json";
    const analysis = await getAnalysis(inspectionId);
    
    if(!analysis) return null;
    
    return ( 
        <div className="flex flex-col ">
             {/* "flex-1 flex flex-col gap-y-8"   flex-col h-screen w-screen*/}
            <div className= "flex-none">
                <Heading title="3D Viewer" 
                description="All your inspection in 3D space " 
                tabs={
                    <AnalysisTabs projectId={projectId} inspectionId={inspectionId} />
                }    
                />
            </div>
             {/* overflow-hidden -1 w-full relative overflow-hidden */}
            <div className="relative" style={{ height: '490px' }}>
                <Analysis3DViewer tilesetUrl={tilesetUrl} inspectionId={inspectionId} initialDetections={analysis.detections} 
                    proxyBaseUrl={""} camerasUrl={"/shots.geojson"} canDeleteDefect={false} 
                    canEditDefect={false} layers={[]}/>
            </div>
           
            
        </div>
     );
}
 
export default Analysis3DViewerPage;
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/inspections/[inspectionId]/analysis/table/page.tsx">
import Heading from "@/components/heading";
import { AnalysisTabs } from "../_navigation/tabs";
import DefectTable from "@/features/defects/defect-table";

type TabularAnalysisPageProps = {
    params: Promise<{projectId: string, inspectionId: string}>;
};
const AnalysisTablePage = async ({params}:TabularAnalysisPageProps) => {

    const {projectId, inspectionId}= await params;
    return ( 
        <div className="flex flex-col gap-y-8 ">
            <div className="gap-y-8 " >
                <Heading title="Defects Registry" 
                description="View and manage all defects identified in this inspection." 
                tabs={
                    <AnalysisTabs projectId={projectId} inspectionId={inspectionId} />
                }    
                />
            </div>
            
            <DefectTable 
                inspectionId={inspectionId}
                data={[]}
                onViewDefect={() => {}}
                canDeleteDefect={false}
                canEditDefect={false}
            />
        </div>
     );
}
 
export default AnalysisTablePage;
</file>

<file path="src/app/(saas)/api/aws/s3/supplements/presign-upload/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { S3Client } from "@aws-sdk/client-s3";
import { createPresignedPost } from "@aws-sdk/s3-presigned-post";
import { s3 } from "@/lib/aws";
import { nanoid } from "nanoid";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { getActiveOrganization } from "@/features/organization/queries/get-active-organization";
//import { v4 as uuidv4 } from 'uuid';
import { randomUUID } from 'crypto'; 
import { generateS3Key } from "@/features/supplements/utils/generate-s3-key";
import { SupplementEntity } from "@prisma/client";

export async function POST(request: NextRequest) {


  const { filename, contentType, projectId, entity, entityId, inspectionId } = await request.json();

  try {
    const { user } = await getAuthOrRedirect(); 
    const activeOrganization = await getActiveOrganization();
    if (!activeOrganization)return ;

    if (!user || !activeOrganization.id) {
        return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Generate a unique ID for the attachment on the server
    const attachmentId = randomUUID();
    const s3Key = generateS3Key({
      organizationId: activeOrganization.id,
      projectId,
      entityId,
      entity: entity ,
      fileName: filename,
      attachmentId,
      inspectionId // Pass the context (if it exists)
    });
    // You can add conditions here for file size, type, etc.
    const { url, fields } = await createPresignedPost(s3, {
      Bucket: process.env.AWS_BUCKET_NAME || '',
      Key: s3Key, // A better key structure
      Fields: {
        'Content-Type': contentType,
      },
      Conditions: [
        ['content-length-range', 0, 104857600], // up to 10 MB
      ],
      Expires: 600, // 10 minutes
    });

    return NextResponse.json({ url, fields });

  } catch (error) {
    return NextResponse.json({ error: (error as Error).message }, { status: 500 });
  }
}
</file>

<file path="src/app/(saas)/api/inngest/route.ts">
import { supplementDeletedEvent } from '@/features/supplements/events/event-attachment-deleted'
import { emailVerificationEvent } from '@/features/auth/events/event-email-verification'
import { invitationCreatedEvent } from '@/features/invitation/events/event-invitation-created'
import { organizationCreatedEvent } from '@/features/organization/events/event-organization-created'
import { passwordResetEvent } from '@/features/password/events/event-password-reset'
import {inspectionStartedEvent} from '@/features/inspection/events/event-inspection-created'
import { inngest } from '@/lib/inngest'
import {serve} from 'inngest/next'

export const  {GET, POST, PUT}= serve({
    client:inngest,
    functions: [passwordResetEvent, emailVerificationEvent, 
        invitationCreatedEvent,supplementDeletedEvent, 
        organizationCreatedEvent, inspectionStartedEvent], 
})
</file>

<file path="src/components/forms/submit-buttton.tsx">
'use client';
import { useFormStatus } from "react-dom";
import { LucideLoaderCircle } from "lucide-react";
import { Button } from "../ui/button";
import { cloneElement } from "react";

type SubmitButtonProps = {
  label?: string;
  icon?:  React.ReactElement<React.HTMLAttributes<HTMLElement>> ;
  variant?:
    | "default"
    | "destructive"
    | "outline"
    | "secondary"
    | "ghost"
    | "link";
  size?: "default" | "sm" | "lg" | "icon";
  disabled: boolean
};


const SubmitButton = ({label, icon, variant='default', size='default', disabled= false}: SubmitButtonProps)=>{
    const {pending} = useFormStatus();

    return (
        <Button disabled={pending} type="submit" variant={variant} size={size} >
            {pending ? (
            <LucideLoaderCircle className="h-4 w-4 animate-spin"/>
            ): icon ? (
                <>
                {cloneElement(icon, {className: 'h-4 w-4',})}
                </>
            ): null  }    
            {label}
        </Button>
    );
};

export { SubmitButton };
</file>

<file path="src/components/image-viewer-modal.tsx">
'use client';

import React, { useEffect, useRef, useState, useMemo } from 'react';
import { Button } from "@/components/ui/button";
import { X, Pencil, ZoomIn, ZoomOut, Save, AlertTriangle, MousePointer2, Activity, Hexagon, Square, Undo } from 'lucide-react';
import { Cartesian3, Matrix4, Matrix3, Quaternion } from 'cesium';

// --- Types ---
type ToolType = 'none' | 'rectangle' | 'polygon' | 'polyline';

interface Point { x: number; y: number; }

interface Shape {
    type: ToolType;
    points: Point[];
}

function projectWorldToImage(
    worldPosition: { x: number, y: number, z: number },
    cameraPose: { position: Cartesian3, orientation: Quaternion },
    intrinsics: { width: number, height: number, focal: number }
) {
    const pointWS = new Cartesian3(worldPosition.x, worldPosition.y, worldPosition.z);
    const viewMatrix = Matrix4.fromRotationTranslation(
        Matrix3.fromQuaternion(cameraPose.orientation),
        cameraPose.position
    );
    const inverseView = Matrix4.inverse(viewMatrix, new Matrix4());
    const pointCamera = Matrix4.multiplyByPoint(inverseView, pointWS, new Cartesian3());

    if (pointCamera.z > 0) return null; 

    const effectiveFocal = intrinsics.focal > 0 ? intrinsics.focal : (intrinsics.width * 0.85); 
    const u = (pointCamera.x / -pointCamera.z) * effectiveFocal;
    const v = (pointCamera.y / -pointCamera.z) * effectiveFocal;

    const xPixel = (intrinsics.width / 2) + u;
    const yPixel = (intrinsics.height / 2) - v; 

    if (xPixel < 0 || xPixel > intrinsics.width || yPixel < 0 || yPixel > intrinsics.height) {
        return null;
    }
    return { x: xPixel, y: yPixel };
}

interface CameraContext {
    position: { x: number, y: number, z: number }; 
    orientation: { x: number, y: number, z: number, w: number }; 
    intrinsics: { width: number, height: number, focal: number };
}

interface ImageViewerModalProps {
    src: string;
    onClose: () => void;
    onSave: (drawingData: { points: Point[], imageId: string | null, defectId?: string | null, type: string }) => void;
    imageId: string | null;
    cameraContext?: CameraContext;
    nearbyDefects?: any[]; 
    initialData?: { 
        id: string; 
        points: Point[];
        type?: string; 
    };
}

export const ImageViewerModal = ({
    src,
    onClose,
    onSave,
    imageId,
    cameraContext,
    nearbyDefects = [],
    initialData
}: ImageViewerModalProps) => {
    const [scale, setScale] = useState(1);
    const [offset, setOffset] = useState({ x: 0, y: 0 });
    const [isDrawing, setIsDrawing] = useState(false);
    const [imageLoaded, setImageLoaded] = useState(false);
    //const [paths, setPaths] = useState<{ x: number; y: number }[][]>([]);

    // Drawing State
    const [activeTool, setActiveTool] = useState<ToolType>('none');
    
    // Determine initial shape based on data
    const [savedShape, setSavedShape] = useState<Shape | null>(() => {
        if (initialData?.points && initialData.points.length > 0) {
            // Infer type if not provided: 3+ points = polygon, 2 = polyline, unless explicitly defined
            const inferredType = initialData.points.length > 2 ? 'polygon' : 'polyline';
            return { 
                type: (initialData.type as ToolType) || inferredType, 
                points: initialData.points 
            };
        }
        return null;
    });
    
    const [currentPoints, setCurrentPoints] = useState<Point[]>([]); 
    const [cursorPos, setCursorPos] = useState<Point | null>(null); // For elastic line preview

    const canvasRef = useRef<HTMLCanvasElement>(null);
    const imgRef = useRef<HTMLImageElement>(null);
    const isDragging = useRef(false);
    const lastPos = useRef({ x: 0, y: 0 });
    const currentPath = useRef<{ x: number; y: number }[]>([]);
    const [paths, setPaths] = useState<{ x: number; y: number }[][]>(() => {
        if (initialData?.points && initialData.points.length > 0) {
            return [initialData.points];
        }
        return [];
    });

    const ghostMarkers = useMemo(() => {
        if (!cameraContext || !nearbyDefects.length) return [];

        const pose = {
            position: new Cartesian3(cameraContext.position.x, cameraContext.position.y, cameraContext.position.z),
            orientation: new Quaternion(cameraContext.orientation.x, cameraContext.orientation.y, cameraContext.orientation.z, cameraContext.orientation.w)
        };

        return nearbyDefects.map(defect => {
            let loc = null;
            if (defect.locationOn3dModel?.coordinates?.length > 0) {
                loc = defect.locationOn3dModel.coordinates[0];
            }
            if (!loc) return null;
            const pixel = projectWorldToImage(loc, pose, cameraContext.intrinsics);
            if (!pixel) return null;
            return {
                ...defect,
                pixelX: pixel.x,
                pixelY: pixel.y
            };
        }).filter(Boolean); 
    }, [nearbyDefects, cameraContext]);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !imageLoaded) return;
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 2;
        ctx.lineWidth = 5;

        // Helper to draw a specific shape
        const drawShape = (points: Point[], type: ToolType, isPreview = false) => {
            if (points.length < 1) return;

            ctx.beginPath();
            ctx.lineWidth = 4 / scale; // Keep line thickness constant visually
            ctx.strokeStyle = isPreview ? "#3b82f6" : "#ef4444"; // Blue for preview, Red for saved
            ctx.fillStyle = isPreview ? "rgba(59, 130, 246, 0.2)" : "rgba(239, 68, 68, 0.2)";

            if (type === 'rectangle') {
                const start = points[0];
                const end = points[1] || (isPreview ? cursorPos : start); 
                if(!end) return;
                const w = end.x - start.x;
                const h = end.y - start.y;
                ctx.rect(start.x, start.y, w, h);
                ctx.stroke();
                ctx.fill();
            } 
            else if (type === 'polyline' || type === 'polygon') {
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach(p => ctx.lineTo(p.x, p.y));

                // Rubber-banding: Line to cursor
                if (isPreview && cursorPos && activeTool !== 'none') {
                    ctx.lineTo(cursorPos.x, cursorPos.y);
                }

                // Close path for polygons
                if (type === 'polygon' && (!isPreview || points.length > 2)) {
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.stroke();

                // Draw vertices dots for better editing feel
                if (isPreview) {
                    ctx.fillStyle = "#fff";
                    points.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 4 / scale, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    });
                }
            }
        };

        // 1. Draw Nearby Defects (Ghost Markers)
        // ... (Ghost marker rendering if needed separately, currently handled via DOM overlay in your code)

        // 2. Draw Saved Shape
        if (savedShape) {
            drawShape(savedShape.points, savedShape.type, false);
        }

        // 3. Draw WIP Shape
        if (currentPoints.length > 0) {
            drawShape(currentPoints, activeTool, true);
        }

        // 2. Draw SAVED Drawings (From Database)
        // We filter defects that match this specific image
        nearbyDefects.forEach(defect => {
            
            if (defect.sourceImageId === imageId && Array.isArray(defect.annotation2D)) {
                const points = defect.annotation2D as {x: number, y: number}[];
                
                if (points.length < 2) return;

                // Draw in a different color (e.g., Darker Red or Orange) to distinguish saved vs new
                ctx.strokeStyle = "#b91c1c"; // Dark Red
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach((p) => ctx.lineTo(p.x, p.y));
                ctx.stroke();
            }
        });
        paths.forEach(path => {
            if (path.length < 2) return;
            ctx.lineWidth = 5;
            ctx.strokeStyle = "#ef4444"; 
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            path.forEach((p) => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });
    }, [paths, imageLoaded, nearbyDefects, imageId, savedShape, currentPoints, scale, cursorPos, activeTool]);

    const getImgCoords = (e: React.PointerEvent | React.MouseEvent) => { 
        if (!canvasRef.current) return { x: 0, y: 0 };
        const rect = canvasRef.current.getBoundingClientRect();
        const scaleX = canvasRef.current.width / rect.width;
        const scaleY = canvasRef.current.height / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    };


    const handlePointerDown = (e: React.PointerEvent) => {
        if (activeTool === 'none') {
            isDragging.current = true;
            lastPos.current = { x: e.clientX, y: e.clientY };
            return;
        }

        e.stopPropagation();
        e.currentTarget.setPointerCapture(e.pointerId); // Capture mouse for dragging out of bounds
        const p = getImgCoords(e);

        if (activeTool === 'rectangle') {
            // Start rect
            if (currentPoints.length === 0) {
                setCurrentPoints([p]); 
            }
        } else {
            // Polyline / Polygon: Add vertex
            // If clicking near the start point for Polygon, close it?
            if (activeTool === 'polygon' && currentPoints.length > 2) {
                const start = currentPoints[0];
                const dist = Math.hypot(p.x - start.x, p.y - start.y);
                if (dist < (20 / scale)) {
                    // Clicked start point -> Finish
                    setSavedShape({ type: 'polygon', points: currentPoints });
                    setCurrentPoints([]);
                    return;
                }
            }
            setCurrentPoints(prev => [...prev, p]);
        }
    };

    const handlePointerMove = (e: React.PointerEvent) => {
        // Pan Logic
        if (activeTool === 'none' && isDragging.current) {
            e.preventDefault();
            const dx = e.clientX - lastPos.current.x;
            const dy = e.clientY - lastPos.current.y;
            setOffset(prev => ({ x: prev.x + dx, y: prev.y + dy }));
            lastPos.current = { x: e.clientX, y: e.clientY };
            return;
        }

        const p = getImgCoords(e);
        setCursorPos(p); // Update cursor for rubber-banding

        // Rectangle Drag Logic
        if (activeTool === 'rectangle' && currentPoints.length === 1) {
            // We only store Start and Current here. 
            // In render, we assume points[1] is the cursor/current drag
        }
    };

    const handlePointerUp = (e: React.PointerEvent) => {
        if (activeTool === 'none') {
            isDragging.current = false;
            return;
        }

        if (activeTool === 'rectangle' && currentPoints.length === 1) {
            const p = getImgCoords(e);
            // Finish rectangle
            setSavedShape({ type: 'rectangle', points: [currentPoints[0], p] });
            setCurrentPoints([]);
            e.currentTarget.releasePointerCapture(e.pointerId);
        }
    };

    // Double click to finish Polyline/Polygon
    const handleDoubleClick = (e: React.MouseEvent) => {
        if ((activeTool === 'polyline' || activeTool === 'polygon') && currentPoints.length > 1) {
            setSavedShape({ type: activeTool, points: currentPoints });
            setCurrentPoints([]);
        }
    };

    const handleUndo = () => {
        if (currentPoints.length > 0) {
            // Remove last point of WIP shape
            setCurrentPoints(prev => prev.slice(0, -1));
        } else if (savedShape) {
            // Remove saved shape
            setSavedShape(null);
        }
    };

    const handleSave = () => {
        if (!savedShape) {
            alert("Please draw a defect first.");
            return;
        }
        
        // Flatten logic or shape logic depending on backend.
        // For Rectangle, convert [start, end] to 4 points if needed, or keep as 2.
        // Here we pass strictly what we drew.
        onSave({ 
            points: savedShape.points, 
            imageId,
            defectId: initialData?.id,
            type: savedShape.type 
        });
        
        setActiveTool('none');
    };
return (
        <div className="fixed inset-0 bg-black/95 z-[2000] flex items-center justify-center overflow-hidden" 
            onPointerUp={() => isDragging.current = false}>
            
            {/* --- TOOLBAR --- */}
            <div className="absolute top-4 left-4 z-50 flex flex-col gap-2 bg-black/80 p-2 rounded-lg border border-white/10 backdrop-blur-md shadow-xl">
                <span className="text-[10px] text-white/50 text-center font-mono uppercase tracking-wider mb-1">Tools</span>
                
                {/* Pan Tool */}
                <Button size="icon" onClick={() => { setActiveTool('none'); setCurrentPoints([]); }} 
                    variant={activeTool === 'none' ? "default" : "secondary"} className="h-8 w-8" title="Pan">
                    <MousePointer2 className="w-4 h-4" />
                </Button>
                
                <div className="h-px bg-white/20 my-1" />
                
                {/* Drawing Tools */}
                <Button size="icon" onClick={() => { setActiveTool('polyline'); setCurrentPoints([]); setSavedShape(null); }} 
                    variant={activeTool === 'polyline' ? "default" : "secondary"} className="h-8 w-8" title="Polyline">
                    <Activity className="w-4 h-4" />
                </Button>
                <Button size="icon" onClick={() => { setActiveTool('polygon'); setCurrentPoints([]); setSavedShape(null); }} 
                    variant={activeTool === 'polygon' ? "default" : "secondary"} className="h-8 w-8" title="Polygon">
                    <Hexagon className="w-4 h-4" />
                </Button>
                <Button size="icon" onClick={() => { setActiveTool('rectangle'); setCurrentPoints([]); setSavedShape(null); }} 
                    variant={activeTool === 'rectangle' ? "default" : "secondary"} className="h-8 w-8" title="Rectangle">
                    <Square className="w-4 h-4" />
                </Button>

                <div className="h-px bg-white/20 my-1" />
                
                <Button size="icon" onClick={handleUndo} variant="destructive" className="h-8 w-8 bg-red-900/50 hover:bg-red-900" title="Undo">
                    <Undo className="w-4 h-4" />
                </Button>
                <Button size="icon" onClick={() => setScale(s => Math.min(5, s + 0.5))} variant="secondary" className="h-8 w-8"><ZoomIn className="w-4 h-4" /></Button>
                <Button size="icon" onClick={() => setScale(s => Math.max(0.1, s - 0.5))} variant="secondary" className="h-8 w-8"><ZoomOut className="w-4 h-4" /></Button>
            </div>

            {/* Save Button */}
            {savedShape && (
                <div className="absolute top-4 left-24 z-50 ml-4">
                    <Button onClick={handleSave} className="bg-green-600 hover:bg-green-700 text-white gap-2 shadow-lg">
                        <Save className="w-4 h-4" />
                        Save Defect
                    </Button>
                </div>
            )}

            {/* Close Button */}
            <Button size="icon" className="absolute top-4 right-4 z-50 rounded-full bg-white/10 hover:bg-white/20" onClick={onClose}>
                <X className="w-6 h-6" />
            </Button>

            {/* Canvas Area */}
            <div className="relative w-full h-full flex items-center justify-center overflow-hidden" 
                style={{ cursor: activeTool === 'none' ? (isDragging.current ? 'grabbing' : 'grab') : 'crosshair' }}>
                <div className="relative shadow-2xl transition-transform duration-75 ease-out" 
                    style={{ transform: `translate(${offset.x}px, ${offset.y}px) scale(${scale})` }}>
                    
                    <img ref={imgRef} src={src} 
                        className="max-h-[85vh] max-w-[90vw] object-contain pointer-events-none select-none" 
                        onLoad={(e) => {
                            setImageLoaded(true);
                            if(canvasRef.current) {
                                canvasRef.current.width = e.currentTarget.naturalWidth;
                                canvasRef.current.height = e.currentTarget.naturalHeight;
                            }
                        }}
                    />
                    
                    <canvas ref={canvasRef} 
                        className="absolute top-0 left-0 w-full h-full" 
                        style={{ pointerEvents: 'auto' }} 
                        onPointerDown={handlePointerDown} 
                        onPointerMove={handlePointerMove} 
                        onPointerUp={handlePointerUp}
                        onDoubleClick={handleDoubleClick}
                    />
                    
                    {/* Render Ghost Markers (DOM layer) */}
                    {imageLoaded && ghostMarkers.map((marker, i) => (
                        <div key={marker.id || i} className="absolute flex items-center justify-center group cursor-pointer z-20" style={{ left: marker.pixelX, top: marker.pixelY, transform: 'translate(-50%, -50%)' }} onClick={(e) => { e.stopPropagation(); alert(`Existing defect #${marker.id.substring(0,8)} found here.`); }}>
                            <div className="relative">
                                <div className="absolute inset-0 bg-yellow-400 rounded-full animate-ping opacity-75" />
                                <div className="relative w-8 h-8 bg-yellow-500 rounded-full border-2 border-white flex items-center justify-center shadow-lg hover:scale-110 transition-transform">
                                    <AlertTriangle className="w-4 h-4 text-black" />
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>

            {/* Instructions Overlay */}
            <div className="absolute bottom-8 left-1/2 -translate-x-1/2 text-white/90 text-sm bg-black/60 px-6 py-2 rounded-full backdrop-blur pointer-events-none border border-white/10">
                {activeTool === 'none' && "Pan and zoom to inspect."}
                {activeTool === 'rectangle' && "Click and drag to box a defect."}
                {activeTool === 'polyline' && "Click to add points. Double-click to finish."}
                {activeTool === 'polygon' && "Click to add points. Double-click or click start to close."}
            </div>
        </div>
    );
};
</file>

<file path="src/components/search-input.tsx">
'use client';
import { Input } from "./ui/input";
import {useDebouncedCallback} from 'use-debounce' ; 

type SearchInputProps={
    placeholder: string;
    value: string;
    onChange:(value: string)=>void;
}

export const SearchInput = ({placeholder, value, onChange}: SearchInputProps) => {


    const handleSearch= useDebouncedCallback((event: React.ChangeEvent<HTMLInputElement>)=>{

        onChange(event.target.value)
    }, 300)
    return ( 
        <Input defaultValue={value}
         placeholder={placeholder} onChange={handleSearch} />
    );
    
}
</file>

<file path="src/components/theme/theme-provider.tsx">
import { ThemeProvider as BaseThemeProvider, ThemeProviderProps} from "next-themes";


const ThemeProvider = ({children}:ThemeProviderProps) => {
    return ( 
        <BaseThemeProvider attribute='class' 
        defaultTheme="system" enableSystem>
            {children}</BaseThemeProvider>
     );
}

export {ThemeProvider}
</file>

<file path="src/components/theme/theme-switcher.tsx">
'use client';
import { Moon, SunMedium } from "lucide-react";
import { Button } from "../ui/button";
import { useTheme } from "next-themes";

export const ThemeSwitcher = () => {
    const {theme, setTheme}= useTheme()
    return ( 
        <Button size='icon' variant="outline"  onClick={()=>setTheme(
            theme === 'light'? 'dark':'light')} >
            {theme==='light'?<SunMedium />:<Moon />}
            <span className="sr-only" >Toggle Theme</span>
        </Button>
     );
}
</file>

<file path="src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="src/features/auth/actions/email-verification.ts">
'use server';

import { ActionState, 
    formErrorToActionState, 
    toActionState } from "@/components/forms/utils/to-action-state";
import { prisma } from "@/lib/prisma";
 
import z from "zod";
import { createSession } from '@/lib/lucia';
import { generateRandomToken } from '@/utils/crypto';
import { setSessionCookie } from '../utils/session-cookie';
import { redirect } from 'next/navigation';
import { projectsPath } from '@/path';
import { getAuthOrRedirect } from '../queries/get-auth-or-rerdirect';
import { setCookieByKey } from '@/actions/cookies';
import { validateEmailVerificationCode } from '../utils/validate-email-verification-code';


const emailVerificationSchema = z.object({

    code: z.string().length(8),
  });

const emailVerification =  async (_actionState:ActionState, 
    formData: FormData) => {
    
    const {user} = await getAuthOrRedirect({
        checkEmailVerified:false,
        checkOrganization: false,
        checkActiveOrganization: false,
    });
    
    try {
        const { code }= emailVerificationSchema.parse(
            {code: formData.get('code')}
        );

        const validCode = await validateEmailVerificationCode(
            user.id,
            user.email,
            code
        );

        if(!validCode){
            return toActionState('Error', 'Invalid code');
        };

        await prisma.session.deleteMany({
            where:{
                userId: user.id,
            },
        });

        await prisma.user.update({
            where:{
                id: user.id,
            },
            data:{
                emailVerified: true,
            },
        });

        const sessionToken = generateRandomToken();
        const session= await createSession(sessionToken, user.id);
        
        await setSessionCookie(sessionToken, session.expiresAt);
       
    } catch (error) {
      return  formErrorToActionState(error, formData)
    }   

    await setCookieByKey('toast', 'Email Verified');
    redirect(projectsPath())
    

};

export { emailVerification }
</file>

<file path="src/features/auth/actions/sign-in.ts">
'use server';

import {verify} from '@node-rs/argon2';
import { ActionState, 
    formErrorToActionState, 
    toActionState } from "@/components/forms/utils/to-action-state";
import { prisma } from "@/lib/prisma";
 
import z from "zod";
import { createSession } from '@/lib/lucia';
import { generateRandomToken } from '@/utils/crypto';
import { setSessionCookie } from '../utils/session-cookie';
import { redirect } from 'next/navigation';
import { projectsPath } from '@/path';


const signInSchema = z.object({

    email: z.string().min(1, { message: "Is required" }).max(191).email(),
    password: z.string().min(6).max(191),
  });

const SignIn =  async (_actionState:ActionState, formData: FormData) => {
    try {
        const { email, password}= signInSchema.parse(
            Object.fromEntries(formData)
        );

        const user = await prisma.user.findUnique({
            where: {email},
        }
        );

  
        const verifyPasswd = await verify(user? user.passwordHash :
            '$argon', password);

        if(!user || !verifyPasswd){
            return toActionState('Error', 'Incorrect email or password', formData);
        }
        const sessionToken = generateRandomToken();
        const session= await createSession(sessionToken, user.id);
        
        await setSessionCookie(sessionToken, session.expiresAt);
       
    } catch (error) {
      return  formErrorToActionState(error, formData)
    }   

    redirect(projectsPath())
    

};

export { SignIn }
</file>

<file path="src/features/auth/actions/sign-up.ts">
'use server';

import { ActionState, formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { createSession } from "@/lib/lucia";
import { prisma } from "@/lib/prisma";
import { generateRandomToken } from "@/utils/crypto";
import z from "zod";
import { setSessionCookie } from "../utils/session-cookie";
import { hashPassword } from "@/features/password/utils/hash-and-verify";
import { redirect } from "next/navigation";
import { projectsPath } from "@/path";
 
import { inngest } from "@/lib/inngest";
import { MembershipRole, Prisma } from "@prisma/client";

const signUpSchema = z
  .object({
    username: z
      .string()
      .min(1)
      .max(191)
      .refine(
        (value) => !value.includes(" "),
        "Username cannot contain spaces"
      ),
    email: z.string().min(1, { message: "Is required" }).max(191).email(),
    password: z.string().min(6).max(191),
    confirmPassword: z.string().min(6).max(191),
  })
  .superRefine(({ password, confirmPassword }, ctx) => {
    if (password !== confirmPassword) {
      ctx.addIssue({
        code: "custom",
        message: "Passwords do not match",
        path: ["confirmPassword"],
      });
    }
  });

export const SignUp = async (
  _actionState:ActionState, 
  formData: FormData) => {
    try {
        const {username, email, password}= signUpSchema.parse(
            Object.fromEntries(formData)
        );
        const passwordHash = await hashPassword(password);

        const user = await prisma.user.create({
          data: {
            username,
            email,
            passwordHash,
          },
        });

        const invitations = await prisma.invitation.findMany({
          where:{
            email,
          },
        });
        
        await prisma.$transaction([
         prisma.invitation.deleteMany({
          where:{
            email,
          },
        }),

         prisma.membership.createMany({
          data: invitations.map((invitation)=>({
            organizationId: invitation.organizationId,
            userId: user.id,
            MembershipRole: "MEMBER",
            isActive: false,
            }))
          })          
        ]);

        await inngest.send({
          name:'app/auth.sign-up',
          data:{
            userId: user.id
          }
        })
        
        const sessionToken = generateRandomToken();
        const session = await createSession(sessionToken, user.id);

        await setSessionCookie(sessionToken, session.expiresAt);


    }  catch (error) {
      if (
        error instanceof Prisma.PrismaClientKnownRequestError &&
        error.code === "P2002"
      ) {
        return toActionState(
          "Error",
          "Either email or username is already in use",
          formData
        );
      }

      return formErrorToActionState(error, formData);
    }

  redirect(projectsPath());
};
</file>

<file path="src/features/auth/components/email-verification-form.tsx">
"use client";
import { FieldErrorMsg } from "@/components/forms/field-error";
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Input } from "@/components/ui/input";
import { useActionState } from "react";
import { emailVerification } from "../actions/email-verification";


export const EmailVerificationForm = () => {
    const [actionState, action]= useActionState(emailVerification, EMPTY_ACTION_STATE)
    return ( 
        <Form action={action} actionState={actionState} >

            <Input name="code" placeholder="Code"  
                defaultValue={ actionState.payload?.get('code') as string } />
            <FieldErrorMsg name="code" actionState={actionState} />

            <SubmitButton label="Verify Email" disabled />
        </Form>
     );
};
</file>

<file path="src/features/auth/components/email-verification-resend-form.tsx">
'use client';
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { useActionState } from "react";
import { emailVerificationResend } from "../actions/email-verification-resend";

export const EmailVerificationResendForm = () => {
    const [actionState, action]= useActionState(emailVerificationResend, EMPTY_ACTION_STATE)
    return ( 
        <Form action={action} actionState={actionState} >
            <SubmitButton label="Resend Code" disabled />
        </Form>
     );
};
</file>

<file path="src/features/auth/components/sign-in-form.tsx">
'use client';
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { Input } from "@/components/ui/input";

import { useActionState } from "react";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { FieldErrorMsg } from "@/components/forms/field-error";
import { SignIn } from "../actions/sign-in";

const SignInForm = () => {
    const [actionState, action]= useActionState(SignIn, EMPTY_ACTION_STATE)
    return ( 
        <Form action={action} actionState={actionState} >

            <Input name="email" placeholder="Email"  
                defaultValue={ actionState.payload?.get('email') as string } />
            <FieldErrorMsg name="email" actionState={actionState} />

            <Input name="password" placeholder="Password" type="password" 
                defaultValue={ actionState.payload?.get('password') as string }/>
            <FieldErrorMsg name="password" actionState={actionState} />


            <SubmitButton label="Sign In" disabled />
        </Form>
     );
}

export {SignInForm}
</file>

<file path="src/features/auth/components/sign-up-form.tsx">
'use client';

import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { Input } from "@/components/ui/input";
import { SignUp } from "../actions/sign-up";
import { useActionState } from "react";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { FieldErrorMsg } from "@/components/forms/field-error";

const SignUpForm = () => {
    const [actionState, action]= useActionState(SignUp, EMPTY_ACTION_STATE)
    return ( 
        <Form action={action} actionState={actionState} >
            <Input name="username" placeholder="username" 
                defaultValue={ actionState.payload?.get('username') as string }/>
            <FieldErrorMsg name="username" actionState={actionState} />

            <Input name="email" placeholder="Email" 
                defaultValue={ actionState.payload?.get('email') as string }/>
            <FieldErrorMsg name="email" actionState={actionState} />

            <Input name="password" placeholder="Password" type="password" 
                defaultValue={ actionState.payload?.get('password') as string }/>
            <FieldErrorMsg name="password" actionState={actionState} />

            <Input name="confirmPassword" 
                placeholder="Confirm Password" 
                type="password" 
                defaultValue={ actionState.payload?.get('confirmPassword') as string }/>
            <FieldErrorMsg name="confirmPassword" actionState={actionState} />

            <SubmitButton label="Sign Up" disabled />
        </Form>
     );
}

export {SignUpForm}
</file>

<file path="src/features/auth/hooks/use-auth.ts">
import {  usePathname } from "next/navigation";
import { getAuth } from "@/features/auth/queries/get-auth";
import { useEffect, useState } from "react";
import { User } from "@prisma/client";

const useAuth = ()=>{
    const [user, setUser]= useState<User | null>(null);
        const[isFetched, setFetch]= useState(false);
        const pathname= usePathname();

        useEffect(() => {
            const fetchUser= async () => {
            const { user }= await getAuth(); 
            setUser(user);
            setFetch(true);
            };

            fetchUser();
        }, [pathname]);

    return {user, isFetched};
};

export {useAuth}
</file>

<file path="src/features/credential/components/credential-create-button.tsx">
"use client";

import { LucidePlus } from "lucide-react";
import { useActionState, useState } from "react";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { Form } from "@/components/forms/form";
import { FieldErrorMsg } from "@/components/forms/field-error";
import { createCredential } from "../actions/create-credential";

type CredentialCreateButtonProps = {
  organizationId: string;
};

const CredentialCreateButton = ({
  organizationId,
}: CredentialCreateButtonProps) => {
  const [open, setOpen] = useState(false);

  const [actionState, action] = useActionState(
    createCredential.bind(null, organizationId),
    EMPTY_ACTION_STATE
  );

  const handleClose = () => {
    setOpen(false);
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button>
          <LucidePlus className="w-4 h-4" />
          Create Credential
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Create Credential</DialogTitle>
          <DialogDescription>
            Create a new API secret for your organization
          </DialogDescription>
        </DialogHeader>
        <Form
          action={action}
          actionState={actionState}
          onSuccess={handleClose}
          toastOptions={{
            duration: Infinity,
            closeButton: true,
          }}
        >
          <div className="grid gap-4 py-4">
            <div>
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="name" className="text-right">
                  Name
                </Label>
                <Input name="name" id="name" className="col-span-3" />
              </div>
              <div className="grid grid-cols-4 items-center gap-4">
                <div />
                <div className="col-span-3">
                  <FieldErrorMsg actionState={actionState} name="name" />
                </div>
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button type="button" variant="outline" onClick={handleClose}>
              Cancel
            </Button>
            <SubmitButton label="Create" disabled/>
          </DialogFooter>
        </Form>
      </DialogContent>
    </Dialog>
  );
};

export { CredentialCreateButton };
</file>

<file path="src/features/defects/actions/delete-detection.ts">
"use server";

import { setCookieByKey } from "@/actions/cookies";
import { ActionState, formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { IsOwner } from "@/features/auth/utils/is-owner";
import { prisma } from "@/lib/prisma";
import { ticketsPath } from "@/path";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { getDefectPermissions } from "../permissions/get-defect-permissions";

const deleteDefect = async (defectId: string)  => {
    
    const { user, activeOrganization } = await getAuthOrRedirect();

    try {
        if (!user || !activeOrganization) {
            return toActionState('Error', 'Not Authenticated');
        }

        const permissions = await getDefectPermissions({
            userId: user.id,
            organizationId: activeOrganization.id
        });

        if (!permissions.canDeleteDefect) {
            return toActionState('Error', 'You do not have permission to delete defects.');
        }
        
        //Find the defect and verify it belongs to the user's org.
        const detection = await prisma.detection.findFirst({
            where: {
                id: defectId,
                analysis: {
                    inspection: {
                        project: {
                            organizationId: activeOrganization.id
                        }
                    }
                }
            }
        });

        if (!detection) {
            return toActionState('Error', 'Defect not found or you are not authorized.');
        }

        // Delete the defect
        await prisma.detection.delete({
            where: { id: defectId }
        });

       

    } catch (error) {
        return toActionState('Error', 'An unexpected error occurred.');
    }


    //await setCookieByKey('toast', "Defect deleted!");
    return toActionState('Success', 'Defect deleted!');

};

export {deleteDefect}
</file>

<file path="src/features/defects/columns.tsx">
"use client"

import { ColumnDef } from "@tanstack/react-table"
import {  Eye, MoreHorizontal } from "lucide-react"
import { ArrowUpDown } from "lucide-react"
 
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import { DETECTION_TYPES, STATUSES, SEVERITIES } from "../constants"
import { DetectionType, DetectionSeverity, DetectionStatus } from "@prisma/client";
import { Badge } from "@/components/ui/badge"

// This type is used to define the shape of our data.
// You can use a Zod schema here if you want.
export type Defect = {
  id: string;
  type: DetectionType | null;
  severity: DetectionSeverity | null;
  status: DetectionStatus | null;
}

export const getColumns = (onViewDefect: (id: string) => void): ColumnDef<Defect>[] => [
    {
    id: "select",
    header: ({ table }) => (
      <Checkbox
        checked={
          table.getIsAllPageRowsSelected() ||
          (table.getIsSomePageRowsSelected() && "indeterminate")
        }
        onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}
        aria-label="Select all"
      />
    ),
    cell: ({ row }) => (
      <Checkbox
        checked={row.getIsSelected()}
        onCheckedChange={(value) => row.toggleSelected(!!value)}
        aria-label="Select row"
      />
    ),
    enableSorting: false,
    enableHiding: false,
  },
  //  DEFECT TYPE COLUMN (Mapped from Constants)
  {
    accessorKey: "type",
    header: "Defect type",
    cell: ({ row }) => {
      // Find the constant object that matches the row value
      const type = DETECTION_TYPES.find(
        (t) => t.value === row.getValue("type")
      );

      if (!type) {
        return null;
      }

      return (
        <div className="flex items-center">
          {type.icon && (
            <type.icon className="mr-2 h-4 w-4 text-muted-foreground" />
          )}
          <span>{type.label}</span>
        </div>
      )
    },
  },
    //  STATUS COLUMN (Mapped from Constants)
  {
    accessorKey: "status",
    header: "Status",
    cell: ({ row }) => {
      const status = STATUSES.find(
        (s) => s.value === row.getValue("status")
      )

      if (!status) {
        return null
      }

      return (
        <div className="flex w-[100px] items-center">
          {status.icon && (
            <status.icon className="mr-2 h-4 w-4 text-muted-foreground" />
          )}
          <span>{status.label}</span>
        </div>
      )
    },
  },
    // SEVERITY COLUMN (Mapped from Constants)
  {
    accessorKey: "severity",
    header: ({ column }) => {
      return (
        <Button
          variant="ghost"
          onClick={() => column.toggleSorting(column.getIsSorted() === "asc")}
        >
          Severity
          <ArrowUpDown className="ml-2 h-4 w-4" />
        </Button>
      )
    },
    cell: ({ row }) => {
      const severity = SEVERITIES.find(
        (s) => s.value === row.getValue("severity")
      )

      if (!severity) {
        return null
      }

      // Map specific severities to Badge colors
      const variant = 
        severity.value === "CRITICAL" ? "destructive" :
        severity.value === "HIGH" ? "default" :  "secondary"; // secondary is usually gray

      return (
        <div className="flex items-center">
           <Badge variant={variant} className="flex items-center gap-1 font-normal">
              {severity.icon && <severity.icon className="h-3 w-3" />}
              {severity.label}
           </Badge>
        </div>
      )
    },
  },

  {
    id: "actions",
    cell: ({ row }) => {
      const defect = row.original
 
      return (
        <div className="flex items-center gap-2">
            {/* NEW: Quick View Button directly in row */}
            <Button 
                variant="ghost" 
                size="sm" 
                onClick={() => onViewDefect(defect.id)}
                className="h-8 w-8 p-0"
            >
                <Eye className="h-4 w-4" />
                <span className="sr-only">View on Map</span>
            </Button>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" className="h-8 w-8 p-0">
              <span className="sr-only">Open menu</span>
              <MoreHorizontal className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuLabel>Actions</DropdownMenuLabel>
            <DropdownMenuItem
              onClick={() => navigator.clipboard.writeText(defect.id)}
            >
              Copy Defect ID
            </DropdownMenuItem>
            <DropdownMenuSeparator />
            <DropdownMenuItem onClick={() => onViewDefect(defect.id)}>
                    View on Map
            </DropdownMenuItem>
            <DropdownMenuItem>View details</DropdownMenuItem>
            <DropdownMenuItem className="text-destructive">Delete defect</DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
        </div>
      )
    },
  },
]
</file>

<file path="src/features/defects/data/index.ts">
export * from "./create-defect";
export * from "./connect-referenced-defects";
</file>

<file path="src/features/defects/types.ts">
import { Prisma } from "@prisma/client"

// export type TicketWithMetadata = Prisma.DetectionGetPayload<{
//         include: { user: {select:{username: true}} }
//     }> & { isOwner: boolean , permissions : { canDeleteTicket: boolean} }
</file>

<file path="src/features/inspection/actions/delete-inspection.ts">
'use server';

import { toActionState } from "@/components/forms/utils/to-action-state";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { prisma } from "@/lib/prisma";
import { getInspections } from "../queries/get-inspections";
import { getInspection } from "../queries/get-inspection";
import { getInspectionPermissions } from "../permissions/get-inspection-permissions";


type deleteInspectionProps = {
    inspectionId:string; 
    conductedByUserId:string | null ;
}
export const deleteInspection = async({
    inspectionId, 
    conductedByUserId}:deleteInspectionProps) => {
    
    const {user, activeOrganization}=await getAuthOrRedirect();
    
    if (!user || !activeOrganization) {
        return toActionState('Error', 'Not Authenticated');
        }
    
    const permissions = await getInspectionPermissions({
                userId: user.id,
                organizationId: activeOrganization.id
        });
    
    if (!permissions.canDeleteInspection) {
        return toActionState('Error', 'You do not have permission to delete defects.');
        }

    const targetInspection =  await getInspection(inspectionId)
    console.log('Target Inspection : ', targetInspection)

    if(!targetInspection){
        return toActionState('Error', 'Inspection not found');
    }

    await prisma.inspection.delete({
        where:{
            id:targetInspection.id,
            conductedByUserId:targetInspection.conductedByUserId
        },
    });

    return toActionState('Success',  
        'Inspection has been deleted!');
}
</file>

<file path="src/features/inspection/actions/toggle-permission.ts">
'use server';
import { prisma } from "@/lib/prisma";
import { toActionState } from "@/components/forms/utils/to-action-state";
import { revalidatePath } from "next/cache";
import { membershipsPath } from "@/path";
import { getAdminOrRedirect } from "../queries/get-admin-or-redirect";

type PermissionKey='canDeleteDefect';

export const togglePermission = async ({userId,
            organizationId,
            permissionKey}:{
                userId: string,
                organizationId: string,
                permissionKey: PermissionKey
            }) => {
    await getAdminOrRedirect(organizationId);

    const where = {
        MembershipId:{
            organizationId,
            userId,
        },
    };

    const membership = await prisma.membership.findUnique({
        where,
    });

    if(!membership){
        return toActionState('Error', "Membership not Found");
    }

    await prisma.membership.update({
        where,
        data:{
            [permissionKey]: membership[permissionKey] === true ? false : true,
        },
    });

    revalidatePath(membershipsPath(organizationId));

    return toActionState('Success', 'Permission updated');

}
</file>

<file path="src/features/inspection/components/inspection-list.tsx">
import { RealtimeChannel } from "@supabase/supabase-js";
import { supabase } from "@/lib/supabase";
import { format } from "date-fns";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { getInspections } from "../queries/get-inspections";

import { InspectionDeleteButton } from "./inspection-delete-button";
import { InspectionItem } from "./inspection-item";
import { Inspection } from "@prisma/client";

//import { useRouter } from "next/navigation";


export const revalidate = 0;

type InspectionListPageProp = {
    userId : string;
    projectId: string;
    canDelete: boolean;
};


export const InspectionList = async ({userId ,projectId, canDelete}:InspectionListPageProp) => {
    //const router = useRouter();
    const inspections =  await getInspections(projectId);
    
    return ( 
        <Table>
            <TableHeader>
                <TableRow>
                    <TableHead>title</TableHead>
                    {/* <TableHead>Email</TableHead> */}
                    <TableHead>inspection Date</TableHead>
                    <TableHead>status</TableHead>
                    {/* <TableHead>Role</TableHead>
                    <TableHead>Can Delete</TableHead> */}
                </TableRow>
            </TableHeader>

            <TableBody>
                {inspections.map((inspection)=>
                    <InspectionItem inspection={inspection}  key={inspection.id} canDelete={canDelete}/>
                
                )}
            </TableBody>
        </Table>
     );
}
</file>

<file path="src/features/inspection/components/inspection-more-menu.tsx">
"use client";
import { Button } from "@/components/ui/button";
import { MembershipRole } from "@prisma/client";
import { LucideUserCog } from "lucide-react";
import { toast } from "sonner";
//import { updateMembershipRole } from "../actions/update-membership-role";
import { DropdownMenu, DropdownMenuContent, DropdownMenuLabel,
     DropdownMenuRadioGroup, DropdownMenuRadioItem, 
     DropdownMenuSeparator, DropdownMenuTrigger
     } from "@/components/ui/dropdown-menu";

type InspectionMoreMenuProps={
    projectId: string;
    userId: string;
    //membershipRole: MembershipRole
}
export const InspectionMoreMenu = ({
    projectId, 
    userId, 
   // membershipRole
}:InspectionMoreMenuProps) => {
    
    const handleUpdateMembershipRole= async(value: string)=>{
        // const promise= updateMembershipRole({
        //     projectId,
        //     userId,
        //     membershipRole: value as MembershipRole,
        // });

        // toast.promise(promise, {
        //     loading: 'Updating membership role...',
        // });

        // const result= await promise;
        
        // if(result.status === 'Error'){
        //     toast.error(result.message);
        // }else{
        //     toast.success(result.message);
        // }
    }
    
    return ( 
        <DropdownMenu>
            <DropdownMenuTrigger asChild >
                <Button variant='outline'  size="icon" >
                    <LucideUserCog className="h-4 w-4" />
                </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent className="w-56" >
                <DropdownMenuLabel>Role</DropdownMenuLabel>
                <DropdownMenuSeparator />
                <DropdownMenuRadioGroup 
                   value={MembershipRole.MEMBER} 
                   onValueChange={handleUpdateMembershipRole}
                >
                    <DropdownMenuRadioItem value="ADMIN" >Admin</DropdownMenuRadioItem>
                    <DropdownMenuRadioItem value="MEMBER" >Member</DropdownMenuRadioItem>
                </DropdownMenuRadioGroup>
            </DropdownMenuContent>
        </DropdownMenu>
     );
}
</file>

<file path="src/features/inspection/components/inspection-pdf-template.tsx">
/* eslint-disable jsx-a11y/alt-text */
import { Document, Page, Text, View, StyleSheet } from '@react-pdf/renderer';
import { Detection } from '@prisma/client';


const styles = StyleSheet.create({
  page: { padding: 40, fontFamily: 'Helvetica', backgroundColor: '#ffffff', color: '#334155' },
  
  // -- Header Section --
  headerContainer: { flexDirection: 'row', justifyContent: 'space-between', marginBottom: 40, borderBottomWidth: 1, borderBottomColor: '#e2e8f0', paddingBottom: 20 },
  brandSection: { flexDirection: 'column' },
  metaSection: { flexDirection: 'column', alignItems: 'flex-end' },
  brandTitle: { fontSize: 10, color: '#64748b', textTransform: 'uppercase', letterSpacing: 1, marginBottom: 4 },
  projectTitle: { fontSize: 20, fontWeight: 'bold', color: '#0f172a' },
  metaText: { fontSize: 9, color: '#64748b', marginBottom: 2 },

  // -- Executive Summary --
  sectionTitle: { fontSize: 14, fontWeight: 'bold', color: '#0f172a', marginBottom: 15, textTransform: 'uppercase', letterSpacing: 0.5 },
  statsContainer: { flexDirection: 'row', gap: 10, marginBottom: 30 },
  statBox: { flex: 1, padding: 15, borderRadius: 6, backgroundColor: '#f8fafc', border: '1px solid #e2e8f0' },
  statLabel: { fontSize: 9, color: '#64748b', marginBottom: 4, textTransform: 'uppercase' },
  statNumber: { fontSize: 24, fontWeight: 'bold', color: '#0f172a' },
  
  // -- Breakdown --
  breakdownContainer: { marginBottom: 30, padding: 15, backgroundColor: '#f8fafc', borderRadius: 6 },
  breakdownRow: { flexDirection: 'row', justifyContent: 'space-between', marginBottom: 6, borderBottomWidth: 1, borderBottomColor: '#e2e8f0', paddingBottom: 4 },
  breakdownLabel: { fontSize: 10, color: '#334155' },
  breakdownValue: { fontSize: 10, fontWeight: 'bold', color: '#0f172a' },

  // -- Detailed Log --
  defectCard: { marginBottom: 15, borderRadius: 6, border: '1px solid #e2e8f0', overflow: 'hidden' },
  cardHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', padding: 10, backgroundColor: '#f1f5f9' },
  cardTitle: { fontSize: 11, fontWeight: 'bold', color: '#334155' },
  cardBody: { padding: 10, flexDirection: 'row' },
  dataColumn: { width: '40%', paddingRight: 10 },
  imageColumn: { width: '60%', height: 120, backgroundColor: '#f8fafc', borderRadius: 4, alignItems: 'center', justifyContent: 'center', border: '1px solid #e2e8f0' },
  
  // -- Fields --
  fieldRow: { marginBottom: 8 },
  fieldLabel: { fontSize: 8, color: '#94a3b8', marginBottom: 2, textTransform: 'uppercase' },
  fieldValue: { fontSize: 10, color: '#0f172a' },

  // -- Badges --
  badge: { paddingHorizontal: 8, paddingVertical: 3, borderRadius: 10, fontSize: 8, fontWeight: 'bold' },
  // Status Colors
  statusResolved: { backgroundColor: '#dcfce7', color: '#166534' },
  statusOpen: { backgroundColor: '#fee2e2', color: '#991b1b' },
  // Severity Colors
  severityCritical: { color: '#ef4444' },
  severityHigh: { color: '#f97316' },
  severityMedium: { color: '#eab308' },
  severityLow: { color: '#64748b' },
});

interface InspectionPDFProps {
  inspectionId: string;
  defects: Detection[];
  projectName?: string;
}

export const InspectionPDFTemplate = ({ inspectionId, defects, projectName }: InspectionPDFProps) => {
  if (defects.length === 0) return null;

  // --- Calculations ---
  const totalDefects = defects.length;
  const resolvedCount = defects.filter(d => d.status === 'RESOLVED').length;
  const pendingCount = totalDefects - resolvedCount;
  const criticalCount = defects.filter(d => d.severity === 'CRITICAL').length;

  // Group by Type
  const typeCounts = defects.reduce((acc, defect) => {
    const type = defect.type || 'Unknown';
    acc[type] = (acc[type] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // Helper for Severity Color
  const getSeverityStyle = (severity: string) => {
    switch (severity) {
      case 'CRITICAL': return styles.severityCritical;
      case 'HIGH': return styles.severityHigh;
      case 'MEDIUM': return styles.severityMedium;
      default: return styles.severityLow;
    }
  };

  return (
    <Document>
      <Page size="A4" style={styles.page}>
        
        {/* --- 1. HEADER --- */}
        <View style={styles.headerContainer}>
            <View style={styles.brandSection}>
                <Text style={styles.brandTitle}>INSPECTION REPORT</Text>
                <Text style={styles.projectTitle}>{projectName || 'Project Report'}</Text>
            </View>
            <View style={styles.metaSection}>
                <Text style={styles.metaText}>Date: {new Date().toLocaleDateString()}</Text>
                <Text style={styles.metaText}>Ref: #{inspectionId.split('-').pop()}</Text>
            </View>
        </View>

        {/* --- 2. EXECUTIVE SUMMARY --- */}
        <Text style={styles.sectionTitle}>Executive Summary</Text>
        <View style={styles.statsContainer}>
            {/* Box 1: Total */}
            <View style={styles.statBox}>
                <Text style={styles.statLabel}>Total Findings</Text>
                <Text style={styles.statNumber}>{totalDefects}</Text>
            </View>
            {/* Box 2: Critical */}
            <View style={[styles.statBox, { backgroundColor: '#fef2f2', borderColor: '#fee2e2' }]}>
                <Text style={[styles.statLabel, { color: '#ef4444' }]}>Critical Risks</Text>
                <Text style={[styles.statNumber, { color: '#ef4444' }]}>{criticalCount}</Text>
            </View>
            {/* Box 3: Pending Actions (Better than "Resolved") */}
            <View style={[styles.statBox, { backgroundColor: pendingCount > 0 ? '#fff7ed' : '#f0fdf4' }]}>
                <Text style={styles.statLabel}>Action Items Pending</Text>
                <Text style={[styles.statNumber, { color: pendingCount > 0 ? '#ea580c' : '#166534' }]}>
                    {pendingCount}
                </Text>
            </View>
        </View>

        {/* --- 3. BREAKDOWN --- */}
        <Text style={styles.sectionTitle}>Defect Breakdown</Text>
        <View style={styles.breakdownContainer}>
            {Object.entries(typeCounts).map(([type, count]) => (
                <View key={type} style={styles.breakdownRow}>
                    <Text style={styles.breakdownLabel}>{type.replace('_', ' ')}</Text>
                    <Text style={styles.breakdownValue}>{count}</Text>
                </View>
            ))}
        </View>

        {/* --- 4. DETAILED LOG --- */}
        <Text style={[styles.sectionTitle, { marginTop: 20 }]}>Detailed Inspection Log</Text>
        {defects.map((defect, index) => (
          <View key={defect.id} style={styles.defectCard} wrap={false}>
            <View style={styles.cardHeader}>
                <Text style={styles.cardTitle}>#{index + 1} - {defect.type?.replace('_', ' ')}</Text>
                <Text style={[styles.cardTitle, getSeverityStyle(defect.severity || 'LOW')]}>
                    {defect.severity}
                </Text>
            </View>
            
            <View style={styles.cardBody}>
                <View style={styles.dataColumn}>
                    <View style={styles.fieldRow}>
                        <Text style={styles.fieldLabel}>Status</Text>
                        <View style={[
                            styles.badge, 
                            defect.status === 'RESOLVED' ? styles.statusResolved : styles.statusOpen
                        ]}>
                            <Text style={{ fontSize: 8 }}>{defect.status}</Text>
                        </View>
                    </View>
                    <View style={styles.fieldRow}>
                        <Text style={styles.fieldLabel}>Measurements</Text>
                        <Text style={styles.fieldValue}>
                            {(defect as any).locationOn3dModel?.measurement || 'N/A'}
                        </Text>
                    </View>
                    <View style={styles.fieldRow}>
                        <Text style={styles.fieldLabel}>Notes</Text>
                        <Text style={styles.fieldValue}>{defect.notes || 'No notes provided.'}</Text>
                    </View>
                </View>
                <View style={styles.imageColumn}>
                    <Text style={{ color: '#cbd5e1', fontSize: 10 }}>[ Site Photo Placeholder ]</Text>
                </View>
            </View>
          </View>
        ))}
      </Page>
    </Document>
  );
};
</file>

<file path="src/features/inspection/components/permission-toggle.tsx">
'use client';
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { LucideBan, LucideCheck } from "lucide-react";
import { useActionState } from "react";
import { togglePermission } from "../actions/toggle-permission";


type PermissionToggleProps = {
    userId: string,
    organizationId: string,
    permissionKey:'canDeleteDefect',
    permissionValue:boolean
}
export const PermissionToggle = ({
    userId,
    organizationId,
    permissionKey,
    permissionValue
}: PermissionToggleProps) => {
    const [actionState, action] = useActionState(
        togglePermission.bind(null, {
            userId,
            organizationId,
            permissionKey
        }),
        EMPTY_ACTION_STATE
    )
    return ( 
        <Form actionState={actionState} action={action}>
            <SubmitButton 
                icon={permissionValue ? <LucideCheck /> : <LucideBan />}
                size="icon"
                variant={permissionValue ? 'secondary': 'outline'}
                disabled
            />
        </Form>
     );
}
</file>

<file path="src/features/inspection/events/event-inspection-created.ts">
import { inngest } from "@/lib/inngest";
import { prisma } from "@/lib/prisma";
import { NonRetriableError } from "inngest";


export type InspectionStartedEventArgs = {
  data: {
    inspectionId: string;
  };
};

export const inspectionStartedEvent = inngest.createFunction(
  { id: "inspection-started" },
  { event: "app/inspection.started" },
  async ({ event , step }) =>  {
    const {
      inspectionId
    } = event.data;

    // Call FastAPI /process-job endpoint
    await step.run("call-fastapi", async () => {
      //console.log("Secret Length:", (process.env.INTERNAL_SERVICE_SECRET || "").length);
      const response = await fetch(`${process.env.FASTAPI_URL}/ingest`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Internal-Secret": process.env.INTERNAL_SERVICE_SECRET || "",
        },
        body: JSON.stringify({
          inspectionId,
        }),
      });

      if (!response.ok) {
        throw new Error(`FastAPI processing failed: ${response.statusText}`);
      }

      return await response.json();
    });

    return { ok: true, inspectionId };
  }
);
</file>

<file path="src/features/invitation/components/invitation-accept-form.tsx">
"use client";

import { useActionState } from "react";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { acceptInvitation } from "../actions/accept-invitation";

type InvitationAcceptFormProps = {
  tokenId: string;
};

const InvitationAcceptForm = ({ tokenId }: InvitationAcceptFormProps) => {
  const [actionState, action] = useActionState(
    acceptInvitation.bind(null, tokenId),
    EMPTY_ACTION_STATE
  );

  return (
    <Form action={action} actionState={actionState}>
      <SubmitButton label="Accept" disabled/>
    </Form>
  );
};

export { InvitationAcceptForm };
</file>

<file path="src/features/invitation/components/invitation-create-button.tsx">
"use client";

import { LucidePlus } from "lucide-react";
import { useState } from "react";
import { useActionState } from "react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { createInvitation } from "../actions/create-invitation";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { FieldErrorMsg } from "@/components/forms/field-error";

type InvitationCreateButtonProps = {
  organizationId: string;
};

const InvitationCreateButton = ({
  organizationId,
}: InvitationCreateButtonProps) => {
  const [open, setOpen] = useState(false);

  const [actionState, action] = useActionState(
    createInvitation.bind(null, organizationId),
    EMPTY_ACTION_STATE
  );

  const handleClose = () => {
    setOpen(false);
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button>
          <LucidePlus className="w-4 h-4" />
          Invite Member
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Invite Member</DialogTitle>
          <DialogDescription>
            Invite a user by email to your organization
          </DialogDescription>
        </DialogHeader>
        <Form action={action} actionState={actionState} onSuccess={handleClose}>
          <div className="grid gap-4 py-4">
            <div>
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="email" className="text-right">
                  Email
                </Label>
                <Input name="email" id="email" className="col-span-3" />
              </div>
              <div className="grid grid-cols-4 items-center gap-4">
                <div />
                <div className="col-span-3">
                  <FieldErrorMsg actionState={actionState} name="email" />
                </div>
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button type="button" variant="outline" onClick={handleClose}>
              Cancel
            </Button>
            <SubmitButton label="Invite" disabled />
          </DialogFooter>
        </Form>
      </DialogContent>
    </Dialog>
  );
};

export { InvitationCreateButton };
</file>

<file path="src/features/membership/actions/delete-membership.ts">
'use server';

import { toActionState } from "@/components/forms/utils/to-action-state";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { prisma } from "@/lib/prisma";
import { getMemberships } from "../queries/get-memberships";

type deleteMembershipProps = {
    organizationId:string; 
    userId:string;
}
export const deleteMembership = async({
    organizationId, 
    userId}:deleteMembershipProps) => {
    
    const {user}=await getAuthOrRedirect();
    
    const memberships = await getMemberships(organizationId);

    if (!Array.isArray(memberships)) {
        return memberships; // already an ActionState
        }

    
    const isLastMembership = (memberships ?? []).length <= 1 ;

    if(isLastMembership){
        return toActionState(
            'Error', 
            "You can't delete the last membership of an organization");
    }

    const targetMembership = (memberships ?? []).find(
            (m)=>m.userId===userId)

    if(!targetMembership){
        return toActionState('Error', 'Membership not found');
    }

    const adminMembership = (memberships ?? []).filter(
        (m)=>m.membershipRole==='ADMIN');
    
    const removesAdmin = targetMembership.membershipRole === 'ADMIN';
    
    const isLastAdmin = adminMembership.length <= 1 ;

    if(removesAdmin && isLastAdmin){
        return toActionState(
            "Error",
            "You can not delete the last admin of an aorganization"
        );
    }

    const myMembership = (memberships ?? []).find(
        (m)=>m.userId===user.id
    );

    const isMyself = user.id === userId;
    const isAdmin = myMembership?.membershipRole === 'ADMIN';

    if( !isMyself && !isAdmin ){
        return toActionState('Error', 'Only Admins can delete memberships');
    }


    await prisma.membership.delete({
        where:{
            MembershipId:{
                userId,
                organizationId,
            },
        },
    });

    return toActionState('Success', 
        isMyself ? 
        'You have left the organization':
        'Membership has been deleted!');
}
</file>

<file path="src/features/membership/actions/update-membership-role.ts">
"use server";

import { MembershipRole } from "@prisma/client";
import { getAdminOrRedirect } from "../queries/get-admin-or-redirect";

import { getMemberships } from "../queries/get-memberships";
import { toActionState } from "@/components/forms/utils/to-action-state";
import { prisma } from "@/lib/prisma";
import { revalidatePath } from "next/cache";
import { membershipsPath } from "@/path";

type UpdateMembershipRoleP= {
    organizationId: string,
    userId: string,
    membershipRole: MembershipRole
};

export const updateMembershipRole =async  ({
    organizationId,
    userId,
    membershipRole}: UpdateMembershipRoleP) => {
        await getAdminOrRedirect(organizationId);
        
        const memberships = await getMemberships(organizationId);
        if (!Array.isArray(memberships)) {
            return memberships; // already an ActionState
        }

        const targetMembership = (memberships ?? []).find(
            (membership)=>membership.userId === userId
        );

        if(!targetMembership){
            return toActionState('Error', 'Membership not found');
        }

        const adminMemberships = (memberships ?? []).filter(
            (m)=>m.membershipRole === 'ADMIN'
        );

        const removesAdmin = targetMembership.membershipRole === "ADMIN";
        const isLastAdmin = adminMemberships.length <= 1;

        if(removesAdmin && isLastAdmin){
            return toActionState('Error', 
                'Can not change the last admin');
        }

        await prisma.membership.update({
            where:{
                MembershipId:{
                    organizationId,
                    userId,
                },
            },
            data:{
                membershipRole
            },
        });

        revalidatePath(membershipsPath(organizationId));

        return toActionState('Success', 'Membership role Updated');


}
</file>

<file path="src/features/membership/queries/get-memberships.ts">
'use server';
import { toActionState } from "@/components/forms/utils/to-action-state";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect"
import { prisma } from "@/lib/prisma";

export const getMemberships = async (organizationId: string) => {
    const {user, activeOrganization}= await getAuthOrRedirect();

    if (!user || !activeOrganization) {
        return toActionState('Error', 'Not Authenticated');
        }
    
    return await prisma.membership.findMany({
        where:{
            organizationId,
        },
        include:{
            user:{
                select:{
                    username:true,
                    email:true,
                    emailVerified:true
                }
            },
        },
    });
}
</file>

<file path="src/features/organization/actions/create-organization.ts">
'use server';
import { setCookieByKey } from "@/actions/cookies";
import { ActionState, formErrorToActionState } from "@/components/forms/utils/to-action-state";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { inngest } from "@/lib/inngest";
import { prisma } from "@/lib/prisma";
import { membershipsPath, projectsPath } from "@/path";
import { redirect } from "next/navigation";
import z from "zod";


const createOrganizationSchema = z.object({
    name: z.string().min(1).max(191),
});

export const createOrganization = async (
    _actionState: ActionState, formData:FormData
) => {
    
    const {user}= await getAuthOrRedirect({
        checkOrganization: false,
        checkActiveOrganization: false,});

    let organization;
    try {
        const data= createOrganizationSchema.parse({
            name: formData.get('name'),
        });

        await prisma.membership.updateMany({
            where:{
                userId: user.id,
            },
            data:{
                isActive: false,
            },
        });        
       
        organization= await prisma.organization.create({
            data:{
                ...data,
                memberships:{
                    create:{
                        userId:user.id,
                        isActive: true,
                        membershipRole:'ADMIN',
                    },
                },
            },
        });


        await inngest.send({
            name: "app/organization.created",
            data: {
                organizationId: organization.id,
                byEmail: user.email,
      },
    });
                
    } catch (error) {
     formErrorToActionState(error);
    }

    
    await setCookieByKey(
        "toast",
        JSON.stringify({
        message: "Organization created",
        link: membershipsPath(organization!.id),
        })
    );   
    redirect(projectsPath());

};
</file>

<file path="src/features/organization/components/organization-create-form.tsx">
'use client';

import { FieldErrorMsg } from "@/components/forms/field-error";
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Input } from "@/components/ui/input";
import { useActionState } from "react";
import { createOrganization } from "../actions/create-organization";

export const OrganizationCreateForm = () => {
    const [actionState, action] = useActionState(createOrganization,
        EMPTY_ACTION_STATE
    )
    return ( 
        <Form action={action} actionState={actionState} >
            <Input name='name'
                placeholder="Name"
                defaultValue={actionState.payload?.get('name') as string} 
            />
            <FieldErrorMsg name="name" actionState={actionState}  />

            <SubmitButton label="Create" disabled={false} />
        </Form>
     );
}
</file>

<file path="src/features/organization/components/organization-list.tsx">
import { format } from "date-fns";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { getOrganizationsByUserId } from "../queries/get-organizations-by-user";
import { OrganizationSwichButton } from "./organization-switch-button";
import { Button } from "@/components/ui/button";
import { 
    LucideArrowLeftRight, 
    LucideArrowUpRightFromSquare, 
    LucidePen } from "lucide-react";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { OrganizationDeleteButton } from "./organization-delete-button";
import Link from "next/link";
import { membershipsPath } from "@/path";
import { MembershipDeleteButton } from "@/features/membership/components/membership-delete-button";

type OrganizationListProps = {
    limitedAccess?: boolean;
}

export const OrganizationList = async ({limitedAccess}: OrganizationListProps) => {
    
    const organizations = await getOrganizationsByUserId();
    const hasActive= organizations.some((org)=>org.membershipByUser.isActive)
    
    return ( 
        <Table>
            <TableHeader>
                <TableRow>
                    <TableHead>ID</TableHead>
                    <TableHead>Name</TableHead>
                    <TableHead>Joined At</TableHead>
                    <TableHead>Members</TableHead>
                    <TableHead>My Role</TableHead>
                    <TableHead/>
                </TableRow>
            </TableHeader>
            <TableBody>
            {organizations.map((organization)=>{

                const isActive= organization.membershipByUser.isActive;
                const isAdmin = organization.membershipByUser.membershipRole === 'ADMIN';

                const switchButton= (
                    <OrganizationSwichButton organizationId={organization.id} 
                    trigger={
                    <SubmitButton 
                            variant={!hasActive ? "secondary" : isActive ? "default" : "outline"}
                            icon={<LucideArrowLeftRight className="h-4 w-4" />}
                            label={!hasActive ? "Activate" : isActive ? 'Active' : 'Switch'} disabled={false}                    />
                    } 
                    
                    />

                );

                const detailButton= (
                    <Button variant="outline" size="icon" asChild>
                        <Link href={membershipsPath(organization.id)} >
                            <LucideArrowUpRightFromSquare className="h-4 w-4" />                        
                        </Link>
                    </Button>
                );

                const editButton= (
                    <Button variant="outline" size="icon">
                        <LucidePen className="h-4 w-4" />
                    </Button>
                );

                const leaveButton= (
                        <MembershipDeleteButton 
                            organizationId= {organization.id}
                            userId= {organization.membershipByUser.userId}
                        />);

                const deleteButton= (
                    <OrganizationDeleteButton 
                        organizationId={organization.id}
                    />
                );

                const placeholder = (
                    <Button size='icon' disabled 
                            className="disabled:opacity-0" 
                    />
                );

                const buttons= (
                    <>
                        {switchButton}
                        {limitedAccess ? null : isAdmin ? detailButton : placeholder}
                        {limitedAccess ? null :  isAdmin ? editButton : placeholder}
                        {limitedAccess ? null : leaveButton}
                        {limitedAccess ? null :  isAdmin ?  deleteButton : placeholder}
                    </>
                );

                return (
                    <TableRow key={organization.id} >
                        <TableCell>{organization.id}</TableCell>
                        <TableCell>{organization.name}</TableCell>
                        <TableCell>
                            {format(organization.membershipByUser.joinedAt,
                                "yyyy-MM-dd"
                            )}</TableCell>
                        <TableCell>{organization._count.memberships}</TableCell>
                        <TableCell>{organization.membershipByUser.membershipRole}</TableCell>
                        <TableCell className="flex justify-end gap-x-2" >
                            {buttons}
                        </TableCell>
                    </TableRow>
                );

            })
            }
            </TableBody>

        </Table>
     );
};
</file>

<file path="src/features/password/components/password-change-form.tsx">
'use client';
import { FieldErrorMsg } from "@/components/forms/field-error";
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Input } from "@/components/ui/input";

import { useActionState } from "react";
import { passwordChange } from "../actions/password-change";
import { Label } from "@/components/ui/label";


export const PasswordChangeForm = () => {
    const [actionState, action]= useActionState(passwordChange, EMPTY_ACTION_STATE)
    return ( 
        <Form action={action} actionState={actionState}>
            <div className="space-y-6" >
                <div className="space-y-2">
                    <Label htmlFor="current_password">Current Password</Label>
                    <Input name="password" placeholder="Password" type="password"  
                            defaultValue={ actionState.payload?.get('password') as string } />
                    <FieldErrorMsg name="password" actionState={actionState} />
                </div>
                <div className="flex justify-center pt-2">
                    <SubmitButton label="Send Email" disabled={false} />
                </div>
            </div>
        </Form>
     );
}
</file>

<file path="src/features/password/components/password-forgot-form.tsx">
'use client';
import { FieldErrorMsg } from "@/components/forms/field-error";
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Input } from "@/components/ui/input";

import { useActionState } from "react";
import { passwordForgot } from "../actions/password-forgot";

export const PasswordForgotForm = () => {
    const [actionState, action]= useActionState(passwordForgot, EMPTY_ACTION_STATE)
    return ( 
        <Form action={action} actionState={actionState} >

            <Input name="email" placeholder="Email"  
                defaultValue={ actionState.payload?.get('email') as string } />
            <FieldErrorMsg name="email" actionState={actionState} />

            <SubmitButton label="Send Email"  disabled={false}/>
        </Form>
     );
}
</file>

<file path="src/features/password/components/password-reset-form.tsx">
'use client';
import { FieldErrorMsg } from "@/components/forms/field-error";
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Input } from "@/components/ui/input";

import { useActionState } from "react";
import { passwordReset } from "../actions/password-reset";

type PasswordResetFormsProps = {
    tokenId: string
}

export const PasswordResetForm = ( {tokenId}: PasswordResetFormsProps ) => {
    const [actionState, action]= useActionState(
        passwordReset.bind(null, tokenId), 
        EMPTY_ACTION_STATE)
    return ( 
        <Form action={action} actionState={actionState} >

            <Input name="password" type="password" placeholder="Password"  
                defaultValue={ actionState.payload?.get('password') as string } />
            <FieldErrorMsg name="password" actionState={actionState} />

            <Input name="confirmPassword" type="password" placeholder="Confirm Password"  
                defaultValue={ actionState.payload?.get('confirmPassword') as string } />
            <FieldErrorMsg name="confirmPassword" actionState={actionState} />

            <SubmitButton label="Reset Password"   disabled={false}/>
        </Form>
     );
}
</file>

<file path="src/features/project/actions/delete-project.ts">
"use server";
import { setCookieByKey } from "@/actions/cookies";
import { formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { IsOwner } from "@/features/auth/utils/is-owner";
import { prisma } from "@/lib/prisma";
import { projectsPath } from "@/path";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { getProjectPermissions } from "../permissions/get-project-permissions";

const deleteProject = async (projectId: string) => {
    
    const {user, activeOrganization}= await getAuthOrRedirect();
    if (!user || !activeOrganization) {
        return toActionState('Error', 'Not Authenticated');
    }
    

    try {
        const permissions = await getProjectPermissions({
            userId: user.id,
            organizationId: activeOrganization.id
        });

        if(!permissions.canDeleteProject){
            return toActionState('Error', 'Not authorized');
        }

        const project= await prisma.project.findUnique({
            where:{
                id: projectId,
            },
            include:{
                user:true,
            }
        });

        if(!project || !IsOwner(user, project)){
            return toActionState('Error', 'Not authorized');
        }

        await prisma.project.delete({
        where:{
            id: projectId,
        },
    });

    } catch (error) {
        return formErrorToActionState(error)
    }

   
    revalidatePath(projectsPath()); 
    await setCookieByKey('toast', "Project deleted!");
    //console.log(getCookieByKey('toast'));
    redirect(projectsPath());
};

export {deleteProject}
</file>

<file path="src/features/project/actions/update-project-status.ts">
'use server';
import { formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { IsOwner } from "@/features/auth/utils/is-owner";
import { prisma } from "@/lib/prisma";
import { projectsPath } from "@/path";
import { ProjectStatus } from "@prisma/client";
import { revalidatePath } from "next/cache";
import { getProjectPermissions } from "../permissions/get-project-permissions";

export const UpdateProjectStatus = async (id: string, status: ProjectStatus) => {
    const {user, activeOrganization}= await getAuthOrRedirect();
    if (!user || !activeOrganization) {
        return toActionState('Error', 'Not Authenticated');
    }
    
    try {
        const permissions = await getProjectPermissions({
            userId: user.id,
            organizationId: activeOrganization.id
        });
            
        if(!permissions.canEditProject){
            return toActionState('Error', 'Not authorized');
        };
     
        const project= await prisma.project.findUnique({
            where:{
                id,
            },
        });
        if(!project || !IsOwner(user, project)){
            return toActionState('Error', 'Not Authorized');
        }

        await prisma.project.update({
            where: { id,},
            data: {status,},
        });        
    } catch (error) {
        return formErrorToActionState(error);
    };

    revalidatePath(projectsPath());

    return toActionState("Success", "Project status updated!");

};
</file>

<file path="src/features/project/components/project-list.tsx">
import { getProjects } from "../queries/get-projects";
import { ProjectItem } from "./project-item";
import { ParsedSearchParams } from "../search-params";
import { Placeholder } from "@/components/placeholder";
import { ProjectSearchInput } from "./project-search-input";
import { ProjectSortSelect } from "./project-sort-select";
import { ProjectPagination } from "./project-pagination";

type ProjectListProps = {
    userId ?: string;
    byOrganization?: boolean
    searchParams: ParsedSearchParams;
    canEdit: boolean;
    canDelete: boolean;
};

export const ProjectLisT = async ({userId, byOrganization=false,searchParams, canEdit, canDelete}: ProjectListProps) => {
    const {list: projects, metadata: projectMetadata}= await getProjects(
        userId,
        byOrganization,
        searchParams);
    return ( 
        <div className='flex-1 flex flex-col items-center gap-y-4' >
            <div className="w-full max-w-[420px] flex gap-x-2" >
                <ProjectSearchInput placeholder='Search projects' />
                <ProjectSortSelect options={
                        [
                        {sortKey: 'createdAt' , 
                         sortValue:'desc', 
                         label:'Newest',
                        },

                        {sortKey: 'createdAt' , 
                         sortValue:'asc', 
                         label:'Oldest',
                        }
                        ]
                    } />
            </div>
            { projects.length ?(projects.map(
                        (project) => (
                            <ProjectItem key={project.id} project={project} canEdit={canEdit} canDelete={canDelete} />
                        )
                )):(<Placeholder label="No Projects Found" />)    
            }
            <div className="w-full max-w-[420px]" >
                <ProjectPagination paginationProjectMetadata={projectMetadata} />
            </div>
        </div>
     );
}
</file>

<file path="src/features/project/components/project-more-menu.tsx">
"use client";
import {  ProjectStatus } from "@prisma/client";
import {  LucideTrash } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import React from "react";
//import { ProjectStatusLabels } from "@/features/constants";
import { PROJECT_STATUS_CONFIG } from "@/features/constants";
import { UpdateProjectStatus } from "../actions/update-project-status";
import { toast } from "sonner";
import { deleteProject } from "../actions/delete-project";
import { useConfirmDialog } from "@/components/confirm-dialogue";
import { ProjectWithMetadata } from "../types";

type ProjectMoreMenuProps = {
    project: ProjectWithMetadata;
    trigger: React.ReactNode;
}

const ProjectMoreMenu = ({project, trigger}: ProjectMoreMenuProps) => {
    const [deleteButton, deleteDialog] = useConfirmDialog({
        action: deleteProject.bind(null, project.id),
        trigger: (
            <DropdownMenuItem disabled={
                !project.permissions.canDeleteProject
            } >
                <LucideTrash className="h-4 w-4 mr-2" />
                <span>Delete</span>
            </DropdownMenuItem>
            ),
        });
        

    const handleProjectStatus = async (status: string)=>{
        //console.log('Status changed to:', status);
        const promise=  UpdateProjectStatus(project.id, status as ProjectStatus);

        toast.promise(promise, {
            loading:'Updating project status...',
        })

        const result= await promise;

        if(result.status === 'Success'){
            toast.success(result.message);

        } else if(result.status === 'Error'){
            toast.error(result.message);
        }
    }

    const projectStatusRadioGroup = (
        <DropdownMenuRadioGroup value={project.status} 
            onValueChange={handleProjectStatus} >
            {(Object.entries(PROJECT_STATUS_CONFIG) as [ProjectStatus, typeof PROJECT_STATUS_CONFIG[ProjectStatus]][]).map(
                ([key, config]) => {
                    const StatusIcon = config.icon; // Get the icon component
                    
                    return (
                    <DropdownMenuRadioItem 
                        key={key} 
                        value={key}
                        className="cursor-pointer"
                    >
                        <StatusIcon className={`mr-2 h-4 w-4 ${config.color}`} />
                        {config.label}
                    </DropdownMenuRadioItem>
                    );
                }
            )}
        </DropdownMenuRadioGroup>
    )

    return (
    <>
    {deleteDialog} 
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        {trigger}
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56" side="right" align="start" >
        <DropdownMenuLabel>Project Menu</DropdownMenuLabel>
        <DropdownMenuSeparator />
        {  projectStatusRadioGroup}
        <DropdownMenuSeparator />
        {  deleteButton}
      </DropdownMenuContent>
    </DropdownMenu>
    </>

     );
};

export { ProjectMoreMenu };
</file>

<file path="src/features/project/permissions/get-project-permissions.ts">
import { prisma } from "@/lib/prisma";
import { MembershipRole } from "@prisma/client";

type ProjectPermissionProps = {
    userId: string | undefined;
    organizationId: string | undefined;
}
export const getProjectPermissions = async({
    userId,
    organizationId
}: ProjectPermissionProps)  => {
    if(!userId || ! organizationId){
        return {
            canDeleteProject: false,
            canEditProject: false
        };
    }

    const membership = await prisma.membership.findUnique({
        where:{
            MembershipId:{
            organizationId,
            userId,
            }
        },
    });

    if(!membership){
        return {
            canDeleteProject: false,
            canEditProject: false
        };
    };

    if(membership.membershipRole === MembershipRole.ADMIN){
            return {
                canDeleteProject: true,
                canEditProject: true
            };
        };

    return {
        canDeleteProject: membership.canDeleteProject,
        canEditProject: membership.canEditProject
    };
}
</file>

<file path="src/features/supplements/actions/delete-attachment.ts">
"use server";


import { inngest } from "@/lib/inngest";
import { prisma } from "@/lib/prisma";
import * as attachmentData from "../data";
import * as attachmentSubjectDTO from "../dto/attachment-subject-dto";
import { formErrorToActionState, toActionState } from "@/components/forms/utils/to-action-state";
import { IsOwner } from "@/features/auth/utils/is-owner";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";

export const deleteAttachment = async (id: string) => {
  const { user } = await getAuthOrRedirect();

  const attachment = await attachmentData.getAttachment(id);

  let subject;
  switch (attachment?.entity) {
    case "INSPECTION":
      subject = attachmentSubjectDTO.fromInspection(attachment.inspection);
      break;
    case "ANALYSIS":
      subject = attachmentSubjectDTO.fromAnalysis(attachment.analysis);
      break;
    case "COMMENT":
      subject = attachmentSubjectDTO.fromComment(attachment.comment);
      break;
  }

  if (!subject || !attachment) {
    return toActionState("Error", "Subject not found");
  }

  if (!IsOwner(user, subject)) {
    return toActionState("Error", "Not authorized");
  }

  try {
    if (!subject.organizationId) {
    throw new Error("Organization ID is required to delete attachment");
    }
    await prisma.supplement.delete({
      where: {
        id,
      },
    });

    await inngest.send({
      name: "app/supplement.deleted",
      data: {
        organizationId: subject.organizationId,
        projectId: subject.projectId,
        entityId: subject.entityId,
        entity: attachment.entity,
        fileName: attachment.name,
        attachmentId: attachment.id,
      },
   });
  } catch (error) {
    return formErrorToActionState(error);
  }

  return toActionState("Success", "Attachment deleted");
};
</file>

<file path="src/features/supplements/components/attachment-create-button.tsx">
"use client";

import { SupplementEntity } from "@prisma/client";
import { PaperclipIcon } from "lucide-react";
import { useState } from "react";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { AttachmentCreateForm } from "./attachment-create-form";
import { SubmitButton } from "@/components/forms/submit-buttton";

type AttachmentCreateButtonProps = {
  entityId: string;
  entity: SupplementEntity;
  onCreateAttachment?: () => void;
};

const AttachmentCreateButton = ({
  entityId,
  entity,
  onCreateAttachment,
}: AttachmentCreateButtonProps) => {
  const [open, setOpen] = useState(false);

  const handleSuccess = () => {
    onCreateAttachment?.();
    setOpen(false);
  };

  const handleCancel = () => {
    setOpen(false);
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button variant="outline" size="icon">
          <PaperclipIcon className="w-4 h-4" />
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Upload File(s)</DialogTitle>
          <DialogDescription>Attach images or PDFs</DialogDescription>
        </DialogHeader>
        <AttachmentCreateForm
          entityId={entityId}
          entity={entity}
          buttons={
            <DialogFooter>
              <Button type="button" variant="outline" onClick={handleCancel}>
                Cancel
              </Button>
              <SubmitButton label="Upload" disabled={false} />
            </DialogFooter>
          }
          onSuccess={handleSuccess}
        />
      </DialogContent>
    </Dialog>
  );
};

export { AttachmentCreateButton };
</file>

<file path="src/features/supplements/components/attachment-create-form.tsx">
"use client";

import { SupplementEntity } from "@prisma/client";
import { useActionState } from "react";
import { Input } from "@/components/ui/input";
import { createAttachments } from "../actions/create-attachments";
import { ACCEPTED } from "../constants";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { FieldErrorMsg } from "@/components/forms/field-error";


type AttachmentCreateFormProps = {
  entityId: string;
  entity: SupplementEntity;
  buttons?: React.ReactNode;
  onSuccess?: () => void;
};

const AttachmentCreateForm = ({
  entityId,
  entity,
  buttons,
  onSuccess,
}: AttachmentCreateFormProps) => {
  const [actionState, action] = useActionState(
    createAttachments.bind(null, { entityId, entity }),
    EMPTY_ACTION_STATE
  );

  return (
    <Form action={action} 
          actionState={actionState} 
          onSuccess={onSuccess}>
      <Input
        name="files"
        id="files"
        type="file"
        multiple
        accept={ACCEPTED.join(",")}
      />
      <FieldErrorMsg actionState={actionState} name="files" />

      {buttons || <SubmitButton label="Upload" disabled={false} />}
    </Form>
  );
};

export { AttachmentCreateForm };
</file>

<file path="src/features/supplements/constants.ts">
export const ACCEPTED = [
  "image/png",
  "image/jpeg",
  //"image/jpg",
  "application/pdf",
];

export const MAX_SIZE = 1000000;
</file>

<file path="src/features/supplements/dto/attachment-subject-dto.ts">
import { SupplementEntity } from "@prisma/client";
import { AttachmentSubject, isComment, isInspection, isAnalysis, isDetection } from "../types";

export type Type = {
  entityId: string;
  entity: SupplementEntity;
  organizationId: string;
  projectId: string;
  userId: string | null;
  inspectionId: string;
  commentId: string | null;
};

export const fromInspection = (inspection: AttachmentSubject | null) => {
  if (!inspection || !isInspection(inspection)) {
    return null;
  }

  return {
    entity: "INSPECTION" as SupplementEntity,
    entityId: inspection.id,
    projectId: inspection.projectId,
    userId: inspection.conductedByUserId,
    inspectionId: inspection.id,
    organizationId: inspection.project.organizationId,
    commentId: null,
  };
};

export const fromAnalysis = (analysis: AttachmentSubject | null) => {
  if (!analysis || !isAnalysis(analysis)) {
    return null;
  }

  return {
    entity: "ANALYSIS" as SupplementEntity,
    entityId: analysis.id,
    analysisId: analysis.id,
    projectId: analysis.inspection.projectId,
    inspectionId: analysis.inspectionId,
    jobId: analysis.jobId,
    organizationId: analysis.inspection.project.organizationId,
    userId: analysis.inspection.conductedByUserId,
    // conductedByUserId: inspection.conductedByUserId,-()
    // inspectionId: inspection.id,
    commentId: null,
  };
};

export const fromDetection = (detection: AttachmentSubject | null) => {
  if (!detection || !isDetection(detection)) {
    return null;
  }
// Traverse the relationship chain
  const analysis = detection.analysis;
  const inspection = analysis?.inspection;
  const project = inspection?.project;

  if (!analysis || !inspection || !project) return null;

  return {
    entity: "DETECTION" as SupplementEntity,
    entityId: detection.id,
    

    
    projectId: inspection.projectId,
    inspectionId: inspection.id,
    organizationId: project.organizationId,

    userId: inspection.conductedByUserId, 
    
    commentId: null,
  };
};

export const fromComment = (comment: AttachmentSubject | null) => {
  if (!comment || !isComment(comment)) {
    return null;
  }

  return {
    entity: "COMMENT" as SupplementEntity,
    entityId: comment.id,
    projectId: comment.inspection?.projectId ?? "",
    userId: comment.userId,
    inspectionId: comment.inspection?.id ?? "",
    organizationId: comment.inspection?.project.organizationId ?? "",
    commentId: comment.id,
  };
};
</file>

<file path="src/features/supplements/events/event-attachment-deleted.ts">
import { DeleteObjectCommand } from "@aws-sdk/client-s3";
import { SupplementEntity } from "@prisma/client";
import { s3 } from "@/lib/aws";
import { inngest } from "@/lib/inngest";
import { generateS3Key } from "../utils/generate-s3-key";

export type SupplementDeleteEventArgs = {
  data: {
    attachmentId: string;
    organizationId: string;
    entityId: string;
    entity: SupplementEntity;
    fileName: string;
    projectId: string;
  };
};

export const supplementDeletedEvent = inngest.createFunction(
  { id: "supplement-deleted" },
  { event: "app/supplement.deleted" },
  async ({ event }) => {
    const { organizationId, entityId, entity, fileName, attachmentId, projectId } =
      event.data;

    try {
      await s3.send(
        new DeleteObjectCommand({
          Bucket: process.env.AWS_BUCKET_NAME,
          Key: generateS3Key({
            organizationId,
            entityId,
            entity,
            fileName,
            attachmentId,
            projectId
          }),
        })
      );
    } catch (error) {
      console.log(error);
      return { event, body: false };
    }

    return { event, body: true };
  }
);
</file>

<file path="src/lib/prisma.ts">
// lib/prisma.ts
import { PrismaClient } from "@prisma/client";

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma || new PrismaClient();

// export const db = prisma.$extends({
//   query: {
//     organization: {
//       async findMany({ args, query }) {
//         args.where = { deletedAt: null, ...args.where }
//         return query(args)
//       },
//       async findFirst({ args, query }) {
//         args.where = { deletedAt: null, ...args.where }
//         return query(args)
//       },
//       async findUnique({ args, query }) {
//         // findUnique requires exact ID, so we trick it by changing to findFirst
//         // or we handle logic manually. 
//         // Safer approach for findUnique is typically to NOT filter automatically 
//         // to avoid "Record not found" confusion when it actually exists but is deleted.
//         return query(args) 
//       },
//     },
//     project: {
//       async findMany({ args, query }) {
//         args.where = { deletedAt: null, ...args.where }
//         return query(args)
//       },
//       async findFirst({ args, query }) {
//         args.where = { deletedAt: null, ...args.where }
//         return query(args)
//       },
//     },
//     // Add other soft-delete models here if needed
//   },
// })

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;
</file>

<file path="src/utils/find-ids-from-text.ts">
type FeatureKey = "inspections" | "tickets";

export const findIdsFromText = (key: FeatureKey, value: string) => {
  const regexPattern = new RegExp(`/${key}/[a-zA-Z0-9]+`, "g");
  const paths = value.match(regexPattern) || [];
  return paths.map((path) => path.replace(`/${key}/`, ""));
};
</file>

<file path="src/utils/get-active-path.ts">
import {closest} from 'fastest-levenshtein'

// export const getActivePath = (path:string, paths:string[], ignoredPath:string[]) => {
//     const closestPath= closest(path, paths.concat(ignoredPath || []));

//     const index= paths.indexOf(closestPath);
//     console.log("closest path index: ", closestPath, index);
//     return {active: closestPath, activeindex: index};
// };

export const getActivePath = (currentPath: string, navPaths: string[]) => {
    let activePath = '';
    let longestMatch = 0;

    // Find the nav path that is the longest prefix of the current path
    for (const navPath of navPaths) {
        if (currentPath.startsWith('/'+navPath) && navPath.length > longestMatch) {
            longestMatch = navPath.length;
            activePath = navPath;
        }
    }

    const activeIndex = navPaths.indexOf(activePath);

    console.log("Active Path Found:", navPaths);

    return { active: activePath, activeindex: activeIndex };
};
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*
.env
# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

/app/generated/prisma

/stripe-cli
</file>

<file path="prisma/seed.ts">
import { hash } from '@node-rs/argon2';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();


const users = [
  {
    username: "admin",
    email: "admin@admin.com",
    emailVerified: true
  },
  {
    username: "user",
    // use your own email here
    email: "youssef.arhib@gmail.com",
    emailVerified: true
  },
];


const comments = [
  {content: 'First comment from DB'},
  {content: 'Second comment from DB'},
  {content: 'Third comment from DB'},
]

const projects = [
  {
      name: "Facade Inspection - Casablanca Tower",
      address: "Boulevard Zerktouni, Casablanca",
      description: "Initial facade inspection for cracks",
      status: "ACTIVE" as const,
  },

  {
      name: "ORTHOMOSAIC Mapping - Rabat HQ",
      address: "Residence Manzah, Benslimane",
      description: "Initial facade 3D reconstruction",
      status: "ON_HOLD" as const ,
  }
]

const seed = async () => {
    
    await prisma.comment.deleteMany();
    await prisma.user.deleteMany();
    //await prisma.ticket.deleteMany();
    await prisma.organization.deleteMany();
    await prisma.membership.deleteMany();
    await prisma.project.deleteMany();

    const dbOrganization = await prisma.organization.create({
      data:{
        name:'Acme Corp',
        
      }
    })

    const passwordHash = await hash("geheimnis");

    const dbUsers = await prisma.user.createManyAndReturn({
        data: users.map((user) => ({
      ...user,
      passwordHash,
        })),
    });

    await prisma.membership.createMany({
      data:[{
        organizationId: dbOrganization.id,
        userId: dbUsers[0].id,
        isActive: true,
        membershipRole:"ADMIN",
        
      },{
        organizationId: dbOrganization.id,
        userId: dbUsers[1].id,
        isActive: false,
        membershipRole:'MEMBER',
        
      },]
    });


    // const dbTickets= await prisma.ticket.createManyAndReturn({
    //     data: tickets.map((ticket) => ({
    //     ...ticket,
    //     userId: dbUsers[0].id,
    //     organizationId: dbOrganization.id,
    //     })),
    // });

    const dbProjects= await prisma.project.createManyAndReturn({
        data: projects.map((project) => ({
        ...project,
        userId: dbUsers[0].id,
        organizationId: dbOrganization.id,
        })),
    });


    // await prisma.comment.createManyAndReturn({
    //   data: comments.map((comment)=>({
    //     ...comment,
    //     userId:  dbUsers[1].id,
    //     ticketId: dbTickets[0].id,
    //   })),
    // });
}

seed()
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/inspections/create/page.tsx">
import Heading from "@/components/heading";
import { CardElement } from "@/components/card-compact";
import { InspectionUpsertForm } from "@/features/inspection/components/inspection-form-upsert"
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { getProject } from "@/features/project/queries/get-project";
import { notFound } from "next/navigation";
import { ProjectBreadCrumbs } from "../../_navigation/tabs";

type InspectionCreatePageProp = {
    params: Promise<{projectId: string}>;
};

const InspectionCreatePage = async({params}:InspectionCreatePageProp) => {
    await getAuthOrRedirect();
    const {projectId}= await params;

    const projectResult = await getProject(projectId);

    // Handle null or ActionState (error) cases
    if (!projectResult || !('name' in projectResult)) {
        return notFound();
    }

    // Now TypeScript knows projectResult has 'name' property
    const project = projectResult;

    if (!project) return notFound();
    return ( 
        <div className="flex flex-col gap-y-8 max-w-5xl mx-auto w-full">
            <Heading 
                title="New Flight Import" 
                description={`Upload drone imagery for ${project.name} to generate 3D models and detect defects.`}
                tabs={
                    <ProjectBreadCrumbs 
                        projectName={project.name} 
                        inspectionTitle="New Import" 
                    />
                }
            /> 

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                {/* Updated Sidebar Context */}
                <div className="hidden lg:block space-y-4">
                    <div className="p-4 bg-blue-50/50 dark:bg-blue-900/10 border border-blue-100 dark:border-blue-900 rounded-lg">
                        <h4 className="text-sm font-semibold text-blue-900 dark:text-blue-100 mb-2">
                            Before you upload
                        </h4>
                        <ul className="text-xs text-blue-700 dark:text-blue-300 space-y-2 list-disc pl-4">
                            <li>Ensure images were taken with **80% overlap**.</li>
                            <li>Upload only **JPG/JPEG** formats.</li>
                            <li>Remove blurry or overexposed images to improve AI accuracy.</li>
                        </ul>
                    </div>
                </div>

                {/* Main Form Area */}
                <div className="lg:col-span-2">
                    <CardElement
                        title="Flight Data"
                        description="Configure the AI pipeline for this dataset."
                        className="w-full"
                        content={<InspectionUpsertForm projectId={projectId} />}
                    />
                </div>
            </div>
        </div>
     );
}
 
export default InspectionCreatePage;
</file>

<file path="src/app/(saas)/(authenticated)/projects/page.tsx">
import Heading from "@/components/heading";
import { Spinner } from "@/components/spinner";
//import { searchParamsCache } from "@/features/ticket/search-params";
import { searchParamsCache } from "@/features/project/search-params";
import { ProjectLisT } from "@/features/project/components/project-list";
import { SearchParams } from "nuqs/server";
import { Suspense } from "react";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { LucidePlus } from "lucide-react";
import { projectCreatePath } from "@/path";
import { toActionState } from "@/components/forms/utils/to-action-state";
import { getInspectionPermissions } from "@/features/inspection/permissions/get-inspection-permissions";
import { getProjectPermissions } from "@/features/project/permissions/get-project-permissions";

type ProjectsPageProps = {
  searchParams: Promise<SearchParams>;
}

export default async function ProjectsPage({searchParams}: ProjectsPageProps) {
  const resolvedSearchParams = await searchParams;
  const {user , activeOrganization}= await getAuthOrRedirect();
  if (!user || !activeOrganization) {
              return toActionState('Error', 'Not Authenticated');
      }
          
  const permissions = await getProjectPermissions({
                      userId: user.id,
                      organizationId: activeOrganization.id
  });

  //console.log('permissions Projects', permissions)

  // const isAdmin = activeOrganization?.membershipByUser.membershipRole ===  'ADMIN';
  return (
    <div className="flex-1 flex flex-col gap-y-8">
    
    <Heading title='Projects' 
            description='All projects in one place'
            actions= {
              permissions.canEditProject && (<Button asChild>
                  <Link href={projectCreatePath()} >
                      <LucidePlus className="w-4 h-4" />
                      Create Project
                  </Link>
              </Button>)
                }
    />
    
            <Suspense fallback={<Spinner />}>
                {/* @ts-expect-error Async Server Component */}
                <ProjectLisT   byOrganization searchParams={searchParamsCache.parse(resolvedSearchParams)} 
                            canEdit={permissions.canEditProject} canDelete={permissions.canDeleteProject}  
                />
            </Suspense>
    </div>
  );
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

/* Dark mode scrollbar */
::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}

::-webkit-scrollbar-track {
  background: #020617; /* match your bg-slate-950 */
}

::-webkit-scrollbar-thumb {
  background: #334155; /* slate-700 */
  border-radius: 5px;
  border: 2px solid #020617; /* creates padding effect */
}

::-webkit-scrollbar-thumb:hover {
  background: #475569; /* slate-600 */
}

/* Hide scrollbar in Chrome, Safari, and Opera */
.no-scrollbar::-webkit-scrollbar {
  display: none;
}

/* Hide scrollbar in IE, Edge, and Firefox */
.no-scrollbar {
  -ms-overflow-style: none; /* IE and Edge */
  scrollbar-width: none; /* Firefox */
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src/components/3D_Viewer/get-Ray-From-Pixel.ts">
import {
    Cartesian3,
    Matrix3,
    Matrix4,
    Ray,
} from 'cesium';

interface CameraProperties {
    focal: number;
    width: number;
    height: number;
    k1?: number;
    k2?: number;
    translation: [number, number, number];
    rotation: [number, number, number];
    gpsPosition: { lon: number, lat: number, alt: number };
}

interface PixelPoint {
    x: number;
    y: number;
}

export const rodriguesToMatrix = (CesiumJs: any, rotVec: number[]): Matrix3 => {
    const [rx, ry, rz] = rotVec;
    const theta = Math.sqrt(rx * rx + ry * ry + rz * rz);
    
    if (theta < 1e-10) {
        return CesiumJs.Matrix3.IDENTITY.clone();
    }

    const kx = rx / theta;
    const ky = ry / theta;
    const kz = rz / theta;
    
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const v = 1 - c;

    return new CesiumJs.Matrix3(
        c + kx * kx * v,       kx * ky * v - kz * s,  kx * kz * v + ky * s,
        ky * kx * v + kz * s,  c + ky * ky * v,       ky * kz * v - kx * s,
        kz * kx * v - ky * s,  kz * ky * v + kx * s,  c + kz * kz * v
    );
};

export const getCameraPositionECEF = (
    CesiumJs: any,
    translation: [number, number, number],
    localToWorldTransform: Matrix4
): Cartesian3 => {
    const localPos = new CesiumJs.Cartesian3(translation[0], translation[1], translation[2]);
    return CesiumJs.Matrix4.multiplyByPoint(localToWorldTransform, localPos, new CesiumJs.Cartesian3());
};


/**
 * Convert 2D pixel to 3D ray in ECEF coordinates
 * Uses [-X, -Y, -Z] sign combination based on testing
 */
export const getRayFromPixel = (
    CesiumJs: any,
    pixel: PixelPoint,
    cameraProps: CameraProperties,
    cameraPositionECEF: Cartesian3,
    localToECEFTransform: Matrix4
): Ray | null => {
    const { width, height, focal, k1 = 0, rotation } = cameraProps;

    // 1. Normalized camera coordinates
    const cx = width / 2;
    const cy = height / 2;
    const f = focal * Math.max(width, height);
    
    let xn = (pixel.x - cx) / f;
    let yn = (pixel.y - cy) / f;

    // 2. Undistort
    if (Math.abs(k1) > 1e-6) {
        for (let i = 0; i < 10; i++) {
            const r2 = xn * xn + yn * yn;
            const d = 1 + k1 * r2;
            xn = ((pixel.x - cx) / f) / d;
            yn = ((pixel.y - cy) / f) / d;
        }
    }

    // 3. Camera direction (OpenSfM: X-right, Y-down, Z-forward)
    const dirCam = new CesiumJs.Cartesian3(xn, yn, 1);
    CesiumJs.Cartesian3.normalize(dirCam, dirCam);

    // 4. Rotate to world frame
    const R = rodriguesToMatrix(CesiumJs, rotation);
    const Rt = CesiumJs.Matrix3.transpose(R, new CesiumJs.Matrix3());
    const dirLocal = CesiumJs.Matrix3.multiplyByVector(Rt, dirCam, new CesiumJs.Cartesian3());

    // 5. Apply sign correction: [-X, -Y, -Z] (found through testing)
    const dirENU = new CesiumJs.Cartesian3(
        -dirLocal.x,
        -dirLocal.y,
        -dirLocal.z
    );

    // 6. Transform to ECEF
    const enuRot = CesiumJs.Matrix4.getMatrix3(localToECEFTransform, new CesiumJs.Matrix3());
    const dirECEF = CesiumJs.Matrix3.multiplyByVector(enuRot, dirENU, new CesiumJs.Cartesian3());
    CesiumJs.Cartesian3.normalize(dirECEF, dirECEF);

    if (!isFinite(dirECEF.x)) return null;

    return new CesiumJs.Ray(cameraPositionECEF, dirECEF);
};


// get-camera-position.ts
export const getCameraPositionFromReconstruction = (
    CesiumJs: any,
    translation: [number, number, number],
    rotation: [number, number, number],
    localToWorldTransform: any
): any => {
    // OpenSfM convention: 
    // rotation: world-to-camera rotation (Rodrigues)
    // translation: t where P_camera = R * P_world + t
    // So camera center C = -R^T * t
    
    const R = rodriguesToMatrix(CesiumJs, rotation);
    const Rt = CesiumJs.Matrix3.transpose(R, new CesiumJs.Matrix3());
    
    // Camera center in local coordinates
    const t = new CesiumJs.Cartesian3(translation[0], translation[1], translation[2]);
    const negT = CesiumJs.Cartesian3.negate(t, new CesiumJs.Cartesian3());
    const camPosLocal = CesiumJs.Matrix3.multiplyByVector(Rt, negT, new CesiumJs.Cartesian3());
    
    // Transform to ECEF using the same transform as the tileset
    return CesiumJs.Matrix4.multiplyByPoint(
        localToWorldTransform,
        camPosLocal,
        new CesiumJs.Cartesian3()
    );
};

// get-ray-from-pixel-fixed.ts
export const getRayFromPixelFixed = (
    CesiumJs: any,
    pixel: { x: number; y: number },
    cameraProps: {
        width: number;
        height: number;
        focal: number;
        k1?: number;
        k2?: number;
        rotation: [number, number, number];
        translation: [number, number, number];
    },
    localToWorldTransform: any
): { origin: any; direction: any } | null => {
    
    const { width, height, focal, k1 = 0, k2 = 0, rotation, translation } = cameraProps;
    
    // 1. Pixel to normalized camera coordinates
    const cx = width / 2;
    const cy = height / 2;
    const f = focal * Math.max(width, height);
    
    let xn = (pixel.x - cx) / f;
    let yn = (pixel.y - cy) / f;
    
    // 2. Undistort (Brown model - iterative)
    if (Math.abs(k1) > 1e-8 || Math.abs(k2) > 1e-8) {
        const xd = xn, yd = yn;
        for (let i = 0; i < 20; i++) {
            const r2 = xn * xn + yn * yn;
            const r4 = r2 * r2;
            const radialDistortion = 1 + k1 * r2 + k2 * r4;
            xn = xd / radialDistortion;
            yn = yd / radialDistortion;
        }
    }
    
    // 3. Direction in camera frame (OpenSfM: X-right, Y-down, Z-forward)
    const dirCam = new CesiumJs.Cartesian3(xn, yn, 1.0);
    CesiumJs.Cartesian3.normalize(dirCam, dirCam);
    
    // 4. Rotation from world to camera (Rodrigues)
    const R_world_to_cam = rodriguesToMatrix(CesiumJs, rotation);
    
    // 5. Transpose to get camera-to-world rotation
    const R_cam_to_world = CesiumJs.Matrix3.transpose(
        R_world_to_cam, 
        new CesiumJs.Matrix3()
    );
    
    // 6. Transform direction to local world frame
    const dirLocal = CesiumJs.Matrix3.multiplyByVector(
        R_cam_to_world, 
        dirCam, 
        new CesiumJs.Cartesian3()
    );
    
    // 7. OpenSfM uses: X=East, Y=North, Z=Up (ENU)
    // But tileset might be rotated, so apply tileset's ENU frame
    const enuRotation = CesiumJs.Matrix4.getMatrix3(
        localToWorldTransform, 
        new CesiumJs.Matrix3()
    );
    
    const dirECEF = CesiumJs.Matrix3.multiplyByVector(
        enuRotation, 
        dirLocal, 
        new CesiumJs.Cartesian3()
    );
    CesiumJs.Cartesian3.normalize(dirECEF, dirECEF);
    
    // 8. Camera position in ECEF
    // OpenSfM: camera position C = -R^T * t
    const t = new CesiumJs.Cartesian3(translation[0], translation[1], translation[2]);
    const negT = CesiumJs.Cartesian3.negate(t, new CesiumJs.Cartesian3());
    const camPosLocal = CesiumJs.Matrix3.multiplyByVector(
        R_cam_to_world, 
        negT, 
        new CesiumJs.Cartesian3()
    );
    
    const camPosECEF = CesiumJs.Matrix4.multiplyByPoint(
        localToWorldTransform,
        camPosLocal,
        new CesiumJs.Cartesian3()
    );
    
    if (!isFinite(dirECEF.x) || !isFinite(camPosECEF.x)) {
        return null;
    }
    
    return {
        origin: camPosECEF,
        direction: dirECEF
    };
};

// intersection-utils.ts
export const intersectRayWithTileset = async (
    CesiumJs: any,
    scene: any,
    ray: any,
    tileset: any,
    maxDistance: number,
    cameraPos: any
): Promise<{ position: any; hitType: string } | null> => {
    
    // Force scene render first
    scene.render();
    
    const minValidDistance = 2; // Minimum 2 meters from camera

    // METHOD 1: pickFromRay - most accurate for tilesets
    try {
        const result = scene.pickFromRay(ray, [scene.globe], 0.001);
        if (result?.position) {
            const dist = CesiumJs.Cartesian3.distance(cameraPos, result.position);
            if (dist > minValidDistance && dist < maxDistance) {
                const obj = result.object;
                if (obj?.primitive === tileset || obj?.tileset === tileset ||
                    obj?.content?.tileset === tileset) {
                    return { position: result.position, hitType: 'pickFromRay-tileset' };
                }
                return { position: result.position, hitType: 'pickFromRay-other' };
            }
        }
    } catch (e) {
        console.debug("pickFromRay error:", e);
    }

    // METHOD 2: drillPickFromRay - finds all intersections
    try {
        const results = scene.drillPickFromRay(ray, 10, [scene.globe], 0.001);
        if (results?.length > 0) {
            // First try to find tileset hit
            for (const r of results) {
                if (!r.position) continue;
                const dist = CesiumJs.Cartesian3.distance(cameraPos, r.position);
                if (dist < minValidDistance || dist > maxDistance) continue;
                
                const obj = r.object;
                if (obj?.primitive === tileset || obj?.tileset === tileset ||
                    obj?.content?.tileset === tileset) {
                    return { position: r.position, hitType: 'drillPick-tileset' };
                }
            }
            // Then accept any valid hit
            // for (const r of results) {
            //     if (!r.position) continue;
            //     const dist = CesiumJs.Cartesian3.distance(cameraPos, r.position);
            //     if (dist > minValidDistance && dist < maxDistance) {
            //         return { position: r.position, hitType: 'drillPick-other' };
            //     }
            // }
        }
    } catch (e) {
        console.debug("drillPickFromRay error:", e);
    }

    // METHOD 3: Sample along ray for tileset intersection
    if (tileset?.boundingSphere) {
        try {
            const steps = 50;
            const stepSize = maxDistance / steps;
            
            for (let i = 1; i <= steps; i++) {
                const t = i * stepSize;
                const testPoint = CesiumJs.Ray.getPoint(ray, t);
                
                // Check if point is inside tileset bounding sphere
                const distToCenter = CesiumJs.Cartesian3.distance(testPoint, tileset.boundingSphere.center);
                if (distToCenter < tileset.boundingSphere.radius) {
                    // Try picking at this location
                    const testCarto = CesiumJs.Cartographic.fromCartesian(testPoint);
                    const screenPos = CesiumJs.SceneTransforms.worldToWindowCoordinates(scene, testPoint);
                    
                    if (screenPos) {
                        const pick = scene.pick(screenPos);
                        if (pick?.primitive === tileset || pick?.tileset === tileset) {
                            const pos = scene.pickPosition(screenPos);
                            if (pos) {
                                const dist = CesiumJs.Cartesian3.distance(cameraPos, pos);
                                if (dist > minValidDistance) {
                                    return { position: pos, hitType: 'rayMarch-tileset' };
                                }
                            }
                        }
                    }
                }
            }            
        } catch (e) {
            console.debug("Method 3 error:", e);
        }
    }

    // METHOD 4: Bounding sphere intersection (fallback)
    if (tileset?.boundingSphere) {
        const sphere = tileset.boundingSphere;
        const intersection = CesiumJs.IntersectionTests.raySphere(ray, sphere);
        
        if (intersection) {
            const distToCenter = CesiumJs.Cartesian3.distance(cameraPos, sphere.center);
            const isInside = distToCenter < sphere.radius;
            
            // Pick the right intersection point
            let t = isInside ? intersection.stop : intersection.start;
            if (t <= 0) t = intersection.stop;
            if (t > 0 && t < maxDistance) {
                const point = CesiumJs.Ray.getPoint(ray, t);
                const dist = CesiumJs.Cartesian3.distance(cameraPos, point);
                if (dist > minValidDistance) {
                    return { position: point, hitType: 'boundingSphere' };
                }
            }
            
            // Use distance to center as fallback
            if (distToCenter > minValidDistance && distToCenter < maxDistance) {
                const point = CesiumJs.Ray.getPoint(ray, distToCenter);
                return { position: point, hitType: 'boundingSphere-center' };
            }
        }
    }

    return null;
};

// Add this function to project a point DOWN onto the tileset surface
export const snapPointToTileset = async (
    CesiumJs: any,
    scene: any,
    point: any,
    tileset: any,
    maxHeight: number = 100
): Promise<{ position: any; success: boolean }> => {
    // Create a vertical ray from above the point, pointing down
    const cartographic = CesiumJs.Cartographic.fromCartesian(point);
    const abovePoint = CesiumJs.Cartesian3.fromRadians(
        cartographic.longitude,
        cartographic.latitude,
        cartographic.height + maxHeight
    );
    
    const down = CesiumJs.Cartesian3.normalize(
        CesiumJs.Cartesian3.negate(
            CesiumJs.Cartesian3.normalize(abovePoint, new CesiumJs.Cartesian3()),
            new CesiumJs.Cartesian3()
        ),
        new CesiumJs.Cartesian3()
    );
    
    // Actually, use ENU "down" direction
    const enu = CesiumJs.Transforms.eastNorthUpToFixedFrame(point);
    const enuRot = CesiumJs.Matrix4.getMatrix3(enu, new CesiumJs.Matrix3());
    const downENU = new CesiumJs.Cartesian3(0, 0, -1); // Down in ENU
    const downECEF = CesiumJs.Matrix3.multiplyByVector(enuRot, downENU, new CesiumJs.Cartesian3());
    
    // Shoot ray down from above the point
    const rayOrigin = CesiumJs.Cartesian3.add(
        point,
        CesiumJs.Cartesian3.multiplyByScalar(
            CesiumJs.Cartesian3.negate(downECEF, new CesiumJs.Cartesian3()),
            maxHeight,
            new CesiumJs.Cartesian3()
        ),
        new CesiumJs.Cartesian3()
    );
    
    const ray = new CesiumJs.Ray(rayOrigin, downECEF);
    
    try {
        const result = scene.pickFromRay(ray);
        if (result?.position) {
            return { position: result.position, success: true };
        }
    } catch (e) { /* Continue */ }
    
    try {
        const results = scene.drillPickFromRay(ray, 10);
        if (results?.length > 0) {
            for (const r of results) {
                if (r.position) {
                    return { position: r.position, success: true };
                }
            }
        }
    } catch (e) { /* Continue */ }
    
    return { position: point, success: false };
};
</file>

<file path="src/components/3D_Viewer/hooks/use-drawing-manager.ts">
import React from 'react';
import { useRef, useState, useCallback } from 'react';
import { 
    Entity, 
    Viewer, 
    ScreenSpaceEventHandler, 
    ScreenSpaceEventType, 
    CallbackProperty, 
    PolygonHierarchy, 
    Cartesian3,
    PolylineGlowMaterialProperty,
    Color,
    ColorMaterialProperty,
    HeightReference,
    Cartesian2,
    LabelStyle,
    ConstantProperty,
    Cesium3DTileFeature
    // PolygonPipeline (use via CesiumJs.PolygonPipeline)
} from 'cesium';
import { CesiumType } from '../types/cesium';

export type DrawingMode = 'none' | 'point' | 'polyline' | 'polygon';

export interface DefectCandidate {
    positions: Cartesian3[];
    type: 'polyline' | 'polygon' | 'point';
    measurement: string;
    labelPosition?: Cartesian3;
    // Add these optional fields for 2D support
    annotation2D?: {x:number, y:number}[];
    sourceImageId?: string | null;
    locationOn3dModel?: any;
    status?: string;
    severity?: string;
}

interface UseDrawingManagerProps {
    CesiumJs: CesiumType;
    //viewer: Viewer | null;
    viewerRef:  React.RefObject<Viewer | null>; 
    onShapeCreated: (candidate: DefectCandidate, entities: Entity[]) => void;
}

export const useDrawingManager = ({ CesiumJs, viewerRef, onShapeCreated }: UseDrawingManagerProps) => {
    const [drawingMode, setDrawingMode] = useState<DrawingMode>('none');
    
    const activeShapeRef = useRef<Entity | null>(null);
    const activePointsRef = useRef<Entity[]>([]);
    const drawingHandlerRef = useRef<ScreenSpaceEventHandler | null>(null);
    const floatingPointRef = useRef<Cartesian3 | null>(null); 
    const activeLabelRef = useRef<Entity | null>(null);

    // --- Math Helpers ---
    const calculatePolylineDistance = React.useCallback((positions: any[]): number => {
        let totalDistance = 0;
        for (let i = 0; i < positions.length - 1; i++) {
            totalDistance += CesiumJs.Cartesian3.distance(positions[i], positions[i + 1]);
        }
        return totalDistance;
    }, [CesiumJs]);

    const calculatePolygonArea =  React.useCallback((positions: any[]): number => {
        if (positions.length < 3) return 0;
        
    // Reference point (first vertex)
        const origin = CesiumJs.Cartographic.fromCartesian(positions[0]);
        const ellipsoid = CesiumJs.Ellipsoid.WGS84;
        const originCart = ellipsoid.cartographicToCartesian(origin);

        // Transform to ENU local frame
        const transform = CesiumJs.Transforms.eastNorthUpToFixedFrame(originCart);
        const inverseTransform = CesiumJs.Matrix4.inverse(transform, new CesiumJs.Matrix4());

        // Convert all points to local ENU
        const localPoints = positions.map(pos => {
            return CesiumJs.Matrix4.multiplyByPoint(inverseTransform, pos, new CesiumJs.Cartesian3());
    });

    // Compute 2D polygon area (shoelace formula)
    let area = 0;
    for (let i = 0; i < localPoints.length; i++) {
        const j = (i + 1) % localPoints.length;
        area += localPoints[i].x * localPoints[j].y - localPoints[j].x * localPoints[i].y;
    }

    return Math.abs(area) * 0.5; // m²
    }, [CesiumJs]);

    // Helper function to format distance
    const formatDistance = (meters: number): string => {
        if (meters < 1000) {
            return `${meters.toFixed(2)} m`;
        } else {
            return `${(meters / 1000).toFixed(3)} km`;
        }
    };

    // Helper function to format area
    const formatArea = (squareMeters: number): string => {
        if (squareMeters < 10000) {
            return `${squareMeters.toFixed(2)} m²`;
        } else if (squareMeters < 1000000) {
            return `${(squareMeters / 10000).toFixed(4)} ha`;
        } else {
            return `${(squareMeters / 1000000).toFixed(4)} km²`;
        }
    };


    // --- Interaction Logic ---

    // ROBUST PICKING STRATEGY
    const getPositionFromTileset = useCallback((position: Cartesian2) => {
        const viewer = viewerRef.current;
        if (!viewer) return null;
        const scene = viewer.scene;

        // First, ensure we really clicked a 3D tile / model
        const picked = scene.pick(position);
        if (
        !CesiumJs.defined(picked) ||
        !(
            picked instanceof CesiumJs.Cesium3DTileFeature ||
            picked.primitive instanceof CesiumJs.Cesium3DTileset
        )
        ) {
        // Click is not on the tileset – ignore
        return null;
        }


    // Method 1: Depth Buffer Pick (Best for 3D Tiles)
    const cartesian = scene.pickPosition(position);

    // Method 2: Ray Intersection (Fallback if Depth Pick fails)
    if (!CesiumJs.defined(cartesian)) {
         return null;
    }

    if (CesiumJs.defined(cartesian)) {
        // Apply offset ONLY if we are picking the base model
        // If we picked an existing drawing entity, we snap to it (no extra offset)
       // if (!isDrawingEntity) {
            const cartographic = CesiumJs.Cartographic.fromCartesian(cartesian);
            
            if (cartographic) {
                cartographic.height += 0.02; // 20cm offset to prevent Z-fighting with surface
                
                return CesiumJs.Cartesian3.fromRadians(
                    cartographic.longitude, 
                    cartographic.latitude, 
                    cartographic.height
                );
            }
        //} else {
            // We hit an entity, use the position as-is (effectively snapping to top of entity)
            //return cartesian; 
      //  }
   }
    return null;
}, [viewerRef, CesiumJs]);



    const clearActiveDrawing = useCallback(() => {

        const viewer = viewerRef.current;
        if (!viewer) return;
        console.log("viewer.entities.count:", viewer.entities.values.length);
        

        // 1. Remove active preview shape (dynamic polyline/polygon)
        if (activeShapeRef.current) {
            viewer.entities.remove(activeShapeRef.current);
            activeShapeRef.current = null;
        }

        // 2. Remove dynamic live-updating label
        if (activeLabelRef.current) {
            viewer.entities.remove(activeLabelRef.current);
            activeLabelRef.current = null;
        }

        // 3. Remove all small point markers
        if (activePointsRef.current.length > 0) {
            activePointsRef.current.forEach(p => viewer.entities.remove(p));
            activePointsRef.current = [];
        }

        // 4. Remove ANY leftover static label created by right-click
        //    (labels created in `startDrawing` → right-click freeze)
        viewer.entities.values.forEach(entity => {
            if (entity.properties?.isTempShape?.getValue()) {
                viewer.entities.remove(entity);
            }
        });


        // 5. Clear floating point used for dynamic update
        floatingPointRef.current = null;

        // 6. Destroy drawing handler (VERY important)
        if (drawingHandlerRef.current) {
            drawingHandlerRef.current.destroy();
            drawingHandlerRef.current = null;
        }

        // 7. Reset drawing mode
        setDrawingMode('none');

}, [viewerRef]);


    const stopDrawing = useCallback(() => {
        if (drawingHandlerRef.current) {
            drawingHandlerRef.current.destroy();
            drawingHandlerRef.current = null;
        }
        clearActiveDrawing();
        setDrawingMode('none');
    }, [clearActiveDrawing]);

    const createPoint = useCallback((position: Cartesian3) => {
        const viewer = viewerRef.current;
        if (!viewer) return;
        const point = viewer.entities.add({
            position: position,
            point: {
                pixelSize: 8,
                color: CesiumJs.Color.WHITE,
                outlineColor: CesiumJs.Color.BLACK,
                outlineWidth: 2,
                disableDepthTestDistance: Number.POSITIVE_INFINITY, // Always visible on top
            }
        });
        activePointsRef.current.push(point);
    }, [CesiumJs, viewerRef]);

    const startDrawing = useCallback((mode: DrawingMode) => {
        const viewer = viewerRef.current;
        if (!viewer) return;
        stopDrawing();
        setDrawingMode(mode);

        const handler = new CesiumJs.ScreenSpaceEventHandler(viewer.scene.canvas);
        drawingHandlerRef.current = handler;
        
        const positions: Cartesian3[] = [];

        // -- DYNAMIC GEOMETRY UPDATER --
        const dynamicPositions = new CesiumJs.CallbackProperty(() => {
            if (mode === 'polygon') {
                // If moving mouse, close the loop visually
                if (floatingPointRef.current) {
                    return new CesiumJs.PolygonHierarchy([...positions, floatingPointRef.current]);
                }
                return new CesiumJs.PolygonHierarchy(positions);
            }
            // Polyline
            if (floatingPointRef.current) {
                return [...positions, floatingPointRef.current];
            }
            return positions;
        }, false);

        // 1.  Add Vertex
        handler.setInputAction((click: any) => {
            const cartesian = getPositionFromTileset(click.position);
            if (!cartesian) return;

            // Check if this is the very first point
            if (positions.length === 0) {
                // Start tracking mouse movement
                floatingPointRef.current = cartesian.clone();
                
                // Create the Dynamic Shape Entity
                if (mode === 'polyline') {
                    activeShapeRef.current = viewer.entities.add({
                        polyline: {
                            positions: dynamicPositions,
                            width: 5,
                            material: new PolylineGlowMaterialProperty({
                                glowPower: 0.2,
                                color: CesiumJs.Color.BLUE,
                            }),
                            clampToGround: false,
                            arcType: CesiumJs.ArcType.NONE, 
                        }
                    });
                } else if (mode === 'polygon') {
                    activeShapeRef.current = viewer.entities.add({
                        polygon: {
                            hierarchy: dynamicPositions as any,
                            material: new ColorMaterialProperty(CesiumJs.Color.RED.withAlpha(0.5)),
                            perPositionHeight: true, // Vital for 3D Tiles
                            outline: true,
                            outlineColor: CesiumJs.Color.BLACK,
                        }
                    });
                }

                // Create a Dynamic Label
                activeLabelRef.current = viewer.entities.add({
                    position: new CesiumJs.CallbackProperty(() => {
                        return floatingPointRef.current || positions[positions.length - 1];
                    }, false) as unknown as Cartesian3,
                    label: {
                        text: new CesiumJs.CallbackProperty(() => {
                            // CALCULATE METRICS LIVE
                            const currentPos = floatingPointRef.current;
                            if(!currentPos) return "Start";
                            
                            const livePositions = [...positions, currentPos];
                            
                            if (mode === 'polyline') {
                                const d = calculatePolylineDistance(livePositions);
                                return `Length: ${formatDistance(d)}`;
                            }
                            if (mode === 'polygon' && livePositions.length > 2) {
                                const a = calculatePolygonArea([...livePositions, positions[0]]); // Close loop
                                return `Area: ${formatArea(a)}`;
                            }
                            return "Draw...";
                        }, false) as unknown as string,
                        font: '14px sans-serif',
                        fillColor: CesiumJs.Color.WHITE,
                        showBackground: true,
                        backgroundColor: CesiumJs.Color.BLACK.withAlpha(0.7),
                        disableDepthTestDistance: Number.POSITIVE_INFINITY,
                        pixelOffset: new Cartesian2(10, -10)
                    }
                });
            }

            positions.push(cartesian);
            createPoint(cartesian);

        }, CesiumJs.ScreenSpaceEventType.LEFT_CLICK);

        //  MOUSE MOVE: Update Floating Point

        handler.setInputAction((movement: any) => {
            const cartesian = getPositionFromTileset(movement.endPosition);
            if (cartesian) {
                floatingPointRef.current = cartesian;
            }
        }, CesiumJs.ScreenSpaceEventType.MOUSE_MOVE);

        //  RIGHT CLICK: Finish & Commit
        handler.setInputAction(() => {
            // Need at least 2 points for line, 3 for polygon
            const minPoints = mode === 'polygon' ? 3 : 2;
            if (positions.length < minPoints) {
                // Cancel if not enough points
                stopDrawing();
                return;
            }

            const finalShape = activeShapeRef.current;
            if(!finalShape) return;

            // 1. Freeze Geometry (remove CallbackProperty)
            if (mode === 'polyline') {
                (finalShape.polyline as any).positions = [...positions];
                (finalShape.polyline as any).arcType = CesiumJs.ArcType.NONE;
            } else if (mode === 'polygon') {
                (finalShape.polygon as any).hierarchy = new PolygonHierarchy([...positions]);
                (finalShape.polygon as any).perPositionHeight = true;
            }

            (finalShape as any).properties = new CesiumJs.PropertyBag({
                isTempShape: new CesiumJs.ConstantProperty(true),
            });


            // 2. Freeze Label (remove CallbackProperty)
            let labelText = "";
            if (mode === 'polyline') {
                labelText = `Length: ${formatDistance(calculatePolylineDistance(positions))}`;
            } else {
                labelText = `Area: ${formatArea(calculatePolygonArea(positions))}`;
            }

            // We create a NEW static label at the center/end
            const labelPos = positions[positions.length - 1]; // Or compute centroid
            const finalLabel = viewer.entities.add({
                position: labelPos,
                label: {
                    text: labelText,
                    font: '14px sans-serif',
                    fillColor: CesiumJs.Color.WHITE,
                    showBackground: true,
                    backgroundColor: CesiumJs.Color.BLACK.withAlpha(0.7),
                    disableDepthTestDistance: Number.POSITIVE_INFINITY,
                    pixelOffset: new Cartesian2(0, -20)
                }
                
            });

            (finalLabel as any).properties = new CesiumJs.PropertyBag({
                isTempShape: new CesiumJs.ConstantProperty(true),
            });


            // Clean up dynamic helpers
            if(activeLabelRef.current) viewer.entities.remove(activeLabelRef.current);
            activePointsRef.current.forEach(p => viewer.entities.remove(p)); 
        

            const entities = [finalShape, finalLabel];

            // Hand off to Parent
            onShapeCreated({
                positions: [...positions],
                type: mode as 'polyline' | 'polygon',
                measurement: labelText,
                labelPosition: labelPos
            }, entities);

            // Reset local state
            activeShapeRef.current = null;
            activeLabelRef.current = null;
            activePointsRef.current = [];
            if (drawingHandlerRef.current) {
                drawingHandlerRef.current.destroy();
                drawingHandlerRef.current = null;
            }
            setDrawingMode('none');

        }, CesiumJs.ScreenSpaceEventType.RIGHT_CLICK);

    }, [viewerRef, stopDrawing, CesiumJs.ScreenSpaceEventHandler, CesiumJs.CallbackProperty, CesiumJs.ScreenSpaceEventType.LEFT_CLICK, CesiumJs.ScreenSpaceEventType.MOUSE_MOVE, CesiumJs.ScreenSpaceEventType.RIGHT_CLICK, CesiumJs.PolygonHierarchy, CesiumJs.Color.WHITE, CesiumJs.Color.BLACK, CesiumJs.Color.BLUE, CesiumJs.Color.RED, CesiumJs.ArcType.NONE, CesiumJs.PropertyBag, CesiumJs.ConstantProperty, getPositionFromTileset, createPoint, calculatePolylineDistance, calculatePolygonArea, onShapeCreated]);

    return {
        drawingMode,
        startDrawing,
        stopDrawing,
        clearActiveDrawing
    };
};
</file>

<file path="src/features/auth/utils/is-owner.ts">
import { User } from "@prisma/client";

type Entity={
    creatorId?: string | null; // <-- optional now
    inspectionId?: string | null;   // If inspection has project.ownerId
    conductedByUserId?: string | null; // If inspection has conductedByUserId
}

export const IsOwner = (
    authUser: User | null | undefined,
    entity: Entity | null | undefined ) => {

    if (!authUser || !entity){
        return false;
    }

    if(!entity.creatorId){
        return false;
    }
    if(authUser.id !== entity.creatorId){
        return false;
    } else {
        return true;
    }
}
</file>

<file path="src/features/defects/actions/upsert-detection.ts">
'use server';
import {  setCookieByKey } from '@/actions/cookies';
import {formErrorToActionState, ActionState, toActionState} from '@/components/forms/utils/to-action-state';
import {prisma} from '@/lib/prisma';
import { three_D_viewer_Path, ticketPath, ticketsPath } from '@/path';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import {toCent} from "@/utils/currency"
import {z} from 'zod';
import { getAuthOrRedirect } from '@/features/auth/queries/get-auth-or-rerdirect';
import { IsOwner } from '@/features/auth/utils/is-owner';
import * as attachmentData from "@/features/supplements/data";
import { DetectionType, DetectionSeverity, DetectionStatus } from '@prisma/client';
import { getAnalysis } from '@/features/analysis/actions/get-analysis';
import { getDefectPermissions } from '../permissions/get-defect-permissions';


const LocationCoordinatesSchema = z.object({ x: z.number(), y: z.number(), z: z.number() });
// Define the 2D Point Schema
const Point2DSchema = z.object({ x: z.number(), y: z.number() });
const LocationSchema = z.object({
    type: z.enum(['polyline', 'polygon', 'point']),
    coordinates: z.array(LocationCoordinatesSchema),
    measurement: z.string().optional(),
    labelPosition: LocationCoordinatesSchema.optional(),

    annotation2D: z.array(Point2DSchema).optional(),
    sourceImageId: z.string().optional().nullable(),
});

const UpsertDetectionSchema= z.object({
    Defect_Type: z.enum(DetectionType),
    Defect_Severity: z.enum(DetectionSeverity),
    Defect_Status: z.enum(DetectionStatus),
    Defect_Notes: z.string().max(1024).optional(),
    Defect_Location: z.preprocess(
        (val) => (typeof val === 'string' && val) ? JSON.parse(val) : undefined,
        LocationSchema.optional()
    )
});


const UpsertDetection = async (id: string ,
    projectId: string,
    inspectionId: string,
    filesKeys: string[],
    _actionStat:ActionState,
    formData: FormData) =>{
    const {user, activeOrganization}= await getAuthOrRedirect();

    if(!user || !activeOrganization){
            return toActionState('Error', 'Not Authenticated')
        }

    const analysis= await getAnalysis(inspectionId);
    
    if(!analysis){
        return toActionState('Error', 'Analysis not found or not authorized.');
    };

    try{ 
        const permissions = await getDefectPermissions({
                userId: user.id,
                organizationId: activeOrganization.id
        });
    
        // Check if updating an existing record
        const existingDefect = await prisma.detection.findUnique({ where: { id } });

        if (existingDefect) {
            if (!permissions.canEditDefect) {
                return toActionState('Error', 'You do not have permission to edit defects.');
            }
        } else {
           
            if (!permissions.canEditDefect) {
                return toActionState('Error', 'You do not have permission to create defects.');
            }
        }
        
        const data= UpsertDetectionSchema.parse({
            Defect_Type: formData.get('Defect_Type') ,
            Defect_Severity: formData.get('Defect_Severity') ,
            Defect_Status: formData.get("Defect_Status") ,
            Defect_Notes: formData.get("Defect_Notes") || undefined,
            Defect_Location: formData.get("Defect_Location") || undefined,
        });

        let locationOn3dModel = undefined;
        let annotation2D = undefined;
        let sourceImageId = undefined;

        if (data.Defect_Location) {
            // Extract 3D parts
            locationOn3dModel = {
                type: data.Defect_Location.type,
                coordinates: data.Defect_Location.coordinates,
                measurement: data.Defect_Location.measurement,
                labelPosition: data.Defect_Location.labelPosition
            };

            // Extract 2D parts
            annotation2D = data.Defect_Location.annotation2D;
            sourceImageId = data.Defect_Location.sourceImageId;
        }

        const dbdata= {
            id: id,
            type: data.Defect_Type,
            severity: data.Defect_Severity,
            status: data.Defect_Status,
            notes: data.Defect_Notes,
            
            locationOn3dModel: locationOn3dModel, // Save cleaned 3D JSON
            annotation2D: annotation2D ?? undefined,       
            sourceImageId: sourceImageId ?? undefined       
        };

        await prisma.detection.upsert({
            where:{
                id: id 
            },
            update: dbdata,
            create: {...dbdata, analysisId: analysis.id,},
        });

        if (filesKeys && filesKeys.length > 0) {
            for (const key of filesKeys) {
                const name = key.split("/").pop() ?? "attachment";
                
                console.log("--- Attempting to create attachment ---");
                console.log("Key:", key);
                console.log("Linking to Defect ID:", id);

                try {
                    // Log the result of the creation
                    const newRecord = await attachmentData.createAttachment({
                        name: name,
                        entity: "DETECTION",
                        entityId: id,
                        url: key
                    });
                    
                    console.log("✅ DB Record Created:", newRecord);
                    
                    if (!newRecord.detectionId) {
                        console.error("⚠️ WARNING: Record created but detectionId is NULL. Check create-attachment.ts mapping.");
                    }
                } catch (dbError) {
                    console.error("❌ Database Error:", dbError);
                }
            }
        }

    }catch (error){
        return formErrorToActionState(error, formData);
    }


    //revalidatePath(three_D_viewer_Path(projectId, inspectionId));

    if (id){
        await setCookieByKey("toast", "Defect Updated!")
        //redirect(ticketPath(id));
    }
  
    return toActionState('Success',  'Defect Saved')
};

export {UpsertDetection};
</file>

<file path="src/features/defects/components/defect-form-upsert.tsx">
'use client';
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";


import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

import { AlertTriangle, ImageIcon, X, CloudUpload } from 'lucide-react';

import { Detection } from "@prisma/client";

import { SubmitButton } from "@/components/forms/submit-buttton";
import { useActionState, useMemo, useRef, useState, useTransition } from "react";
import { FieldErrorMsg } from "@/components/forms/field-error";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";

import { Form } from "@/components/forms/form";

import { DatePicker, ImperativeHandleFromDatePicker } from "@/components/date-picker";
import { UpsertDetection } from "../actions/upsert-detection";
import { Button } from "@/components/ui/button";
import { deleteDefect } from "../actions/delete-detection";
import { cn } from "@/lib/utils";
import { ACCEPTED } from "@/features/supplements/constants";



type DetectionUpdateFormProps = {
    detection?: Detection;
    projectId: string;
    inspectionId: string;
    geometry?: { type: 'polyline' | 'polygon' | 'point'; coordinates: {x: number, y: number, z: number}[], 
                measurement?: string; labelPosition?: {x: number, y: number, z: number}; 
                annotation2D?: {x: number, y: number}[] | null; sourceImageId?: string | null
            };
    onCancel: () => void;
    onFormSuccess: () => void;
    canDelete: boolean;
    canEdit: boolean;
    onOpenImage: (detection: Detection)=>void;
}

const DetectionUpsertForm = ({detection, projectId, inspectionId, geometry, 
            onCancel, onFormSuccess, canDelete, canEdit, onOpenImage} : DetectionUpdateFormProps) => {
    // 1. Memoize ID: Use existing ID or generate a new UUID for uploads
    const defectId = useMemo(() => detection?.id || crypto.randomUUID(), [detection]);

    const [uploading, setUploading] = useState(false);
    const [s3Keys, setS3Keys] = useState<string[]>([]);

    const [actionState, action]= useActionState(
        UpsertDetection.bind(null, defectId, projectId, inspectionId, s3Keys), EMPTY_ACTION_STATE)

    const [isDeleting, startDeleteTransition] = useTransition();
    
    //const datePickerImperativeHandleRef =useRef<ImperativeHandleFromDatePicker>(null);

    // 3. Handle File Upload (Similar to InspectionUpsertForm)
    async function handleFileUpload(event: React.ChangeEvent<HTMLInputElement>) {
        const files = event.target.files;
        if (!files || files.length === 0) return;

        setUploading(true);
        const uploadedKeys: string[] = [];

        for (const file of Array.from(files)) {
            // Ask backend for a presigned URL
            const presignRes = await fetch("/api/aws/s3/supplements/presign-upload", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ 
                    filename: file.name, 
                    contentType: file.type, 
                    projectId: projectId, 
                    entity: 'DETECTION', 
                    entityId: defectId,
                    inspectionId: inspectionId
                }),
            });

            if (!presignRes.ok) {
                console.error("Failed to get presigned URL");
                continue;
            }

            const { url, fields } = await presignRes.json();

            // Build FormData for S3
            const formData = new FormData();
            Object.entries(fields).forEach(([key, value]) => {
                formData.append(key, value as string);
            });
            formData.append("file", file);

            // Upload directly to S3
            const uploadRes = await fetch(url, {
                method: "POST",
                body: formData,
            });

            if (uploadRes.ok) {
                uploadedKeys.push(fields.key);
            } else {
                console.error("Failed to upload file:", file.name);
            }
        }

        // Add new keys to existing ones (if any)
        setS3Keys(prev => [...prev, ...uploadedKeys]);
        setUploading(false);
    }

    const handleSuccess = () => {
        //datePickerImperativeHandleRef.current?.reset();
        setS3Keys([]);
        onFormSuccess();
    }; 

    const handleDelete = async () => {
        if (!detection) return;
        
        // Simple browser confirmation
        if (confirm("Are you sure you want to delete this defect?")) {
            startDeleteTransition(async () => {
                const result = await deleteDefect(detection.id);
                if (result.status === 'Success') {
                    onFormSuccess(); // This will close the form and refresh the map
                } else {
                    alert(result.message); // Show an error
                }
            });
        }
    };

    return (        
    <div className="relative w-full h-full">

        <Button 
            type="button"
            variant="ghost"
            size="icon"
            onClick={onCancel}
            className="absolute -top-2 -right-2 text-muted-foreground hover:text-foreground z-10"
        >
            <X className="w-5 h-5" />
        </Button>
        
        
        <h3 className="text-lg font-bold mb-4 pr-8">
            {detection ? 'Edit Defect' : 'New Defect'}
        </h3>

        <Form action={action} actionState={actionState} onSuccess={handleSuccess}>
            {geometry && (
                    <input 
                        type="hidden" 
                        name="Defect_Location" 
                        value={JSON.stringify(geometry)} 
                    />
                )}
            {detection?.sourceImageId && (
                    <div className="mb-4 p-3 bg-slate-100 dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700">
                        <div className="flex items-center justify-between mb-2">
                            <span className="text-xs font-semibold text-muted-foreground uppercase tracking-wider">
                                Source Image
                            </span>
                            {/* This badge confirms we have 2D data */}
                            {detection.annotation2D && (
                                <span className="text-[10px] bg-green-100 text-green-700 px-2 py-0.5 rounded-full">
                                    Has Drawing
                                </span>
                            )}
                        </div>
                        
                        <div className="flex items-center gap-2">
                            <div className="text-sm truncate flex-1 font-mono">
                                {detection.sourceImageId}
                            </div>
                            <Button
                                type="button"
                                variant="outline"
                                size="sm"
                                onClick={() => onOpenImage(detection)} // 👈 Open Modal in Edit Mode
                                className="gap-2 h-8"
                            >
                                <ImageIcon className="w-3 h-3" />
                                Edit Drawing
                            </Button>
                        </div>
                    </div>
                )}
            <div className="mb-2">
                <Label htmlFor="Defect_Type"  
                    className="block text-sm font-medium  mb-1">
                        Defect Type
                </Label>
                <select id="Defect_Type" name='Defect_Type'
                defaultValue={ (actionState.payload?.get('Defect_Type') as string ) ?? detection?.type} 
                className="w-full p-2 border border-input bg-background rounded-md text-sm">
                    <option value="SPALLING_CRACK" >Spalling Crack</option>
                    <option value="EFFLORESCENCE" >Efflorescence</option>
                    <option value="WATER_DAMAGE" >Water Damage</option>
                    <option value="CORROSION_STAIN" >Corrosion Stain</option>
                    <option value="INSULATION_FAULT" >Insulation Fault</option>
                </select>
                
                <FieldErrorMsg actionState={actionState} name="Defect_Type" />
            </div>

            <div className="mb-2">
                <Label htmlFor="Defect_Severity"  
                    className="block text-sm font-medium  mb-1">
                        Defect Severity
                </Label>
                <select id="Defect_Severity" name='Defect_Severity'
                defaultValue={ (actionState.payload?.get('Defect_Severity') as string ) ?? detection?.severity} 
                className="w-full p-2 border border-input bg-background rounded-md text-sm">
                    <option value="LOW">Low</option>
                    <option value="MEDIUM">Medium</option>
                    <option value="HIGH">High</option>
                    <option value="CRITICAL">Critical</option>
                </select>
                
                <FieldErrorMsg actionState={actionState} name="Defect_Severity" />
            </div>
            
            <div className="mb-2">
                <Label htmlFor="Defect_Status"  
                    className="block text-sm font-medium  mb-1">
                        Defect Status
                </Label>
                <select id="Defect_Status" name='Defect_Status'
                defaultValue={ (actionState.payload?.get('Defect_Status') as string ) ?? detection?.status} 
                className="w-full p-2 border border-input bg-background rounded-md text-sm">
                    <option value="NEW">New</option>
                    <option value="ACKNOWLEDGED">Acknowledged</option>
                    <option value="IN_PROGRESS">In Progress</option>
                    <option value="RESOLVED">Resolved</option>
                </select>
                
                <FieldErrorMsg actionState={actionState} name="Defect_Status" />
            </div>

            <div className="mb-2">
                <Label htmlFor="Defect_Notes" className="block text-sm font-medium  mb-1">Notes</Label>
                <Textarea id='Defect_Notes' name='Defect_Notes' 
                    defaultValue={ (actionState.payload?.get('Defect_Notes') as string ) ?? detection?.notes} 
                    className="w-full p-2 border border-gray-300 rounded-md " rows={2}></Textarea>
            </div>

            {/* --- NEW FILE UPLOAD SECTION --- */}
            <div className="mb-4">
                <Label className="block text-sm font-medium mb-1">Attachments</Label>
                <div className="border border-dashed border-input rounded-md p-4 text-center hover:bg-accent/50 transition-colors relative">
                    <input
                        type="file"
                        multiple
                        accept={ACCEPTED.join(",")}
                        onChange={handleFileUpload}
                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                        disabled={uploading}
                    />
                    <div className="flex flex-col items-center gap-1">
                        <CloudUpload className="w-5 h-5 text-muted-foreground" />
                        <span className="text-xs text-muted-foreground">
                            {uploading ? "Uploading..." : "Click or drag to attach files"}
                        </span>
                    </div>
                </div>
                
                {/* Visual feedback for selected/uploaded files */}
                {s3Keys.length > 0 && (
                    <div className="mt-2 text-xs text-green-600 flex items-center gap-1">
                        <div className="w-2 h-2 rounded-full bg-green-500" />
                        {s3Keys.length} file(s) ready to save
                    </div>
                )}

                {/* Existing attachments list could go here if we fetch them */}
                
                <FieldErrorMsg actionState={actionState} name="files" />
            </div>

            <div className={cn(
                    "flex w-full gap-2 pt-2",
                    detection ? "justify-between" : "justify-center"
                )}>
                {detection && canDelete && (
                    <Button 
                        type="button"
                        variant="destructive" 
                        onClick={handleDelete}
                        disabled={isDeleting}
                    >
                        {isDeleting ? <div className="w-4 h-4 animate-spin rounded-full border-2 border-current border-t-transparent"/> : 
                                    <AlertTriangle className="w-4 h-4" />}
                    </Button>
                )}
       
               {(!detection || canEdit) && (
                        <SubmitButton 
                            label={detection ? 'Save Changes' : 'Create Defect'} 
                            disabled={false}   
                        />
                        )}
            </div>
        </Form>
    </div>
    );
}
 
export  {DetectionUpsertForm};
</file>

<file path="src/features/defects/defect-table.tsx">
"use client"
import { DataTable } from "@/components/data-table"
import { getColumns, Defect } from "./columns"
import { getDefects } from "./queries/get-defects";
import { DetectionSeverity, DetectionStatus, DetectionType } from "@prisma/client";

// async function getData(): Promise<Defect[]> {
//   // Fetch data from your API here.
//   return [
//     {
//       id:'1',
//       type: "SPALLING_CRACK",
//       status: "NEW",
//       severity: "LOW",
//     },
//     {
//       id:'2',
//       type: "EFFLORESCENCE",
//       status: "IN_PROGRESS",
//       severity: "CRITICAL",
//     },
//     {
//       id:'3',
//       type: "WATER_DAMAGE",
//       status: "RESOLVED",
//       severity: "CRITICAL",
//     },    
//     {
//       id:'4',
//       type: "SPALLING_CRACK",
//       status: "NEW",
//       severity: "LOW",
//     },
//     {
//       id:'5',
//       type: "EFFLORESCENCE",
//       status: "IN_PROGRESS",
//       severity: "CRITICAL",
//     },
//     {
//       id:'6',
//       type: "WATER_DAMAGE",
//       status: "RESOLVED",
//       severity: "CRITICAL",
//     },    
//     {
//       id:'7',
//       type: "SPALLING_CRACK",
//       status: "NEW",
//       severity: "LOW",
//     },
//     {
//       id:'8',
//       type: "EFFLORESCENCE",
//       status: "IN_PROGRESS",
//       severity: "CRITICAL",
//     },
//     {
//       id:'9',
//       type: "WATER_DAMAGE",
//       status: "RESOLVED",
//       severity: "CRITICAL",
//     },    
//     {
//       id:'10',
//       type: "SPALLING_CRACK",
//       status: "NEW",
//       severity: "LOW",
//     },
//     {
//       id:'11',
//       type: "EFFLORESCENCE",
//       status: "IN_PROGRESS",
//       severity: "CRITICAL",
//     },
//     {
//       id:'12',
//       type: "WATER_DAMAGE",
//       status: "RESOLVED",
//       severity: "CRITICAL",
//     }
//     // ...
//   ]
// };


type DefectTableProps = {
  inspectionId: string;
  data: Defect[]; // Data is now passed from parent
  onViewDefect: (id: string) => void;
  canDeleteDefect: boolean;  // Add this
  canEditDefect: boolean;    // Add this
};

export default  function DefectTable({ data, onViewDefect, canDeleteDefect, canEditDefect }: DefectTableProps) {
  //const data = await getData();
  const defects  =  getColumns(onViewDefect);
  if (!defects)return;
  //console.log(defects)

  return (
   
      <DataTable columns={defects} data={data} />

  )
}
</file>

<file path="src/features/inspection/actions/upsert-inspection.ts">
'use server';

import { setCookieByKey } from "@/actions/cookies";
import {formErrorToActionState, ActionState, toActionState} from '@/components/forms/utils/to-action-state';
import {prisma} from '@/lib/prisma';
import {  inspectionsPath, projectPath, supplementDownloadPath,  } from '@/path';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import { AnalysisType } from "@prisma/client";
import * as inspectionData from "../data";
import * as attachmentSubjectDTO from "@/features/supplements/dto/attachment-subject-dto";
import * as attachmentService from "../../supplements/service";
import { inngest } from "@/lib/inngest";
import {z} from 'zod';
import { getAuthOrRedirect } from '@/features/auth/queries/get-auth-or-rerdirect';
import { IsOwner } from '@/features/auth/utils/is-owner';
import { filesSchema } from "@/features/supplements/schema/files";
import { findIdsFromText } from '@/utils/find-ids-from-text';
import { getInspectionPermissions } from "../permissions/get-inspection-permissions";

const JobTypeEnum = z.enum(AnalysisType);

const UpsertInspectionSchema= z.object({
    title:z.string().min(1).max(100),
    //content: z.string().min(1).max(1024),
    inspectionDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Is required"),
    projectId: z.string().min(1).max(100),
    jobs: z.array(JobTypeEnum).optional().default([]),
    //files: z.array(z.string().min(1)), //  S3 keys,

    
});


const UpsertInspection = async (projectId: string ,
    inspectionId: string,filesKeys: string[] ,
    _actionStat:ActionState ,
    formData: FormData) =>{

    let inspection;

    try{
        const {user, activeOrganization}=await getAuthOrRedirect();
        
        if (!user || !activeOrganization) {
            return toActionState('Error', 'Not Authenticated');
            }
        
        const permissions = await getInspectionPermissions({
                    userId: user.id,
                    organizationId: activeOrganization.id
            });
        
        if (!permissions.canEditInspection) {
            return toActionState('Error', 'You do not have permission to edit  or create ins.');
            }
        const data_parsed= UpsertInspectionSchema.parse({
            title: formData.get('title') ,
            //content: formData.get('content') ,
            inspectionDate: formData.get("inspectionDate") ,
            projectId,
            jobs: formData.getAll("jobs"),
            //files: formData.getAll('files'),
            
        });

        const isoInspectionDate = new Date(data_parsed.inspectionDate).toISOString();

        inspection = await inspectionData.createInspection({
            id: inspectionId,
            userId: user.id,
            title: data_parsed.title,
            projectId: data_parsed.projectId,
            inspectionDate: isoInspectionDate,
            jobs: data_parsed.jobs,
            options: {
                includeUser: true,
                includeProject: true,
            },
        });

        const subject = attachmentSubjectDTO.fromInspection(inspection);
        if (!subject) {
            return toActionState("Error", "Inspection not created");
        }

        await attachmentService.createAttachments({
            subject: subject,
            entity: "INSPECTION",
            entityId: inspection.id,
            files: filesKeys,
            });
        
        // console.log('Inspection Info: ', inspection)
        // console.log('supplements Info: ', supplements)

        if (inspection.status === "SCHEDULED") {
        await inngest.send({
            name: "app/inspection.started",
            data: {
                inspectionId: inspection.id,
                },
            })
        };
  
        
    }catch (error){
        return formErrorToActionState(error, formData);
    }

   
    revalidatePath(inspectionsPath(projectId ));
    
    await setCookieByKey(
            "toast","Inspection started you will recieve \n an email when the inspection complete",
        ); 

    redirect(inspectionsPath(projectId)); // 👈 navigate to inspections page
    //return toActionState('Success','Inspection Started')
};

export {UpsertInspection};
</file>

<file path="src/features/inspection/components/inspection-form-upsert.tsx">
'use client';

import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";

import { Inspection } from "@prisma/client";

import { SubmitButton } from "@/components/forms/submit-buttton";
import { useActionState, useMemo, useRef, useState } from "react";
import { FieldErrorMsg } from "@/components/forms/field-error";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";

import { Form } from "@/components/forms/form";

import { DatePicker, ImperativeHandleFromDatePicker } from "@/components/date-picker";
import { UpsertInspection } from "../actions/upsert-inspection";
import { Button } from "@/components/ui/button";
import { ACCEPTED } from "@/features/supplements/constants";
//import { v4 as uuidv4 } from 'uuid';
//import { randomUUID } from 'crypto'; 
import { LucideBox, LucideCloudUpload, LucideScanLine } from "lucide-react";

type InspectionUpdateFormProps = {
    projectId: string;
   
   
}

const InspectionUpsertForm = ({projectId} : InspectionUpdateFormProps) => {
     const inspectionId = useMemo(() => crypto.randomUUID(), []);

    const [uploading, setUploading] = useState(false);
    const [s3Keys, setS3Keys] = useState<string[]>([]);

    const [actionState, action]= useActionState(
        UpsertInspection.bind(null, projectId, inspectionId , s3Keys), 
        EMPTY_ACTION_STATE)
    const [fileCount, setFileCount] = useState(0);
    

    const datePickerImperativeHandleRef =useRef<ImperativeHandleFromDatePicker>(null);
    
    // Generate a unique ID for the attachment on the server
    
    async function handleFileUpload(event: React.ChangeEvent<HTMLInputElement>) {
        const files = event.target.files;
        if (!files || files.length === 0) return;

        setUploading(true);
        const uploadedKeys: string[] = [];

        for (const file of Array.from(files)) {
        // 1. Ask backend for a presigned URL
            const presignRes = await fetch("/api/aws/s3/supplements/presign-upload", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ filename: file.name, contentType: file.type, 
                                            projectId:projectId, 
                                            entity: 'INSPECTION', 
                                            entityId: inspectionId }),
                            });

            if (!presignRes.ok) {
                console.error("Failed to get presigned URL");
                continue;
            }

            const { url, fields } = await presignRes.json();

      // 2. Build FormData for S3
            const formData = new FormData();
            Object.entries(fields).forEach(([key, value]) => {
                formData.append(key, value as string);
                });
            formData.append("file", file);

      // 3. Upload directly to S3
            const uploadRes = await fetch(url, {
                        method: "POST",
                        body: formData,
                        });

            if (uploadRes.ok) {
                    uploadedKeys.push(fields.key); // store the uploaded file's S3 key
        } else {
                    console.error("Failed to upload file:", file.name);
        }
    }

    setS3Keys(uploadedKeys);
    setUploading(false);
  }

    const handleSuccess = () => {
        datePickerImperativeHandleRef.current?.reset();
        setS3Keys([]);
    }; 

    return (
     <Form action={action} actionState={actionState} onSuccess={handleSuccess} >
        <div className="space-y-6">
            
            {/* Section 1: Basic Info */}
            <div className="space-y-4">
                <div className="grid gap-2">
                    <Label htmlFor="title">Dataset Name</Label>
                    <Input id="title" name='title' placeholder="e.g. 'North Façade - Post Storm Scan'" />
                    <FieldErrorMsg actionState={actionState} name="title" />
                </div>

                <div className="grid gap-2">
                    <Label htmlFor="inspectionDate">Capture Date</Label>
                    <div className="text-xs text-muted-foreground mb-1">When were these photos taken?</div>
                    <DatePicker   
                        id="inspectionDate"
                        name="inspectionDate"
                        imperativeHandleRef={datePickerImperativeHandleRef}
                    />
                    <FieldErrorMsg actionState={actionState} name="inspectionDate" />
                </div>
            </div>

            {/* Section 2: Processing Jobs (Visual Cards) */}
            <div className="space-y-3">
                <Label>AI Processing Jobs</Label>
                <div className="grid grid-cols-2 gap-4">
                    {/* 3D Reconstruction Card */}
                    <label className="cursor-pointer">
                        <input type="checkbox" name="jobs" value="THREE_D_MODELING" className="peer sr-only" />
                        <div className="flex flex-col items-center justify-center p-4 border-2 border-muted rounded-xl hover:bg-muted/50 peer-checked:border-primary peer-checked:bg-primary/5 transition-all">
                            <LucideBox className="w-6 h-6 mb-2 text-muted-foreground peer-checked:text-primary" />
                            <span className="text-sm font-medium">3D Model</span>
                        </div>
                    </label>

                    {/* Crack Detection Card */}
                    <label className="cursor-pointer">
                        <input type="checkbox" name="jobs" value="CRACK_DETECTION" className="peer sr-only" />
                        <div className="flex flex-col items-center justify-center p-4 border-2 border-muted rounded-xl hover:bg-muted/50 peer-checked:border-primary peer-checked:bg-primary/5 transition-all">
                            <LucideScanLine className="w-6 h-6 mb-2 text-muted-foreground peer-checked:text-primary" />
                            <span className="text-sm font-medium">AI Defect Scan</span>
                        </div>
                    </label>
                </div>
                <FieldErrorMsg actionState={actionState} name="jobs" />
            </div>

            {/* Section 3: File Upload (Better UX) */}
            <div className="space-y-2">
                <Label>Drone Imagery</Label>
                <div className="border-2 border-dashed border-muted-foreground/25 rounded-xl p-8 text-center hover:bg-muted/20 transition-colors relative">
                    <input
                        name="files"
                        type="file"
                        multiple
                        accept={ACCEPTED.join(",")}
                        onChange={handleFileUpload}
                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                    />
                    <div className="flex flex-col items-center gap-2">
                        <div className="p-3 bg-primary/10 rounded-full">
                            <LucideCloudUpload className="w-6 h-6 text-primary" />
                        </div>
                        <div className="text-sm">
                            <span className="font-semibold text-primary">Click to upload</span> or drag and drop
                        </div>
                        <p className="text-xs text-muted-foreground">
                            JPG, PNG (Max 100MB per file)
                        </p>
                        {fileCount > 0 && (
                            <div className="mt-2 text-sm font-medium text-green-600 bg-green-100 px-3 py-1 rounded-full">
                                {fileCount} files selected
                            </div>
                        )}
                    </div>
                </div>
                {uploading && <p className="text-xs text-blue-500 animate-pulse">Uploading to secure storage...</p>}
                
                {/* Hidden inputs for keys */}
                {s3Keys.map((key, idx) => (
                    <input key={idx} type="hidden" name="files" value={key} />
                ))}
                <FieldErrorMsg actionState={actionState} name="files" />
            </div>
        
        </div>   
        
        <div className="pt-4 grid">
            <SubmitButton label='Start Processing' disabled={!uploading} size="lg" /> 
        </div>
    </Form>

    );

}
 
export  {InspectionUpsertForm };
</file>

<file path="src/features/inspection/components/inspection-item.tsx">
'use client';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { format } from "date-fns";
import { LucideArrowRightCircle, LucideArrowUpRightFromSquare, LucideBan, LucideCheck } from "lucide-react";
import { getInspections } from "../queries/get-inspections";
import { InspectionMoreMenu } from "./inspection-more-menu";
import {PermissionToggle} from './permission-toggle';
import { InspectionDeleteButton } from "./inspection-delete-button";
import { Inspection } from "@prisma/client";
import { supabase } from "@/lib/supabase";
import { RealtimeChannel } from "@supabase/supabase-js";
import { useEffect, useState } from "react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import {  analysis_Path, three_D_viewer_Path } from "@/path";

type InspectionItemPageProp = {
   
    inspection: Inspection ;
    canDelete: boolean;
}



export const InspectionItem = ({ inspection, canDelete}:InspectionItemPageProp) => {

    //const inspections = await getInspections(projectId);
    // const inspectionMoreMenu= (
    //         <InspectionMoreMenu
    //             projectId= {inspection.projectId}
    //             conductedByUserId= {inspection.conductedByUserId}
    //            // inspectionRole= {inspection.inspectionRole}
    //         />
    //    )

    const detailButton =  (
                        <Button variant="default" size="icon" >
                            <Link href={analysis_Path(inspection.projectId, inspection.id)} >
                                <LucideArrowRightCircle className="h-4 w-4" />                        
                            </Link>
                        </Button>
            );

    const deleteButton= (
            <InspectionDeleteButton 
                            inspectionId= {inspection.id}
                            conductedByUserId= {inspection.conductedByUserId}
                        />
                    )
    const buttons= <>{inspection.status==='COMPLETED' && detailButton}{ canDelete && deleteButton}</>;
    
    return ( 
        <TableRow key={inspection.id} >
                <TableCell>{inspection.title}</TableCell>
                    {/* <TableCell>{inspection.conductedByUser?.email}</TableCell> */}
                <TableCell>
                    {format(inspection.inspectionDate , "yyyy-MM-dd")}
                </TableCell>
                {/* <TableCell>
                                {inspection.conductedByUser?.emailVerified ? (
                                    <LucideCheck className="h-4 w-4" />
                                ): (
                                    <LucideBan className="h-4 w-4" />
                                )}
                </TableCell> */}
                <TableCell>{inspection.status}</TableCell>
                {/* <TableCell>
                    <PermissionToggle
                        userId={inspection.userId}
                            organizationId={inspection.organizationId}
                            permissionKey="canDeleteTicket"
                            permissionValue= {inspection.canDeleteTicket}
                    />
                </TableCell> */}
                <TableCell className="flex justify-end gap-x-2">
                    {buttons}
                </TableCell>
        </TableRow>
    )

}
</file>

<file path="src/features/membership/actions/toggle-permission.ts">
'use server';
import { prisma } from "@/lib/prisma";
import { getAdminOrRedirect } from "../queries/get-admin-or-redirect";
import { toActionState } from "@/components/forms/utils/to-action-state";
import { revalidatePath } from "next/cache";
import { membershipsPath } from "@/path";
import { Membership } from "@prisma/client";

type PermissionKey = keyof Pick<Membership, 
  'canDeleteInspection' | 
  'canEditInspection' |
  'canDeleteDefect' |
  'canEditDefect'
>;

export const togglePermission = async ({userId,
            organizationId,
            permissionKey}:{
                userId: string,
                organizationId: string,
                permissionKey: PermissionKey
            }) => {
    await getAdminOrRedirect(organizationId);

    // 2. Validate Key (Security precaution)
    const allowedKeys: PermissionKey[] = [
        'canDeleteInspection', 'canEditInspection',
        'canDeleteDefect' , 'canEditDefect'
    ];

    if (!allowedKeys.includes(permissionKey as PermissionKey)) {
        return toActionState('Error', "Invalid permission key");
    }

    const key = permissionKey as PermissionKey;

    const where = {
        MembershipId:{
            organizationId,
            userId,
        },
    };

    const membership = await prisma.membership.findUnique({
        where,
    });

    if(!membership){
        return toActionState('Error', "Membership not Found");
    }

    await prisma.membership.update({
        where,
        data:{
            [permissionKey]: membership[permissionKey] === true ? false : true,
        },
    });

    revalidatePath(membershipsPath(organizationId));

    return toActionState('Success', 'Permission updated');

}
</file>

<file path="src/features/membership/components/permission-toggle.tsx">
'use client';
import { Form } from "@/components/forms/form";
import { SubmitButton } from "@/components/forms/submit-buttton";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";
import { LucideBan, LucideCheck } from "lucide-react";
import { useActionState } from "react";
import { togglePermission } from "../actions/toggle-permission";
import { Membership } from "@prisma/client";

type PermissionKey = keyof Pick<Membership,  
  'canDeleteInspection' | 
  'canEditInspection' |
  'canDeleteDefect' |
  'canEditDefect'
>;

type PermissionToggleProps = {
    userId: string,
    organizationId: string,
    permissionKey: PermissionKey,
    permissionValue:boolean,
    disabled?:boolean
}
export const PermissionToggle = ({
    userId,
    organizationId,
    permissionKey,
    permissionValue,
    disabled = false
}: PermissionToggleProps) => {
    const [actionState, action] = useActionState(
        togglePermission.bind(null, {
            userId,
            organizationId,
            permissionKey
        }),
        EMPTY_ACTION_STATE
    )
    return ( 
        <Form actionState={actionState} action={action}>
            <SubmitButton 
                icon={permissionValue ? <LucideCheck /> : <LucideBan />}
                size="icon"
                variant={permissionValue ? 'secondary': 'ghost'} // Ghost looks cleaner in a table
                //className={permissionValue ? "text-green-600 bg-green-50 hover:bg-green-100" : "text-muted-foreground"}
                disabled={disabled}
            />
        </Form>
     );
}
</file>

<file path="src/features/project/components/project-form-upsert.tsx">
'use client';
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { useRouter } from "next/navigation";
import { useEffect } from "react";


import { Project } from "@prisma/client";

import { SubmitButton } from "@/components/forms/submit-buttton";
import { useActionState, useRef } from "react";
import { FieldErrorMsg } from "@/components/forms/field-error";
import { EMPTY_ACTION_STATE } from "@/components/forms/utils/to-action-state";

import { Form } from "@/components/forms/form";

import { DatePicker, ImperativeHandleFromDatePicker } from "@/components/date-picker";
import { UpsertProject } from "../actions/upsert-project";
import { projectPath, projectsPath } from "@/path";


type ProjectUpdateFormProps = {
    project?: Project;
}

const ProjectUpsertForm = ({project} : ProjectUpdateFormProps) => {
    const [actionState, action]= useActionState(
        UpsertProject.bind(null, project?.id), EMPTY_ACTION_STATE);

    const router = useRouter();

    useEffect(() => {
    if (actionState.status === "Success") {
        if (project?.id) {
        router.push(projectPath(project.id));
        } else {
        router.push(projectsPath());
        }
    }
    }, [actionState, router, project]);

    
    const datePickerImperativeHandleRef =useRef<ImperativeHandleFromDatePicker>(null);

    const handleSuccess = () => {
        datePickerImperativeHandleRef.current?.reset();
    }; 

    return (         
     <Form action={action} actionState={actionState} onSuccess={handleSuccess}>
        <Label htmlFor="name">Project Name</Label>
        <Input id="name" name='name' type="text" 
        defaultValue={ (actionState.payload?.get('name') as string ) 
                        ?? project?.name} />
        
        <FieldErrorMsg actionState={actionState} name="name" />

        <Label htmlFor="description" >Description</Label>
        <Textarea name="description" id="description" 
            defaultValue={ (actionState.payload?.get('description') as string ) 
                            ?? project?.description} />
        <FieldErrorMsg actionState={actionState} name="description" />

        {/* <div className="flex gap-x-2  mb-1">  */}
            {/*  <div className="w-1/2">
                <Label htmlFor="updatedAt">Updated At</Label>
                <DatePicker
                
                    id="updatedAt"
                    name="updatedAt"
                    defaultValue={
                    (actionState.payload?.get("updatedAt")) ??
                    project?.updatedAt
                    }
                    imperativeHandleRef={datePickerImperativeHandleRef }
                />
                <FieldErrorMsg actionState={actionState} name="updatedAt" />
            </div> */}
            {/* <div className="w-1/2"> */}
                <Label htmlFor="address">Address</Label>
                <Input
                    id="address"
                    name="address"
                    type="string"
                   
                    defaultValue={
                    (actionState.payload?.get("address") as string ) ??
                    (project?.address ? project?.address : "")
                    }
                />
                <FieldErrorMsg actionState={actionState} name="address" />
            {/* </div> */}
        {/* </div> */}

        <SubmitButton label= {project ? 'Edit': 'Create'} disabled/>
        
    </Form>);
}
 
export  {ProjectUpsertForm};
</file>

<file path="src/features/project/queries/get-project.ts">
import { getAuth } from '@/features/auth/queries/get-auth';
import { IsOwner } from '@/features/auth/utils/is-owner';
import {prisma} from '@/lib/prisma'
import { getProjectPermissions } from '../permissions/get-project-permissions';
import { getAuthOrRedirect } from '@/features/auth/queries/get-auth-or-rerdirect';
import { toActionState } from '@/components/forms/utils/to-action-state';
import { ca } from 'date-fns/locale';

export const getProject = async(projectId:string ) => {
    
    const {user, activeOrganization} = await getAuthOrRedirect();

    if (!user || !activeOrganization) {
        return toActionState('Error', 'Not Authenticated');
    };      

    const project= await prisma.project.findUnique({
        where: {
            id: projectId,
        },
        include: {
            user :{
                select:{
                    username: true
                }
            }
        }
    });

    if(!project){
        return null;
    };

    const permissions = await getProjectPermissions({
        userId: user?.id, 
        organizationId: project.organizationId});
    const isOwner = IsOwner(user, project);

    return {...project, isOwner, permissions:{
        canDeleteProject: isOwner && !!permissions.canDeleteProject,
        canEditProject: isOwner && !!permissions.canEditProject
    }};
};
</file>

<file path="src/lib/inngest.ts">
import { SupplementDeleteEventArgs } from '@/features/supplements/events/event-attachment-deleted';
import { EmailVeriificationEventArgs } from '@/features/auth/events/event-email-verification';
import { InvitationCreateEventArgs } from '@/features/invitation/events/event-invitation-created';
import { OrganizationCreateEventArgs } from '@/features/organization/events/event-organization-created';
import { PasswodResetEventArgs } from '@/features/password/events/event-password-reset';
import { InspectionStartedEventArgs } from '@/features/inspection/events/event-inspection-created';
import {EventSchemas, Inngest} from 'inngest' ;


type Events = {
    'app/password.password-reset':PasswodResetEventArgs;
    'app/auth.sign-up': EmailVeriificationEventArgs;
    "app/invitation.created" : InvitationCreateEventArgs;
   
    "app/supplement.deleted": SupplementDeleteEventArgs;
    "app/organization.created": OrganizationCreateEventArgs;
    "app/inspection.started": InspectionStartedEventArgs;

}

export const inngest = new Inngest({
    id: 'road-to-next-js',
    eventKey:
    process.env.NODE_ENV === "production"
      ? process.env.INNGEST_EVENT_KEY
      : undefined,
    schemas: new EventSchemas().fromRecord<Events>(),
});
</file>

<file path="src/path.ts">
export const homePath = ()=>"/";

export const projectsPath = ()=>"/projects";
export const projectPath= (projectId: string)=>`/projects/${projectId}`;
export const projectCreatePath = ()=> '/projects/create';
export const projectEditPath=  (projectId: string)=> `/projects/${projectId}/edit`;
export const inspectionsPath = (projectId: string)=>
    `/projects/${projectId}/inspections`;

export const inspectionsCreatePath = (projectId: string)=>
    `/projects/${projectId}/inspections/create`;

export const three_D_viewer_Path =(projectId:string, inspectionId: string)=>
    `/projects/${projectId}/inspections/${inspectionId}/analysis/3d_viewer`

export const tabular_analysis_Path =(projectId:string, inspectionId: string)=>
    `/projects/${projectId}/inspections/${inspectionId}/analysis/table`

export const analysis_Path =(projectId:string, inspectionId: string)=>
    `/projects/${projectId}/inspections/${inspectionId}/analysis`

export const pricingPath = ()=> '/pricing';

export const ticketsPath = ()=> "/tickets";
export const ticketsByOrganizationPath = ()=>'/tickets/organization';

export const ticketPath= (ticketId: string)=>`/tickets/${ticketId}`;
export const ticketEditPath=  (ticketId: string)=> `/tickets/${ticketId}/edit`;

export const emailVerificationPath = ()=> '/email-verification';
export const emailInvitationPath = ()=> '/email-invitation';


export const signUpPath = ()=> '/sign-up';
export const signInPath = ()=> '/sign-in';

export const passwordForgotPath = ()=> '/password-forgot';
export const passwordResetPath = ()=> '/password-reset';

export const profilePath = ()=> '/account/profile';
export const passwordPath = ()=> '/account/password';

export const organizationPath = ()=> '/organization';
export const organizationCreatePath = ()=> '/organization/create';
export const membershipsPath = (organizationId: string)=>
    `/organization/${organizationId}/memberships`;
export const invitationsPath =  (organizationId: string)=>
    `/organization/${organizationId}/invitations`;
export const credentialsPath =  (organizationId: string)=>
    `/organization/${organizationId}/credentials`;

export const subscriptionPath = (organizationId: string) =>
  `/organization/${organizationId}/subscription`;


export const onboardingPath= ()=> '/onboarding';
export const selectActiveOrganizationPath= ()=> 
    '/onboarding/select-active-organization';

export const attachmentDownloadPath = (attachmentId: string) =>
  `/api/aws/s3/attachments/${attachmentId}`;


export const supplementDownloadPath = (supplementId: string) =>
  `/api/aws/s3/supplements/${supplementId}`;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    },
    //"allowImportingTsExtensions": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", "src/actions", "next.config.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/inspections/[inspectionId]/analysis/analysis-layout.tsx">
"use client"

import { useRef, useState } from "react";
import { Analysis3DViewer } from "@/features/analysis/components/analysis_3d_viewer";
import { InspectorPanel } from "@/features/analysis/components/inspector-panel";
import { AnalyticsDrawer } from "@/features/analysis/components/analytics-drawer";
import { Detection } from "@prisma/client";
import { MapLayer } from "@/components/3D_Viewer/types/map";
import { Button } from "@/components/ui/button";
import { 
  BarChart3, 
  Maximize2, 
  Minimize2, 
  PanelRightOpen, 
  PanelRightClose 
} from "lucide-react"; 
import { cn } from "@/lib/utils";
import { Defect } from "@/features/defects/columns";

interface AnalysisLayoutProps {
  projectId: string;
  inspectionId: string;
  camerasUrl: string;
  proxyBaseUrl: string;
  tilesetUrl: string;
  layers: MapLayer[];
  initialDetections: Detection[];
  canDeleteDefect: boolean;
  canEditDefect: boolean;
}

export function AnalysisLayout({
  camerasUrl,
  proxyBaseUrl,
  tilesetUrl,
  layers,
  projectId,
  inspectionId,
  initialDetections,
  canDeleteDefect,
  canEditDefect
}: AnalysisLayoutProps) {
  
  const [isInspectorOpen, setIsInspectorOpen] = useState(false); 
  const [isAnalyticsOpen, setIsAnalyticsOpen] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [focusedDefectId, setFocusedDefectId] = useState<string | null>(null);

  const [draftDefect, setDraftDefect] = useState<{ position: {x:number, y:number, z:number} } | null>(null);

  const containerRef = useRef<HTMLDivElement>(null);

  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      containerRef.current?.requestFullscreen();
      setIsFullscreen(true);
    } else {
      document.exitFullscreen();
      setIsFullscreen(false);
    }
  };

// Handler for when user clicks the 3D model
  const handleDraftCreated = (data: { positions: any[] }) => {
      // 1. Extract the position (assuming single point for now)
      const position = data.positions[0]; 
      
      // 2. Set draft state
      setDraftDefect({ position: { x: position.x, y: position.y, z: position.z } });
      
      // 3. Open the inspector
      setIsInspectorOpen(true);
      
      // 4. Clear any focused existing defect so we don't show that
      setFocusedDefectId(null);
  };

  const handleDefectSelect = (id: string | null) => {
      if (id) setDraftDefect(null);
      setFocusedDefectId(id);
      if (id) setIsInspectorOpen(true);
  };

  // Close handler needs to clear draft too
  const handleCloseInspector = () => {
      setIsInspectorOpen(false);
      setDraftDefect(null);
      setFocusedDefectId(null);
  };

  return (
    <div 
      ref={containerRef} 
      className="relative h-full w-full overflow-hidden bg-black group"
    >
      
      {/* 1. LAYER A: 3D VIEWER (BACKGROUND) */}
      <div className="absolute inset-0 z-0">
        <Analysis3DViewer 
            tilesetUrl={tilesetUrl}
            camerasUrl={camerasUrl}
            proxyBaseUrl={proxyBaseUrl}
            layers={layers}
            inspectionId={inspectionId}
            initialDetections={initialDetections}
            focusedDefectId={focusedDefectId} 
            canDeleteDefect={canDeleteDefect}
            canEditDefect={canEditDefect}
            onDefectSelected={(defect) => handleDefectSelect(defect.id)}
            onDefectDetected={(candidate: any) => handleDraftCreated(candidate)}
        />
      </div>

      {/* 2. LAYER B: FLOATING HUD (The "Command Bar") */}

      {/* BOTTOM RIGHT: Main Action Bar */}
      <div className={cn(
          "absolute bottom-6 right-6 z-20 flex items-center p-1.5 gap-2 rounded-xl transition-all duration-300",
          "bg-black/60 backdrop-blur-md border border-white/10 shadow-2xl", 
          isInspectorOpen ? "translate-x-[-384px] md:translate-x-[-400px]" : "translate-x-0"
      )}>
        
        {/* Analytics Toggle */}
        <Button 
            variant={isAnalyticsOpen ? "secondary" : "outline"} 
            size="sm" 
            onClick={() => setIsAnalyticsOpen(!isAnalyticsOpen)}
            className={cn(
            "text-black hover:bg-white/10",
            isAnalyticsOpen && "bg-white/20"
        )}
        >
            <BarChart3 className="w-4 h-4 mr-2" />
            Analytics
        </Button>

        {/* Vertical Separator */}
        <div className="h-4 w-px bg-white/20" />

        {/* Inspector Toggle (Primary Blue Button) */}
        <Button 
            variant={isInspectorOpen ? "secondary" : "default"} 
            size="sm" 
            className={cn(
                        "shadow-none transition-all",
                        !isInspectorOpen && "bg-blue-600 hover:bg-blue-700 text-white border-none"
                    )}
            onClick={() => setIsInspectorOpen(!isInspectorOpen)}
        >
            {isInspectorOpen ? (
                <>
                <PanelRightClose className="w-4 h-4 mr-2" />
                Close Panel
                </>
            ) : (
                <>
                <PanelRightOpen className="w-4 h-4 mr-2" />
                Inspector Panel
                </>
            )}
        </Button>
        {/* Vertical Separator */}
        <div className="h-4 w-px bg-white/20 mx-1" />

        {/* 3. Fullscreen Toggle (Icon Only) */}
        <Button 
            variant="ghost" 
            size="icon" 
            onClick={toggleFullscreen}
            className="h-9 w-9 text-white hover:bg-white/10 rounded-lg"
            title="Toggle Fullscreen"
        >
            {isFullscreen ? <Minimize2 className="h-4 w-4" /> : <Maximize2 className="h-4 w-4" />}
        </Button>
      </div>

      {/* 3. LAYER C: INSPECTOR PANEL (SLIDE IN FROM RIGHT) */}
      <div 
        className={cn(
          "absolute top-0 right-0 h-full z-30 transition-transform duration-300 ease-in-out shadow-2xl border-l border-border/50 bg-background",
          "w-full md:w-[400px]", 
          isInspectorOpen ? "translate-x-0" : "translate-x-full"
      )}
        //style={{ width: '400px' }} // Fixed width matching mockup
      >
        {/* Render content only when needed or keep mounted for state preservation */}
        <InspectorPanel 
            inspectionId={inspectionId}
            projectId={projectId}
            defects={initialDetections}
            focusedDefectId={focusedDefectId}
            onSelectDefect={handleDefectSelect}
            onClose={handleCloseInspector}
            draftDefect={draftDefect}
            camerasUrl={camerasUrl}
            proxyBaseUrl={proxyBaseUrl}
            canDeleteDefect={canDeleteDefect}
            canEditDefect={canEditDefect}
            
        />
      </div>

      {/* 4. LAYER D: ANALYTICS DRAWER (SLIDE UP FROM BOTTOM) */}
      <AnalyticsDrawer 
          isOpen={isAnalyticsOpen} 
          onClose={() => setIsAnalyticsOpen(false)} 
          detections={initialDetections}
      />

    </div>
  );
}
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/inspections/[inspectionId]/analysis/page.tsx">
import { getAnalysis } from "@/features/analysis/actions/get-analysis";
import { AnalysisLayout } from "./analysis-layout"; 
import { ProjectBreadCrumbs } from "../../../_navigation/tabs";
import { Suspense } from "react";
import { Spinner } from "@/components/spinner";
import { InspectionActions } from "@/features/inspection/components/inspection-actions";
import { InspectionContextBar, InspectionContextType } from "@/features/inspection/components/inspection-context-bar";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { getDefectPermissions } from "@/features/defects/permissions/get-defect-permissions";
import { MapLayer } from "@/components/3D_Viewer/types/map";
import { DetectionSeverity, DetectionStatus, DetectionType } from "@prisma/client";

type PageProps = {
  params: Promise<{ projectId: string; inspectionId: string }>;
};

// --- MOCK CONTEXT DATA ---
const MOCK_CONTEXT: InspectionContextType = {
    weather: "Partly Cloudy",
    temperature: "24°C",
    droneModel: "DJI Mavic 3 Thermal",
    aiModelVersion: "v2.4.1 (Concrete)",
    aiConfidence: 94
};
// -------------------------

// Server Component fetches data
export default async function AnalysisPage({ params }: PageProps) {
  const { projectId, inspectionId } = await params;
  
  const { user, activeOrganization } = await getAuthOrRedirect();

  const permissions = await getDefectPermissions({
    userId: user.id,
    organizationId: activeOrganization?.id
  });

  // Fetch Analysis (Tileset + Detections)
  const analysis = await getAnalysis(inspectionId);
  //console.log('Inspection ID:', inspectionId);
  //console.log('Project ID:', projectId);
  //console.log('Analysis Data:', analysis);


  //const tilesetUrl = "/model/tileset.json"; // Or from analysis object
  //const tilesetUrl = `/api/tiles/${activeOrganization?.id}/${projectId}/${inspectionId}/tileset.json`;
  // Base URL 
  const apiBaseUrl = `/api/tiles/${activeOrganization?.id}/${projectId}/${inspectionId}`;
  // 1. URL for the 3D Model
  // The API sees .json and maps it to "3d_tiles/model/"
 // const tilesetUrl = `${apiBaseUrl}/tileset.json`;
  const tilesetUrl = `/model/tileset.json`;

  // 2. URL for the Camera Positions
  // The API sees .geojson and maps it to "odm_report/"
   //const camerasUrl = `${apiBaseUrl}/shots.geojson`;
  const camerasUrl = `/shots.geojson`;

  // 3. Base URL for Images (to be passed to children)
  // When you append "/image.jpg", the API maps it to "uploaded_images/"
  const proxyBaseUrl = apiBaseUrl;
  //const proxyBaseUrl = '';
  //  CONSTRUCT THE LAYERS
  const layers: MapLayer[] = [
    // {
    //   id: 'mesh',
    //   name: '3D Mesh',
    //   type: '3D_TILES',
    //   url: `${apiBase}/3d_tiles/model/tileset.json`, 
    //   visible: true,
    //   isBaseLayer: true
    // },
    // {
    //   id: 'ortho',
    //   name: 'Orthophoto',
    //   type: 'IMAGERY',
    //   // Note the {z}/{x}/{y} format for XYZ tiles
    //   url: `${apiBase}/orthophoto/tiles/{z}/{x}/{y}.png`, 
    //   visible: true,
    //   opacity: 0.8
    // },
    // Optional: Point Cloud
    // {
    //   id: 'cloud',
    //   name: 'Point Cloud',
    //   type: 'POINT_CLOUD',
    //   url: `${apiBase}/3d_tiles/pointcloud/tileset.json`,
    //   visible: true
    // }
  ];

  if (!analysis) return <div>Analysis not found</div>;
  const projectName = analysis.inspection.project.name;

//   const detections = analysis.detections.map((d) => ({
//   ...d,
//   type: d.type ?? DetectionType.SPALLING_CRACK, // Provide a default
//   severity: d.severity ?? DetectionSeverity.LOW,
//   status: d.status ?? DetectionStatus.NEW,
// }));


  return (
    <div className="flex flex-col h-[calc(100vh-60px)] w-full overflow-hidden">
    
      {/* HEADER */}
      <div className="flex-none h-14 px-4 flex items-center justify-between border-b border-border bg-background z-10">
         <div className="flex flex-col">
             <ProjectBreadCrumbs projectName={projectName} />
         </div>
         <InspectionActions inspectionId={inspectionId} defects={analysis.detections} projectName={projectName} />
      </div>

      {/* CONTEXT BAR  */}
      {/* <InspectionContextBar data={MOCK_CONTEXT} /> */}

      {/* MAIN WORKSPACE */}
      <div className="flex-1 min-h-0 w-full relative no-scrollbar">
        <Suspense fallback={<Spinner/>} >
            <AnalysisLayout 
              projectId={projectId}
              inspectionId={inspectionId}
              tilesetUrl={tilesetUrl}
              camerasUrl={camerasUrl} 
              proxyBaseUrl= {proxyBaseUrl}
              layers={layers}
              initialDetections={analysis.detections}
              canDeleteDefect={permissions.canDeleteDefect}
              canEditDefect= {permissions.canEditDefect}
            />
        </Suspense>
      </div>
    </div>
  );
}
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/inspections/page.tsx">
import Heading from "@/components/heading";
import { Spinner } from "@/components/spinner";
import { MembershipList } from "@/features/membership/components/membership-list";
import { Suspense } from "react";
import { Breadcrumbs } from "@/components/breadcrumbs";
import { inspectionsCreatePath, projectsPath, projectPath } from "@/path";
import { getProject } from "@/features/project/queries/get-project";
import { ProjectBreadCrumbs } from "../_navigation/tabs";
import { LucidePlus } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { InspectionList } from "@/features/inspection/components/inspection-list";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { toActionState } from "@/components/forms/utils/to-action-state";
import { getInspectionPermissions } from "@/features/inspection/permissions/get-inspection-permissions";
import notFound from "../not-found";

type InspectionsPageProps = {
    params: Promise<{projectId: string}>;
};
const Inspectionspage = async({params}:InspectionsPageProps) => {
    const {projectId}= await params;
    const {user, activeOrganization}= await getAuthOrRedirect();
        
    if (!user || !activeOrganization) {
            return toActionState('Error', 'Not Authenticated');
    }
        
    const permissions = await getInspectionPermissions({
                    userId: user.id,
                    organizationId: activeOrganization.id
 });
        

    //const isAdmin = activeOrganization?.membershipByUser.membershipRole ===  'ADMIN';
    
    const projectResult = await getProject(projectId);
    // Handle null or ActionState (error) cases
    if (!projectResult || !('name' in projectResult)) {
            return notFound();
        }
    // Now TypeScript knows projectResult has 'name' property
    const project = projectResult;
    if(!project) return null
    
    return ( 
        <div className="flex-1 flex flex-col gap-y-8" >
            <Heading 
                title="Inspections"
                description="Manage the inspections related to your project"
                tabs={< ProjectBreadCrumbs projectName={project.name} />}
                actions= {
                    permissions.canEditInspection && (<Button asChild>
                        <Link href={inspectionsCreatePath(projectId)} >
                            <LucidePlus className="w-4 h-4" />
                            Start Inspection
                        </Link>
                    </Button>)
                }
            />

            <Suspense fallback={<Spinner/>} >
                <InspectionList userId = {user.id} projectId={projectId} canDelete= {permissions.canDeleteInspection} />
            </Suspense>
        </div>
     );
}
 
export default Inspectionspage;
</file>

<file path="src/app/(saas)/(authenticated)/projects/[projectId]/page.tsx">
// import { Breadcrumbs } from '@/components/breadcrumbs';
// import Heading from '@/components/heading';
// import { Separator } from '@/components/ui/separator';
// import { Attachments } from '@/features/attachments/components/attachments';
// import { Comments } from '@/features/comment/components/comments/comments';
// import { getComments } from '@/features/comment/queries/get-comments';
// import { ProjectItem } from '@/features/project/components/project-item';
// import { getProject } from '@/features/project/queries/get-project';

// import { notFound } from 'next/navigation';
// import { ProjectBreadCrumbs } from './_navigation/tabs';

// type ProjectPageProps= {
//     params:{
//         projectId: string,
//     }
// }


// const  ProjectPage = async ({params}:ProjectPageProps) => {
//   const { projectId } = await params;
//   const projectPromise = getProject(projectId);
//   const commentsPromise = getComments(projectId);


//   const [project, paginatedComments] = await Promise.all([
//     projectPromise,
//     commentsPromise,
//   ]);
    
//     if(!project){
//         return(
//             notFound()
//         )
//     }
//     return (
//       <div className='flex-1 flex flex-col gap-y-8'>
//          <Heading title='Project Dashboard' 
//             description='Real-time safety intelligence and inspection history.'
//             tabs={< ProjectBreadCrumbs />}
             
//           />
       

//         <div className='flex justify-center' >
//           <ProjectItem project={project} isDetail
//           //   attachments={
//           //     <Attachments entityId={ticket.id} 
//           //       entity="TICKET" 
//           //       isOwner={ticket.isOwner} />
//           //   }
//           //   referencedTickets = {<ReferencedTickets ticketId={ticket.id}/>} 
//           //   comments={
//           //   <Comments
//           //     ticketId={ticket.id}
//           //     paginatedComments={paginatedComments}
//           //   />
//           // }
//           />
//         </div>
//        </div>
        
//      );
// }
 
// export default ProjectPage;


    

import { InspectionList } from "@/features/inspection/components/inspection-list";
import { Suspense } from "react";
import { Spinner } from "@/components/spinner";
import { ProjectStats, ProjectStatsType } from "@/features/project/components/project-stats";
import { ProjectTrendChart, ChartDataPoint } from "@/features/project/components/project-trend-chart";
//import { getProjectAnalytics } from "@/features/project/queries/get-project-analytics";
import { Button } from "@/components/ui/button";
import { LucideDownload, LucideCalendarDays } from "lucide-react";
import Heading from "@/components/heading";
import { ProjectBreadCrumbs } from "./_navigation/tabs";
import { getAuthOrRedirect } from "@/features/auth/queries/get-auth-or-rerdirect";
import { getProject } from "@/features/project/queries/get-project";
import { getInspectionPermissions } from "@/features/inspection/permissions/get-inspection-permissions";
import { toActionState } from "@/components/forms/utils/to-action-state";
import notFound from "./not-found";

// --- MOCK DATA GENERATOR (For UI Dev) ---
const MOCK_STATS: ProjectStatsType = {
    healthScore: 82,
    criticalCount: 2,
    totalDefects: 145,
    totalInspections: 12,
    resolvedCount: 118
};

const MOCK_CHART_DATA: ChartDataPoint[] = [
    { date: 'Jun 2024', critical: 5, open: 12, resolved: 8 },
    { date: 'Jul 2024', critical: 3, open: 15, resolved: 20 },
    { date: 'Aug 2024', critical: 4, open: 8, resolved: 25 },
    { date: 'Sep 2024', critical: 1, open: 5, resolved: 30 },
    { date: 'Oct 2024', critical: 0, open: 4, resolved: 12 },
    { date: 'Nov 2024', critical: 2, open: 6, resolved: 18 },
];
// ----------------------------------------

export default  async  function ProjectPage({ params }: { params: Promise<{ projectId: string }> }) {
    const { projectId } = await params;
    
    const {user, activeOrganization}= await getAuthOrRedirect();
            
    if (!user || !activeOrganization) {
        return toActionState('Error', 'Not Authenticated');
    }
            
    const permissions = await getInspectionPermissions({
        userId: user.id,
        organizationId: activeOrganization.id
     });

    const projectResult = await getProject(projectId);

    // Handle null or ActionState (error) cases
    if (!projectResult || !('name' in projectResult)) {
        return notFound();
    }

    // Now TypeScript knows projectResult has 'name' property
    const project = projectResult;
    if(!project) return null
    // When DB is populated, uncomment this and remove MOCK_DATA
    // const { chartData, kpi } = await getProjectAnalytics(projectId);
    
    // For now, use mocks to verify UI
    const chartData = MOCK_CHART_DATA;
    const kpi = MOCK_STATS;

    return (
        <div className="flex-1 flex flex-col gap-y-8 pb-10">
            
            {/* 1. Header with Actions */}
            <Heading 
                title="Project Dashboard" 
                description="Real-time safety intelligence and inspection history." 
                tabs={<ProjectBreadCrumbs  projectName={project.name || "Project"}/>} 
                actions={
                    <div className="flex gap-2">
                        {/* <Button variant="outline" size="sm">
                            <LucideCalendarDays className="mr-2 h-4 w-4" />
                            Schedule
                        </Button> */}
                        <Button variant="outline" size="sm">
                            <LucideDownload className="mr-2 h-4 w-4" />
                            Export Report
                        </Button>
                    </div>
                }
            />

            {/* 2. Top KPI Layer */}
            <ProjectStats stats={kpi} />

            {/* 3. Middle Intelligence Layer */}
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                {/* Trend Chart (2/3 width) */}
                <div className="lg:col-span-2">
                    <ProjectTrendChart data={chartData} />
                </div>

                {/* Quick Activity Feed (1/3 width) */}
                <div className="bg-card border border-border rounded-xl shadow-sm p-6 flex flex-col h-[425px]">
                    <h3 className="font-semibold mb-4 text-foreground">Recent Activity</h3>
                    <div className="flex-1 overflow-y-auto pr-2 space-y-6">
                        {/* Mock Feed Items */}
                        {[1, 2, 3, 4].map((i) => (
                            <div key={i} className="flex gap-4 relative">
                                {/* Timeline Line */}
                                {i !== 4 && <div className="absolute left-[11px] top-8 bottom-[-24px] w-[2px] bg-border" />}
                                
                                <div className="relative z-10 w-6 h-6 rounded-full bg-blue-100 flex items-center justify-center shrink-0">
                                    <div className="w-2 h-2 bg-blue-600 rounded-full" />
                                </div>
                                <div>
                                    <p className="text-sm font-medium text-foreground">Critical Crack Detected</p>
                                    <p className="text-xs text-muted-foreground mb-1">Inspection #{1000 + i} • 2 hours ago</p>
                                    <p className="text-xs text-slate-600 dark:text-slate-400 bg-muted p-2 rounded">
                                        AI detected a 5mm spalling crack on the North Facade.
                                    </p>
                                </div>
                            </div>
                        ))}
                    </div>
                    <Button variant="ghost" size="sm" className="w-full mt-4 text-xs">
                        View All Activity
                    </Button>
                </div>
            </div>

            {/* Bottom Data Layer */}
            <div className="mt-4">
                <div className="flex items-center justify-between mb-4">
                    <h3 className="text-xl font-semibold tracking-tight">Inspection Flight Logs</h3>
                </div>
                <div className="rounded-xl border border-border bg-card shadow-sm overflow-hidden">
                    <Suspense fallback={<div className="p-8"><Spinner /></div>}>
                        <InspectionList userId="" projectId={projectId} canDelete={permissions.canDeleteInspection} />
                    </Suspense>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { NuqsAdapter } from 'nuqs/adapters/next/app'

import Header from "@/app/(saas)/_navigation/header";
import { ThemeProvider } from "@/components/theme/theme-provider";
import { Toaster } from "@/components/ui/sonner";
import { Sidebar } from "@/app/(saas)/_navigation/sidebar/components/sidebar";
import ReactQueryProvider from "@/app/(saas)/_providers/react-query/react-query-provider";
import Script from "next/script";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Ai4Safety",
  description: "Generated by NextJS",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html suppressHydrationWarning lang="en">
      {/* <head>
        <Script
          id="cesium-widgets-css"
          strategy="beforeInteractive"
        >{`
          const link = document.createElement('link');
          link.rel = 'stylesheet';
          link.href = '/cesium/Widgets/widgets.css';
          document.head.appendChild(link);
        `}</Script>
      </head> */}
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
      <NuqsAdapter>
      <ThemeProvider>
      <ReactQueryProvider>
          {children}
        <Toaster expand />
      </ReactQueryProvider>
      </ThemeProvider>
      </NuqsAdapter>
      </body>
    </html>
  );
}
</file>

<file path="src/features/analysis/components/analysis_3d_viewer.tsx">
'use client'

import { useState } from "react";
import CesiumWrapper from "@/components/3D_Viewer/CesiumWrapper";
import { Detection } from "@prisma/client";
import { DetectionUpsertForm } from "@/features/defects/components/defect-form-upsert";
import { DefectCandidate } from "@/components/3D_Viewer/hooks/use-drawing-manager";
import { Entity } from "cesium";
import { useRouter } from "next/navigation";
import { MapLayer } from "@/components/3D_Viewer/types/map";
// Removed Portal import

type AnalaysisProps= {
  proxyBaseUrl:string;
  camerasUrl:string;
  tilesetUrl:string;
  inspectionId:string;
  initialDetections: Detection[];
  focusedDefectId?: string | null;
  canDeleteDefect: boolean;
  canEditDefect: boolean;
  onDefectSelected?: (defect: Detection) => void;
  layers: MapLayer[];
  onDefectDetected?: (candidate: DefectCandidate, tempEntities: any[])=> void;
}

export const Analysis3DViewer = ({ proxyBaseUrl,camerasUrl,tilesetUrl, inspectionId, initialDetections,
     focusedDefectId, canDeleteDefect, 
     canEditDefect, onDefectSelected,layers, onDefectDetected }: AnalaysisProps) => {
    const router = useRouter();
    
    const [defectCandidate, setDefectCandidate] = useState<DefectCandidate | null>(null);
    const [tempEntities, setTempEntities] = useState<Entity[]>([]); 
    const [editingDefect, setEditingDefect] = useState<Detection | null>(null);
    const [defectToEditImage, setDefectToEditImage] = useState<Detection | null>(null);

    // Handler passed to the form
    const handleOpenImageEdit = (defect: Detection) => {
        setDefectToEditImage(defect);
    };

    const handleDefectDetected = (candidate: DefectCandidate, entities: Entity[]) => {
        //setDefectCandidate(candidate);
        
        //setTempEntities(entities);
        if (onDefectDetected) {
            onDefectDetected(candidate, []);
        }
        setEditingDefect(null); 
    };

    const handleDefectSelected = (defect: Detection) => {
            if (onDefectSelected) {
                // New Architecture: Notify parent to open the Side Panel
                onDefectSelected(defect);
                
                // We clear the local editingDefect so we don't show the duplicate floating form
                setEditingDefect(null);
            } else {
                // Old Architecture: Show floating form inside viewer (fallback)
                setEditingDefect(defect);
            }
            setDefectCandidate(null); 
    };

    const handleFormSuccess = () => {
        setDefectCandidate(null);
        setEditingDefect(null);
        setTempEntities([]); 
        router.refresh();
    };

    const handleFormCancel = () => {
        setDefectCandidate(null);
        setEditingDefect(null);
    };

        // Common style for both forms 
    const formContainerStyle = "absolute top-2 right-2 z-[3000] w-80 md:w-96 bg-white dark:bg-slate-900 rounded-lg shadow-2xl border border-slate-200 dark:border-slate-700 flex flex-col max-h-[calc(100%-1rem)]";


    return (
        <div className="relative w-full h-full overflow-hidden">
            <CesiumWrapper
                proxyBaseUrl={proxyBaseUrl}
                camerasUrl={camerasUrl}
                tilesetUrl={tilesetUrl}
                inspectionId={inspectionId}
                initialDetections={initialDetections}
                onDefectDetected={handleDefectDetected}
                onDefectSelected={handleDefectSelected}
                focusedDefectId={focusedDefectId}
                layers={layers}
                defectToEditImage={defectToEditImage}
                onCloseImageEdit={() => setDefectToEditImage(null)} showTileset={false} showDefects={false} 
                onToggleTileset={function (): void {
                    throw new Error("Function not implemented.");
                } } 
                onToggleDefects={function (): void {
                    throw new Error("Function not implemented.");
                } }                
                >
                {/* Children rendered INSIDE the fullscreen div */}
                
                {/* Form for CREATING a new defect */}
                 {/* {defectCandidate && (
                    // Added 'pointer-events-auto' to ensure interactions work if parent has 'pointer-events-none'
                    <div className={formContainerStyle}>
                        <div className="p-4 overflow-y-auto flex-1 overscroll-contain">
                            <DetectionUpsertForm
                                inspectionId={inspectionId}
                                geometry={{
                                    type: defectCandidate.type,
                                    coordinates: defectCandidate.positions.map((pos: any) => ({ 
                                        x: pos.x, y: pos.y, z: pos.z 
                                    })),
                                    measurement: defectCandidate.measurement,
                                    
                                    annotation2D: defectCandidate.annotation2D, 
                                    sourceImageId: defectCandidate.sourceImageId,
                                    
                                    labelPosition: defectCandidate.labelPosition ? {
                                        x: defectCandidate.labelPosition.x,
                                        y: defectCandidate.labelPosition.y,
                                        z: defectCandidate.labelPosition.z
                                    } : undefined 
                                }}
                                onCancel={handleFormCancel}
                                onFormSuccess={handleFormSuccess}
                                canDelete={canDeleteDefect}
                                canEdit= {canEditDefect}
                                onOpenImage={handleOpenImageEdit}
                            />
                        </div>
                    </div>
                )} */}

                {/* Form for EDITING an existing defect */}
                {/* {editingDefect && !onDefectSelected && (
                    <div className={formContainerStyle}>
                        <div className="p-4 overflow-y-auto flex-1 overscroll-contain">
                            <DetectionUpsertForm
                                detection={editingDefect}
                                inspectionId={inspectionId}
                                onCancel={handleFormCancel}
                                onFormSuccess={handleFormSuccess}
                                canDelete={canDeleteDefect}
                                canEdit= {canEditDefect}
                                onOpenImage={handleOpenImageEdit}
                            />
                        </div>
                    </div>
                )}  */}
            </CesiumWrapper>
        </div>
    )
}
</file>

<file path="src/features/constants.tsx">
// import { CircleCheck, 
//     FileText, 
//     Pencil,
//     AlertTriangle, 
//     Droplets, 
//     Activity, 
//     HelpCircle, 
//     Search,
//     AlertOctagon,
//     AlertCircle,
//     CheckCircle2, 
//     DamIcon
// } from 'lucide-react';

// export const ProjectsIcn = {
//     ACTIVE: <FileText /> ,
//     ON_HOLD: <Pencil />,
//     COMPLETED: <CircleCheck />,
//     ARCHIVED: <Pencil />,
// };

// export const ProjectStatusLabels = {
//     ACTIVE: 'ACTIVE',
//     ON_HOLD: 'ON_HOLD',
//     COMPLETED: 'COMPLETED',
//     ARCHIVED: 'ARCHIVED',
// }

// export const TicketsIcn = {
//     Open: <FileText /> ,
//     IN_PROGRESS: <Pencil />,
//     Done: <CircleCheck />
// };

// export const TicketStatusLabels = {
//     Open: 'Open',
//     IN_PROGRESS: 'IN_PROGRESS',
//     Done: 'Done'
// }


// // Import actual Enums from Prisma if available, or define matching types
// import { DetectionType, DetectionSeverity, DetectionStatus } from "@prisma/client";

// export const DETECTION_TYPES = [
//   {
//     value:  DetectionType.SPALLING_CRACK, // Matches Prisma DetectionType.CRACK
//     label: "CRACK",
//     icon: Activity,
//   },
//   {
//     value: DetectionType.EFFLORESCENCE, // Matches Prisma DetectionType.RUST
//     label: "EFFLORESCENCE",
//     icon: Droplets,
//   },
//   {
//     value: DetectionType.WATER_DAMAGE,
//     label: "WATER DAMAGE",
//     icon: AlertTriangle,
//   },
//   {
//     value: DetectionType.CORROSION_STAIN,
//     label: "CORROSION STAIN",
//     icon: HelpCircle,
//   },
//   {
//     value: DetectionType.INSULATION_FAULT,
//     label: "INSULATION FAULT",
//     icon: DamIcon,
//   }
// ];

// export const SEVERITIES = [
//   {
//     value: DetectionSeverity.CRITICAL,
//     label: "CRITICAL",
//     icon: AlertOctagon,
//   },
//   {
//     value: DetectionSeverity.HIGH,
//     label: "HIGH",
//     icon: AlertCircle,
//   },
//   {
//     value: DetectionSeverity.MEDIUM,
//     label: "MEDIUM",
//     icon: AlertTriangle,
//   },
//   {
//     value: DetectionSeverity.LOW,
//     label: "LOW",
//     icon: CheckCircle2,
//   },
// ];

// export const STATUSES = [
//   {
//     value: DetectionStatus.NEW,
//     label: "NEW",
//     icon: HelpCircle,
//   },
//   {
//     value: DetectionStatus.IN_PROGRESS,
//     label: "IN PROGRESS",
//     icon: Activity,
//   },
//   {
//     value: DetectionStatus.ACKNOWLEDGED,
//     label: "ACKNOWLEDGED",
//     icon: Search,
//   },
//   {
//     value: DetectionStatus.RESOLVED,
//     label: "RESOLVED",
//     icon: CheckCircle2,
//   },
// ];

import { 
    CircleCheck, 
    FileText, 
    Pencil, // Keep for "Edit" buttons elsewhere, but don't use for status
    AlertTriangle, 
    Droplets, 
    Activity, 
    HelpCircle, 
    Search,
    AlertOctagon,
    AlertCircle,
    CheckCircle2, 
    Dam as DamIcon, // Renamed for clarity
    PauseCircle, // NEW: For On Hold
    Archive,     // NEW: For Archived
    PlayCircle,  // NEW: For Active
    Clock,       // NEW: For In Progress
    Flame        // NEW: For Fire/Critical visual variety
} from 'lucide-react';

// Import actual Enums from Prisma
import { DetectionType, DetectionSeverity, DetectionStatus } from "@prisma/client";

// =========================================================
// PROJECT CONFIGURATION
// =========================================================

// Combined config allows you to get Label, Icon, and Color from one key
export const PROJECT_STATUS_CONFIG = {
    ACTIVE: { 
        label: 'Active', 
        icon: PlayCircle, 
        color: 'text-green-600',
        bg: 'bg-green-100'
    },
    ON_HOLD: { 
        label: 'On Hold', 
        icon: PauseCircle, 
        color: 'text-orange-500',
        bg: 'bg-orange-100'
    },
    COMPLETED: { 
        label: 'Completed', 
        icon: CircleCheck, 
        color: 'text-blue-600',
        bg: 'bg-blue-100'
    },
    ARCHIVED: { 
        label: 'Archived', 
        icon: Archive, 
        color: 'text-gray-500',
        bg: 'bg-gray-100'
    },
};

// =========================================================
// DETECTION / ISSUE CONFIGURATION
// =========================================================

export const DETECTION_TYPES = [
  {
    value: DetectionType.SPALLING_CRACK,
    label: "Spalling Crack", // Title Case
    icon: Activity,
  },
  {
    value: DetectionType.EFFLORESCENCE,
    label: "Efflorescence",
    icon: Droplets,
  },
  {
    value: DetectionType.WATER_DAMAGE,
    label: "Water Damage",
    icon: Droplets, // Changed from Triangle to Droplets for context
  },
  {
    value: DetectionType.CORROSION_STAIN,
    label: "Corrosion Stain",
    icon: AlertTriangle,
  },
  {
    value: DetectionType.INSULATION_FAULT,
    label: "Insulation Fault",
    icon: DamIcon,
  }
];

export const SEVERITIES = [
  {
    value: DetectionSeverity.CRITICAL,
    label: "Critical",
    icon: AlertOctagon,
    color: "text-red-600",
    bg: "bg-red-100" // Background color for badges
  },
  {
    value: DetectionSeverity.HIGH,
    label: "High",
    icon: AlertCircle,
    color: "text-orange-600",
    bg: "bg-orange-100"
  },
  {
    value: DetectionSeverity.MEDIUM,
    label: "Medium",
    icon: AlertTriangle,
    color: "text-yellow-600",
    bg: "bg-yellow-100"
  },
  {
    value: DetectionSeverity.LOW,
    label: "Low",
    icon: CheckCircle2,
    color: "text-slate-600",
    bg: "bg-slate-100"
  },
];

export const STATUSES = [
  {
    value: DetectionStatus.NEW,
    label: "New",
    icon: HelpCircle,
    color: "text-blue-500"
  },
  {
    value: DetectionStatus.IN_PROGRESS,
    label: "In Progress",
    icon: Activity, // Activity implies work being done
    color: "text-orange-500"
  },
  {
    value: DetectionStatus.ACKNOWLEDGED,
    label: "Acknowledged",
    icon: Search, // Search implies investigation
    color: "text-indigo-500"
  },
  {
    value: DetectionStatus.RESOLVED,
    label: "Resolved",
    icon: CheckCircle2,
    color: "text-green-600"
  },
];
</file>

<file path="src/features/membership/components/membership-list.tsx">
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { format } from "date-fns";
import { LucideBan, LucideCheck } from "lucide-react";
import { getMemberships } from "../queries/get-memberships";
import { MembershipDeleteButton } from "./membership-delete-button";
import { MembershipMoreMenu } from "./membership-more-menu";
import {PermissionToggle} from './permission-toggle';
import { Badge } from "@/components/ui/badge";
import { PermissionManager } from "./permission-manager";

type MembershipListPageProp = {
    organizationId: string;
}
export const MembershipList = async({organizationId}:MembershipListPageProp) => {
    const memberships = await getMemberships(organizationId);
    if (!Array.isArray(memberships)) {
            return (
            <div className="text-sm text-destructive">
                {memberships.message}
            </div>
            );
        }
    
    return ( 
        <Table>
            <TableHeader>
                <TableRow>
                    <TableHead>Username</TableHead>
                    <TableHead>Email</TableHead>
                    <TableHead>Joined At</TableHead>
                    <TableHead>Verifed Email</TableHead>
                    <TableHead>Role</TableHead>
                    <TableHead >Permissions</TableHead>
                </TableRow>
            </TableHeader>

            <TableBody>
                {memberships.map((membership)=>{
                    const isAdmin = membership.membershipRole === 'ADMIN';
                    const membershipMoreMenu= (
                        <MembershipMoreMenu
                            organizationId= {membership.organizationId}
                            userId= {membership.userId}
                            membershipRole= {membership.membershipRole}
                        />
                    )
                    const deleteButton= (
                        <MembershipDeleteButton 
                            organizationId= {membership.organizationId}
                            userId= {membership.userId}
                        />
                    )
                    // {membershipMoreMenu}
                    const buttons= <>
                                    {deleteButton}</>;
                    return(
                        <TableRow key={membership.userId} >
                            <TableCell>{membership.user.username}</TableCell>
                            <TableCell>{membership.user.email}</TableCell>
                            <TableCell>
                                {format(membership.joinedAt , "yyyy-MM-dd, HH:mm")}
                            </TableCell>
                            <TableCell>
                                {membership.user.emailVerified ? (
                                    <LucideCheck className="h-4 w-4" />
                                ): (
                                    <LucideBan className="h-4 w-4" />
                                )}
                            </TableCell>
                            <TableCell>                                
                                <Badge variant={isAdmin ? "default" : "secondary"}>
                                    {membership.membershipRole}
                                </Badge>
                            </TableCell>
                            <TableCell>
                                {/* <PermissionToggle
                                    userId={membership.userId}
                                    organizationId={membership.organizationId}
                                    permissionKey="canDeleteProject"
                                    permissionValue= {membership.canDeleteProject}
                                /> */}
                                {isAdmin ? (
                                    <span className="text-xs text-muted-foreground italic">
                                        Full Access
                                    </span>
                                ) : (
                                    <PermissionManager 
                                        membership={membership}
                                        isAdmin={isAdmin}
                                    />
                                )}
                            </TableCell>
                            <TableCell className="flex justify-end gap-x-2">
                                {buttons}
                            </TableCell>
                        </TableRow>
                    );
                })}
            </TableBody>
        </Table>
     );
}
</file>

<file path="src/features/project/actions/upsert-project.ts">
'use server';
import {  setCookieByKey } from '@/actions/cookies';
import {formErrorToActionState, ActionState, toActionState} from '@/components/forms/utils/to-action-state';
import {prisma} from '@/lib/prisma';
import { projectPath,  projectsPath } from '@/path';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';

import {z} from 'zod';
import { getAuthOrRedirect } from '@/features/auth/queries/get-auth-or-rerdirect';
import { IsOwner } from '@/features/auth/utils/is-owner';
import { getProjectPermissions } from '../permissions/get-project-permissions';


const UpsertProjectSchema= z.object({
    name:z.string().min(1).max(100),
    description: z.string().min(1).max(1024),
    //updatedAt: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Is required"),
    address: z.string().min(1).max(100),
});


const UpsertProject = async (id: string | undefined,
    _actionStat:ActionState ,
    formData: FormData) =>{
    const {user, activeOrganization}= await getAuthOrRedirect()
    if (!user || !activeOrganization) {
        return toActionState('Error', 'Not Authenticated');
    }
    
    try{
        if(id){
            const permissions = await getProjectPermissions({
                        userId: user.id,
                        organizationId: activeOrganization.id
            });
            
            if(!permissions.canEditProject){
                        return toActionState('Error', 'Not authorized');
            };
            const project = await prisma.project.findUnique({
                where: {
                    id,
                }
            });

            if(!project || !IsOwner(user, project)){
                return toActionState('Error', 'Not authorized');
            }
        }
        const data= UpsertProjectSchema.parse({
            name: formData.get('name') ,
            description: formData.get('description') ,
            //updatedAt: formData.get("deadline") ,
            address: formData.get("address")   ,
        });

        const dbdata= {
            ...data,
            creatorId: user.id,
            //bounty: toCent(data.bounty)
        }

        await prisma.project.upsert({
            where:{
                id: id || ""
            },
            update: dbdata,
            create: {...dbdata, organizationId: activeOrganization!.id,},

        });
    }catch (error){
        return formErrorToActionState(error, formData);
    }


    revalidatePath(projectsPath());

    await setCookieByKey(
    "toast",
    id ? "Project Updated!" : "Project Created!"
    );

    return toActionState(
    "Success",
    id ? "Project Updated" : "Project Created"
    );
};

export {UpsertProject};
</file>

<file path="src/features/project/components/project-item.tsx">
"use client";

import { clsx } from 'clsx';
import { projectEditPath, projectPath } from '@/path';
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardFooter,
} from "@/components/ui/card";

import Link from 'next/link';

import { 
  LucideMoreVertical, 
  LucidePencil, 
  LucideSquareArrowOutUpRight,
  Calendar, 
  User,     
  MapPin    
} from 'lucide-react';

import { Button } from '@/components/ui/button';

import { PROJECT_STATUS_CONFIG } from '@/features/constants'; 
import { ProjectMoreMenu } from './project-more-menu';
import React, { Suspense } from 'react';
import { Skeleton } from '@/components/ui/skeleton';
import { ProjectWithMetadata } from '../types';
import { format } from 'date-fns';

type ProjectItemProps = {
  project: ProjectWithMetadata;
  isDetail?: boolean;
  attachments?: React.ReactNode;
  referencedInspections?: React.ReactNode;
  comments?: React.ReactNode;
  canEdit: boolean;
  canDelete: boolean;
}

export const ProjectItem = ({ 
  project, 
  isDetail, 
  attachments, 
  referencedInspections, 
  comments 
}: ProjectItemProps) => {

  // 1. GET STATUS CONFIG
  const statusConfig = PROJECT_STATUS_CONFIG[project.status];
  const StatusIcon = statusConfig.icon;

  const detailButton = (
    <Button asChild variant='outline' size='icon' className="h-8 w-8">
      <Link prefetch href={projectPath(project.id)}>
        <LucideSquareArrowOutUpRight className='h-4 w-4 text-muted-foreground' />
      </Link>
    </Button>
  );

  const editButton = project.isOwner ? (
    <Button variant="outline" size='icon' className="h-8 w-8" asChild>
      <Link href={projectEditPath(project.id)}>
        <LucidePencil className='w-4 h-4 text-muted-foreground' />
      </Link>
    </Button>
  ) : null;

  const moreMenu = project.isOwner ? (
    <ProjectMoreMenu 
      project={project} 
      trigger={
        <Button variant='outline' size='icon' className="h-8 w-8">
          <LucideMoreVertical className="h-4 w-4 text-muted-foreground" />
        </Button>
      } 
    />
  ) : null;

  return (
    <div className={clsx('w-full flex flex-col gap-y-4 transition-all', {
      'max-w-[800px]': isDetail, // Widen detail view slightly
      'max-w-[420px]': !isDetail,
    })}>
      
      <div className='flex gap-x-2 items-start'>
        <Card className='w-full flex-1 hover:shadow-md transition-shadow duration-200 border-muted/60'>
          
          <CardHeader className="pb-3">
            <CardTitle className='flex items-center gap-x-3 text-base font-semibold'>
              {/* 2. DYNAMIC STATUS ICON */}
              <div className={clsx("p-2 rounded-full bg-opacity-10", statusConfig.bg)}>
                 <StatusIcon className={clsx("w-5 h-5", statusConfig.color)} />
              </div>
              
              <span className="truncate">{project.name}</span>
            </CardTitle>
          </CardHeader>

          <CardContent className="pb-3">
            <p className={clsx("text-sm text-muted-foreground whitespace-break-spaces leading-relaxed", {
              "line-clamp-2": !isDetail,
            })}>
              {project.description}
            </p>
          </CardContent>

          {/* 3. POLISHED METADATA FOOTER */}
          <CardFooter className="flex flex-col gap-y-2 pt-0 items-start">
            <div className="flex items-center gap-x-4 text-xs text-muted-foreground w-full">
              
              {/* Date & User Group */}
              <div className="flex items-center gap-x-1 shrink-0">
                 <Calendar className="w-3.5 h-3.5" />
                 <span>{format(new Date(project.updatedAt), 'MMM dd, yyyy')}</span>
              </div>
              
              <div className="flex items-center gap-x-1 shrink-0">
                 <User className="w-3.5 h-3.5" />
                 <span className="max-w-[100px] truncate">{project.user?.username || 'Unknown'}</span>
              </div>

            </div>

            {/* Address Line */}
            {project.address && (
               <div className="flex items-start gap-x-1 text-xs text-muted-foreground w-full">
                  <MapPin className="w-3.5 h-3.5 mt-0.5 shrink-0" />
                  <span className="truncate">{project.address}</span>
               </div>
            )}
          </CardFooter>
        </Card>

        {/* Action Buttons Column */}
        <div className='flex flex-col gap-y-2 shrink-0'>
          {isDetail ? (
            <> {editButton} {moreMenu} </>
          ) : (
            <> {detailButton} {moreMenu} </>
          )}
        </div>
      </div>

      {isDetail ? (
        <Suspense fallback={
          <div className='flex flex-col gap-y-4'>
            <Skeleton className='h-[250px] w-full rounded-lg' />
            <div className="flex gap-4">
               <Skeleton className='h-20 w-1/2 rounded-lg' />
               <Skeleton className='h-20 w-1/2 rounded-lg' />
            </div>
          </div>
        }>
          {attachments}
          {referencedInspections}
          {comments}
        </Suspense>
      ) : null}
    </div>
  );
}
</file>

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init


generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Organization {
  id String @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime? //  If this has a date, the org is "soft deleted"
  name String 
  stripeCustomerId String?

  memberships Membership[]
  invitations Invitation[]
  credentials Credential[]
  stripeCustomer StripeCustomer?

  projects Project[]
  auditLogs AuditLog[]

}

model StripeCustomer {
  organizationId     String             @unique
  organization       Organization       @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  customerId         String             @unique

  subscriptionId     String?
  subscriptionStatus StripeSubscriptionStatus?
  productId          String?
  priceId            String?
  eventAt            Int?
}

enum StripeSubscriptionStatus {
  active
  incomplete
  incomplete_expired
  past_due
  canceled
  unpaid
  trialing
  paused
}

model Credential {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  secretHash     String       @unique
  name           String
  lastUsed       DateTime?
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  organizationId String

  @@index([organizationId])
}

model Invitation {
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email String
  tokenHash String @unique
  organizationId String
  organization Organization @relation(fields: [organizationId] ,references: [id], onDelete: Cascade )
  invitedByUserId String?
  invitedByUser User? @relation(fields: [invitedByUserId], references: [id], onDelete: SetNull)
  status InvitationStatus @default(PENDING)

  @@id(name: "invitationId", [organizationId, email])
  @@index([organizationId])
}

enum InvitationStatus {
  PENDING
  ACCEPTED_WITHOUT_ACCOUNT
}


model Membership {
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  organizationId String

  joinedAt DateTime @default(now())
  isActive Boolean
  membershipRole MembershipRole @default(MEMBER)

  //permissions
  canDeleteProject Boolean @default(false)
  canEditProject      Boolean @default(false)

  canDeleteInspection Boolean @default(false)
  canEditInspection   Boolean @default(false)

  canDeleteDefect Boolean @default(false)
  canEditDefect   Boolean @default(false)

  @@id(name: "MembershipId", [organizationId, userId])
  @@index([organizationId])
  @@index([userId])
}

enum MembershipRole {
  ADMIN
  MEMBER
}

model User {
  id              String        @id @default(cuid())
  username        String            @unique
  email           String            @unique
  emailVerified   Boolean           @default(false)
  passwordHash    String

    // --- ADD THESE FIELDS ---
  firstName       String?
  lastName        String?
  role            String?        
  //image           String?         
  // ------------------------

  sessions Session[]
  passwordResetTokens PasswordResetToken[]
  emailVerificationTokens EmailVerificationToken[]
  memberships Membership[]
  comments Comment[]
  invitesByUsers Invitation[]
  
  conductedInspections    Inspection[]            @relation("ConductedByUser")

  projects Project[]
  auditLogs AuditLog[]
  
}

model AuditLog {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  action      String   // e.g. "INSPECTION_APPROVED", "PROJECT_DELETED"
  entityType  String   // e.g. "Project", "Inspection"
  entityId    String   // The ID of the thing being changed
  
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  details     Json?    // Store what changed: { "oldStatus": "PENDING", "newStatus": "APPROVED" }

  @@index([organizationId])
  @@index([entityId])
}

model EmailVerificationToken {
  id String @id @default(cuid())
  createdAt DateTime @default(now())
  code String
  expiresAt DateTime
  email String
  userId String
  user User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model PasswordResetToken {
  tokenHash String @id
  expiresAt DateTime
  userId String
  user User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Session {
  id String @id
  expiresAt DateTime
  userId String
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])

}
        


model Comment{
  id String @id @default(cuid())
  createdAt DateTime @default(now())
  content String @db.VarChar(1024)
  
  userId String?
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)


  inspectionId String?
  inspection Inspection? @relation(fields: [inspectionId], references: [id], onDelete: Cascade)


  supplements Supplement[]

  @@index([inspectionId])
  @@index([userId])

}


model Project {
  id              String          @id @default(cuid())
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  deletedAt       DateTime?
  name            String
  address         String?
  metadata        Json?        // { "facade_type": "glass", "height_m": 120 }
  description     String?
  
  status          ProjectStatus   @default(ACTIVE) // <-- new field

  creatorId String?
  user User? @relation(fields: [creatorId], references: [id], onDelete:SetNull)

  // relationships
  organization    Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  organizationId  String

  inspections    Inspection[]

  @@index([creatorId])
  @@index([organizationId])

}


// An Inspection is a single inspection event for a Project on a specific date.
model Inspection {
  id                String           @id @default(cuid())
  title             String
  inspectionDate    DateTime
  status            InspectionStatus @default(SCHEDULED)
  weatherConditions Json?            // { "temp_c": 25, "wind_kph": 10 }
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  
  // Foreign Keys
  projectId         String
  conductedByUserId String ?

  // Relations
  project           Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  conductedByUser   User ?        @relation("ConductedByUser", fields: [conductedByUserId], references: [id], onDelete:SetNull)
  job               Job[]         // The background job for this inspection
  analysis          Analysis[]   // The analysis resulting from this inspection
  supplements       Supplement[] // Raw data like drone images
  comments          Comment[]

  referencedInspections Inspection[] @relation("InspectionReferences")
  referencingInspections Inspection[] @relation("InspectionReferences")

  @@index([projectId])
  @@index([conductedByUserId])
}




model Job {
  id          String        @id @default(cuid())
  createdAt   DateTime      @default(now())
  startedAt   DateTime?     
  completedAt DateTime?     
  type        AnalysisType
  status      JobStatus     @default(PENDING)
  logs        String?       @db.Text
  
  errorMessage String?      @db.Text //  Separate system logs from error output
  
  attemptCount Int          @default(0) //  Helps you retry failed jobs automatically

  // Foreign Keys
  inspectionId String       // Each inspection kicks off one primary job
  
  // Relations
  inspection   Inspection   @relation(fields: [inspectionId], references: [id], onDelete: Cascade)
  analysis     Analysis?

  @@index([inspectionId])
 
}


// An Analysis is the computational result derived from an Inspection's data.

model Analysis {
  id          String         @id @default(cuid())
  createdAt   DateTime       @default(now())
  summary     Json?        // { "total_detections": 150, "critical_issues": 12 }


  job     Job        @relation(fields: [jobId], references: [id], onDelete: Cascade)
  jobId   String @unique

  inspection   Inspection   @relation(fields: [inspectionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  inspectionId     String 
  detections       Detection[]
  supplements      Supplement[] // Output files like reports or 3D models

  @@index([inspectionId])
  @@index([jobId])
}


// A Detection is a single, structured finding from an Analysis (e.g., a specific crack).
model Detection {
  id                String            @id @default(cuid())
  createdAt         DateTime          @default(now())
  type              DetectionType?
  severity          DetectionSeverity?
  status            DetectionStatus?   @default(NEW)
  confidenceScore   Float?
  notes             String?           @db.Text
  locationOn3dModel Json?             // { "x": 12.3, "y": 45.6, "z": 78.9 }

  annotation2D     Json?
  sourceImageId    String?
  
  referencedDetections Detection[] @relation("DetectionReferences")
  referencingDetections Detection[] @relation("DetectionReferences")

  // Foreign Keys
  analysisId        String

  attachments     Supplement[]      @relation("DetectionAttachments")

  // Relations
  analysis          Analysis          @relation(fields: [analysisId], references: [id], onDelete: Cascade)
  images            DetectionOnImage[] // Many-to-many link to images

  @@index([analysisId])
}


// Junction table for the many-to-many relationship between Detections and Images (Supplements).
model DetectionOnImage {
  // Foreign Keys
  detectionId  String
  supplementId String
  supplementPath String

  // Data specific to this relationship
  boundingBox  Json?
  // STRICT FORMAT: [x, y, width, height] normalized (0.0 to 1.0)
  // Example: [0.5, 0.5, 0.1, 0.2] = Center of image, 10% width, 20% height

  // Relations
  detection    Detection  @relation(fields: [detectionId], references: [id], onDelete: Cascade)
  supplement   Supplement @relation(fields: [supplementId], references: [id], onDelete: Cascade)

  @@id([detectionId, supplementId])
}



model Supplement {
  id          String     @id @default(cuid())
  createdAt   DateTime   @default(now())
  name String
  //type        SupplementType
  entity      SupplementEntity
  url         String?     // S3 URL key path

  sizeMB    Float?
  format    String?   // jpg, tif, laz, etc.
  metadata  Json?     // EXIF, GPS, resolution, etc.



  inspection   Inspection? @relation(fields: [inspectionId], references: [id], onDelete: Cascade)
  inspectionId String?

  analysis     Analysis?    @relation(fields: [analysisId], references: [id], onDelete: Cascade)
  analysisId   String?

  comment   Comment?    @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId String?

  detection   Detection? @relation("DetectionAttachments", fields: [detectionId], references: [id], onDelete: Cascade)
  detectionId String?

  detections   DetectionOnImage[]

  @@index([inspectionId])
  @@index([analysisId])
  @@index([commentId])
  @@index([detectionId])

}

 enum SupplementType {
   DRONE_IMAGE
   ORTHOMOSAIC
   POINT_CLOUD
   THREE_D_MODEL
   INSPECTION_REPORT
   THERMAL_MAP
   AUDIO_NOTE
   EXPERT_FILE
 }

enum SupplementEntity {
  INSPECTION
  ANALYSIS
  COMMENT
  DETECTION
}

enum JobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum AnalysisType {
  THREE_D_MODELING
  CRACK_DETECTION
  THERMAL_ANALYSIS
}

enum ProjectStatus {
  ACTIVE
  ON_HOLD
  COMPLETED
  ARCHIVED
}

enum InspectionStatus {
  SCHEDULED
  IN_PROGRESS
  DATA_UPLOADING
  COMPLETED
  FAILED
}

enum AnalysisStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum DetectionType {
  SPALLING_CRACK
  EFFLORESCENCE
  WATER_DAMAGE
  CORROSION_STAIN
  INSULATION_FAULT
}

enum DetectionSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum DetectionStatus {
  NEW
  ACKNOWLEDGED
  IN_PROGRESS
  RESOLVED
}
</file>

<file path="src/components/3D_Viewer/CesiumWrapper.tsx">
'use client';

if (typeof window !== "undefined") {
            (window as any).CESIUM_BASE_URL = "/cesium";
        }


import dynamic from 'next/dynamic'
import React, { useEffect, useRef, useState } from 'react';
import { CesiumType } from './types/cesium';
import { Detection } from '@prisma/client';
//import { type Entity } from 'cesium';
import { DefectCandidate } from './hooks/use-drawing-manager';
import { Spinner } from '../spinner';
import { SeverityVisibility } from './components/layer-control'; 
import { MapLayer } from './types/map';

// Define props for the Dynamic Component
type CesiumEntity = any;
export interface CesiumComponentProps {
    CesiumJs: CesiumType;
    cesiumContainerRef: React.RefObject<HTMLDivElement | null> ;
    onFullscreenToggle?: () => void;
    isMapFullscreen?: boolean;
    proxyBaseUrl:string;
    camerasUrl: string;
    tilesetUrl: string;
    inspectionId: string;
    initialDetections: Detection[];

    // Event Handlers

    onDefectDetected?: (candidate: DefectCandidate, tempEntities: CesiumEntity[]) => void;
    onDefectSelected?: (defect: Detection) => void;
    focusedDefectId?: string | null;
    showTileset: boolean;
    onToggleTileset: () => void;
    
    severityVisibility: SeverityVisibility;
    onToggleSeverity: (key: keyof SeverityVisibility) => void;
    onToggleAllDefects: (show: boolean) => void;
    layers: MapLayer[];
    defectToEditImage: Detection | null;
    onCloseImageEdit: () => void;
}


const CesiumDynamicComponent = dynamic(() => import('./Cesium'), {
    ssr: false,
    loading: () => (
        <div className="flex h-full w-full items-center justify-center bg-slate-950">
            <div className="text-white text-center">
                <Spinner />
                <p className="mt-4 text-sm text-slate-400">Initializing 3D Engine...</p>
            </div>
        </div>
    )
});

type WrapperProps = {
 proxyBaseUrl:string;
  camerasUrl:string;
  tilesetUrl: string;
  layers: MapLayer[];
  inspectionId: string;
  initialDetections: Detection[];
  // Parent Listeners
  onDefectDetected?: (candidate: DefectCandidate, tempEntities: CesiumEntity[]) => void;
  onDefectSelected?: (defect: Detection) => void;
  focusedDefectId?: string | null;
  showTileset: boolean;
  showDefects: boolean;
  onToggleTileset: () => void;
  onToggleDefects: () => void;
  defectToEditImage: Detection | null; 
  onCloseImageEdit: () => void;
  children?: React.ReactNode; 
};

export const CesiumWrapper: React.FunctionComponent<WrapperProps> = ({
    proxyBaseUrl,
    camerasUrl,
    tilesetUrl, 
    layers,
    inspectionId, 
    initialDetections,
    onDefectDetected,
    onDefectSelected,
    focusedDefectId,
    defectToEditImage,
    onCloseImageEdit,
    children
}) => {
    const [CesiumJs, setCesiumJs] = useState<CesiumType | null>(null);
    const [isMapFullscreen, setIsMapFullscreen] = useState(false);
    const cesiumContainerRef = useRef<HTMLDivElement>(null); 
    const fullscreenWrapperRef = useRef<HTMLDivElement>(null);

    //  Layer Visibility State
    const [showTileset, setShowTileset] = useState(true);
    const [showDefects, setShowDefects] = useState(true);

    const [severityVisibility, setSeverityVisibility] = useState<SeverityVisibility>({
        CRITICAL: true,
        HIGH: true,
        MEDIUM: true,
        LOW: true,
    });

    const handleToggleSeverity = (severity: keyof SeverityVisibility) => {
        setSeverityVisibility(prev => ({
            ...prev,
            [severity]: !prev[severity]
        }));
    };

    const handleToggleAllDefects = (show: boolean) => {
        setSeverityVisibility({
            CRITICAL: show,
            HIGH: show,
            MEDIUM: show,
            LOW: show,
        });
    };

    
    useEffect(() => {
        if (CesiumJs !== null) return;

        import("cesium").then((Cesium) => {
            setCesiumJs(Cesium as CesiumType);
        });
    }, [CesiumJs]);


    const handleFullscreenToggle = () => {
        if (fullscreenWrapperRef.current) {
            if (!document.fullscreenElement) {
                fullscreenWrapperRef.current.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable full-screen mode: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }
    };

    useEffect(() => {
        const handleFullscreenChange = () => {
            setIsMapFullscreen(!!document.fullscreenElement);
        };
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        return () => {
            document.removeEventListener('fullscreenchange', handleFullscreenChange);
        };
    }, []);

    return (
        <div ref={fullscreenWrapperRef} className="relative w-full h-full bg-black" suppressHydrationWarning={true} >
            {CesiumJs ? (
                    <CesiumDynamicComponent
                        CesiumJs={CesiumJs}
                        cesiumContainerRef={cesiumContainerRef}
                        onFullscreenToggle={handleFullscreenToggle} 
                        isMapFullscreen={isMapFullscreen}
                        proxyBaseUrl={proxyBaseUrl}
                        camerasUrl={camerasUrl} 
                        tilesetUrl={tilesetUrl}
                        inspectionId={inspectionId}
                        initialDetections={initialDetections}
                        
                        onDefectDetected={onDefectDetected}
                        onDefectSelected={onDefectSelected}
                        focusedDefectId= {focusedDefectId}
                        
                        showTileset={showTileset}
                        onToggleTileset={() => setShowTileset(!showTileset)}
                        severityVisibility={severityVisibility}
                        onToggleSeverity={handleToggleSeverity}
                        onToggleAllDefects={handleToggleAllDefects}
                        layers={layers}
                        defectToEditImage={defectToEditImage}
                        onCloseImageEdit={onCloseImageEdit}
                    />
            ) : null}
            {children}
        </div>
    );
};

export default CesiumWrapper;
</file>

<file path="next.config.ts">
import path from 'path';
import process from 'process';
import CopyWebpackPlugin from 'copy-webpack-plugin';
import type { NextConfig } from 'next';
import type { Configuration } from 'webpack';
import webpack from 'webpack';

const pathBuilder = (subpath: string): string => path.join(process.cwd(), subpath);


const nextConfig: NextConfig = {
  reactStrictMode: false, 
  eslint: {
    ignoreDuringBuilds: true,
  },
  /* config options here */
  // experimental: {
  //   staleTimes: {
  //     dynamic:30,
  //   },
  // },
  experimental: {
    serverActions: {
      bodySizeLimit: '100000mb',
    },
  },

  images: {
    remotePatterns: [
          // local dev
      {
        protocol: 'http',
        hostname: 'localhost',
        port: '3000',
        pathname: '/**',
      },

      {
        protocol: 'https',
        // Allow all AWS S3 subdomains (e.g., your-bucket.s3.us-east-1.amazonaws.com)
        hostname: '**.amazonaws.com', 
      },
    ],
  },
  
  webpack: (config: Configuration, { isServer }) => {
      config.resolve = {
        ...config.resolve,
      };
    if (!isServer) {
      // 1. Define Cesium Base URL ONCE
      config.plugins!.push(
        new webpack.DefinePlugin({
          CESIUM_BASE_URL: JSON.stringify("/cesium"),
        })
      );

      // 2. Copy Cesium Assets to /public/cesium
      config.plugins!.push(
        new CopyWebpackPlugin({
          patterns: [
            {
              from: path.join(process.cwd(), "node_modules/cesium/Build/Cesium"),
              to: path.join(process.cwd(), "public/cesium"),
            },
          ],
        })
      );

      // 3. Fix Cesium Engine alias
      // config.resolve!.alias = {
      //   ...config.resolve!.alias,
      //   "@cesium/engine": path.resolve(
      //     process.cwd(),
      //     "node_modules/@cesium/engine/Source"
      //   ),
      // };
    }

    return config;
  },

//   webpack: (config: Configuration, { webpack , isServer }) => {

//         if (!isServer) {
//             // Define CESIUM_BASE_URL first
//             config.plugins!.push(
//                 new webpack.DefinePlugin({
//                     CESIUM_BASE_URL: JSON.stringify('/cesium')
//                 })
//             );


//         config.plugins!.push(
//             new CopyWebpackPlugin({
//                 patterns: [
//                     {
//                         from: pathBuilder('node_modules/cesium/Build/Cesium/Workers'),
//                         to: '../public/cesium/Workers',
//                         info: { minimized: true }
//                     }
//                 ]
//             }),
//             new CopyWebpackPlugin({
//                 patterns: [
//                     {
//                         from: pathBuilder('node_modules/cesium/Build/Cesium/ThirdParty'),
//                         to: '../public/cesium/ThirdParty',
//                         info: { minimized: true }
//                     }
//                 ]
//             }),
//             new CopyWebpackPlugin({
//                 patterns: [
//                     {
//                         from: pathBuilder('node_modules/cesium/Build/Cesium/Assets'),
//                         to: '../public/cesium/Assets',
//                         info: { minimized: true }
//                     }
//                 ]
//             }),
//             new CopyWebpackPlugin({
//                 patterns: [
//                     {
//                         from: pathBuilder('node_modules/cesium/Build/Cesium/Widgets'),
//                         to: '../public/cesium/Widgets',
//                         info: { minimized: true }
//                     }
//                 ]
//             }),
//             new webpack.DefinePlugin({ CESIUM_BASE_URL: JSON.stringify('/cesium') })
//         );


//             // Fix module resolution
//             config.resolve!.alias = {
//                 ...config.resolve!.alias,
//                 '@cesium/engine': path.resolve(__dirname, 'node_modules/@cesium/engine/Source')
//             };
            
//         }

//         return config;
//     },
  // reactStrictMode: true,
  // webpack: (
  //   config: Configuration,
  //   { isServer }: { isServer: boolean }
  // ) => {
  //   config.plugins?.push(
  //     new webpack.DefinePlugin({
  //       CESIUM_BASE_URL: JSON.stringify('cesium'),
  //     })
  //   );
  //   return config;
  // },
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "next-js-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "lint-fix": "next lint --fix",
    "type": "tsc --noEmit",
    "postinstall": "prisma generate",
    "prisma-seed": "tsx prisma/seed.ts",
    "stripe-seed": "tsx src/lib/stripe/seed.ts",
    "email": "email dev --dir src/emails"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.879.0",
    "@aws-sdk/s3-presigned-post": "^3.888.0",
    "@aws-sdk/s3-request-presigner": "^3.879.0",
    "@cesium/engine": "^22.0.0",
    "@cesium/widgets": "^14.0.0",
    "@giro3d/giro3d": "^0.43.5",
    "@node-rs/argon2": "^2.0.2",
    "@oslojs/crypto": "^1.0.1",
    "@oslojs/encoding": "^1.1.0",
    "@prisma/client": "^6.12.0",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.12",
    "@react-email/components": "^0.5.1",
    "@react-email/render": "^1.2.2",
    "@react-pdf/renderer": "^4.3.1",
    "@supabase/supabase-js": "^2.57.4",
    "@tanstack/react-query": "^5.85.5",
    "@tanstack/react-table": "^8.21.3",
    "@types/file-saver": "^2.0.7",
    "big.js": "^7.0.1",
    "cesium": "^1.135.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "fastest-levenshtein": "^1.0.16",
    "file-saver": "^2.0.5",
    "inngest": "^3.40.1",
    "linkify-react": "^4.3.2",
    "lucia": "^3.2.2",
    "lucide-react": "^0.525.0",
    "next": "15.4.1",
    "next-themes": "^0.4.6",
    "nuqs": "^2.4.3",
    "p-limit": "^7.2.0",
    "react": "19.1.0",
    "react-day-picker": "^9.8.1",
    "react-dom": "19.1.0",
    "react-intersection-observer": "^9.16.0",
    "react-resizable-panels": "^3.0.6",
    "recharts": "^3.5.1",
    "resend": "^6.0.1",
    "resium": "^1.19.1",
    "sonner": "^2.0.6",
    "stripe": "^18.5.0",
    "tailwind-merge": "^3.3.1",
    "use-debounce": "^10.0.5",
    "zod": "^4.0.10"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@react-email/preview-server": "^4.2.8",
    "@tailwindcss/postcss": "^4.1.17",
    "@types/big.js": "^6.2.2",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "copy-webpack-plugin": "^13.0.1",
    "eslint": "^9",
    "eslint-config-next": "15.4.1",
    "eslint-plugin-simple-import-sort": "^12.1.1",
    "prisma": "^6.12.0",
    "react-email": "^4.2.8",
    "supabase": "^2.40.7",
    "symlink-dir": "^9.0.0",
    "tailwindcss": "^4",
    "tsx": "^4.20.3",
    "tw-animate-css": "^1.3.5",
    "typescript": "^5"
  }
}
</file>

<file path="src/components/3D_Viewer/Cesium.tsx">
'use client'
import type { Entity, Cartesian3, Color } from "cesium";

import React, { useEffect, useRef, useState } from 'react';
// import { 
//     CustomDataSource,
//     Entity,
//     Viewer,
//     Cesium3DTileset,
//     Scene,
//     Cartesian3
// } from 'cesium';

import { CesiumType } from './types/cesium';
import { basemapsLayers } from './imagery_basemaps';
import { autoAlignTileset } from './auto-align-tileset';
import { Button } from '../ui/button';
import { Pencil, Square, Trash2, Hand, LucideFullscreen, X, TriangleAlert } from 'lucide-react';
import { DefectCandidate, useDrawingManager } from './hooks/use-drawing-manager';
import { CesiumComponentProps } from './CesiumWrapper';
import { LayerControl, SeverityVisibility } from './components/layer-control';
import { DefectSearch } from './components/defect-search';
import { getOrientationFromRodrigues} from './get-Orientation-From-Rodrigues';
import 'cesium/Build/Cesium/Widgets/widgets.css';
import Image from 'next/image';
import { ImageViewerModal } from '../image-viewer-modal';
import { getCameraPositionECEF, getRayFromPixel, intersectRayWithTileset, rodriguesToMatrix, snapPointToTileset } from './get-Ray-From-Pixel';
import { debugCameraProjection } from './debug-projection';
import { intersectRayWithPlane, setCesiumCameraToDrone } from './utils/intersection-utils';
import { findBestCamera, getSurfaceNormal } from './utils/camera-math';
//import "@cesium/widgets/styles.css";

const triangleAlertSvg = `data:image/svg+xml,${encodeURIComponent(`
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
    <path d="M12 9v4"/>
    <path d="M12 17h.01"/>
  </svg>
`)}`;

// Helper to extract Camera Context from the Cesium Entity
const getCameraContext = (entity: InstanceType<typeof CesiumJs.Entity> | null, CesiumJs: CesiumType) => {
    if (!entity) return undefined;
    
    // Get time-based values
    const time = CesiumJs.JulianDate.now();
    const position = entity.position?.getValue(time);
    const orientation = entity.orientation?.getValue(time);
    
    // Get custom properties we stored earlier
    // Note: In your code, you stored intrinsics in 'cameraData' property
    const camData = entity.properties?.getValue(time)?.cameraData;

    if (!position || !orientation || !camData) return undefined;

    return {
        position: { x: position.x, y: position.y, z: position.z },
        orientation: { x: orientation.x, y: orientation.y, z: orientation.z, w: orientation.w },
        intrinsics: {
            width: camData.width,
            height: camData.height,
            focal: camData.focal 
        }
    };
};

const getSeverityColor = (CesiumJs: CesiumType, severity: string) => {
    switch (severity) {
        case 'CRITICAL':
            return CesiumJs.Color.RED;
        case 'HIGH':
            return CesiumJs.Color.ORANGE;
        case 'MEDIUM':
            return CesiumJs.Color.YELLOW;
        case 'LOW':
            return CesiumJs.Color.LIME; // or CYAN
        default:
            return CesiumJs.Color.WHITE; // Fallback
    }
};

export const CesiumComponent: React.FunctionComponent<CesiumComponentProps> = ({
    CesiumJs,
    cesiumContainerRef,
    onFullscreenToggle,
    isMapFullscreen,
    proxyBaseUrl,
    camerasUrl,  
    tilesetUrl, 
    initialDetections,
    onDefectDetected,
    onDefectSelected, 
    focusedDefectId,
    showTileset,
    
    onToggleTileset,
    severityVisibility,
    onToggleSeverity,
    onToggleAllDefects,
    defectToEditImage,
    onCloseImageEdit
    
}) => {
    
    // Fix global variable assignment
    // if (typeof window !== 'undefined') {
    //     (window as any).CESIUM_BASE_URL = '/cesium';
    // };

    // useEffect(() => {
    //     (window as any).CESIUM_BASE_URL = '/cesium';
    // }, [])

    const cesiumViewer = useRef<any | null>(null);
    const defectsDataSourceRef = useRef<any | null>(null);
    const camerasDataSourceRef = useRef<any | null>(null);
    
    const addedScenePrimitives = useRef<any[]>([]);
    const currentTilesetRef = useRef<any | null>(null);
    const isLoaded = useRef(false);
    const [viewerReady, setViewerReady] = useState(false);
    const [selectedImage, setSelectedImage] = useState<string | null>(null);
    const selectedCameraEntity = useRef<any | null>(null);
    const localToWorldTransformRef = useRef<any>(null);
    const [temp3DLocation, setTemp3DLocation] = useState<any | null>(null);


    const { 
        drawingMode, 
        startDrawing,
        stopDrawing, 
        clearActiveDrawing 
    } = useDrawingManager({
        CesiumJs,
        viewerRef: cesiumViewer,
        onShapeCreated: (candidate, entities) => {
            if (onDefectDetected) {
                onDefectDetected(candidate, entities);
            }
        }
    });

    const parseCameraModel = (cameraString: string) => {
        // Example: "v2 dji fc330 4000 3000 brown 0.5555"
        const parts = cameraString.split(' ');
        
        return {
            version: parts[0],
            make: parts[1],
            model: parts[2],
            width: parseInt(parts[3]) || 4000,
            height: parseInt(parts[4]) || 3000,
            distortionModel: parts[5] || 'brown',
            // The last number is often the focal ratio or first distortion param
            k1: parseFloat(parts[6]) || 0,
            k2: 0, // Would need to get from cameras.json if available
        };
    };

    // ---------------------------------------------------------------------------
    //   LOAD CAMERAS (Icons + Drop Lines)
    // ---------------------------------------------------------------------------
    useEffect(() => {
        if (!camerasUrl || !viewerReady || !cesiumViewer.current) return;

        const loadCameras = async () => {
            try {
                const response = await fetch(camerasUrl);
                if (!response.ok) return;
                const data = await response.json();

                if (!camerasDataSourceRef.current) {
                    const ds = new CesiumJs.CustomDataSource("drone-cameras");
                    cesiumViewer.current!.dataSources.add(ds);
                    camerasDataSourceRef.current = ds;
                }

                const dataSource = camerasDataSourceRef.current;
                dataSource.entities.removeAll();

                // Compute the local-to-ECEF transform using the first camera as reference
                if (data.features.length > 0) {
                    const firstFeature = data.features[0];
                    const [refLon, refLat, refAlt] = firstFeature.geometry.coordinates;
                    
                    // Create ENU frame at reference point
                    const refCartesian = CesiumJs.Cartesian3.fromDegrees(refLon, refLat, 0);
                    localToWorldTransformRef.current = CesiumJs.Transforms.eastNorthUpToFixedFrame(refCartesian);
                }


                // Load a camera icon (You can use a local asset or a base64 string)
                // Using a standard map pin style for now, or ensure you have /camera-icon.png in public folder
                const cameraIconUrl = "https://cdn-icons-png.flaticon.com/512/3687/3687416.png"; 

                data.features.forEach((feature: any) => {
                    const [lon, lat, alt] = feature.geometry.coordinates;
                    const props = feature.properties;
                    const filename = feature.properties.filename;
                    
                    const position = CesiumJs.Cartesian3.fromDegrees(lon, lat, alt);
                    const groundPosition = CesiumJs.Cartesian3.fromDegrees(lon, lat, 0); // Ground level anchor

                    const cameraModel = parseCameraModel(props.camera);

                    // Store complete camera data for projection
                    const cameraData = {
                        filename: props.filename,
                        focal: props.focal,
                        width: props.width || cameraModel.width,
                        height: props.height || cameraModel.height,
                        k1: cameraModel.k1 || 0,
                        k2: cameraModel.k2 || 0,
                        translation: props.translation,
                        rotation: props.rotation,
                        gpsPosition: { lon, lat, alt }
                    };

                    //const rotationVector = feature.properties.rotation; 
                  
                    const orientation = getOrientationFromRodrigues(CesiumJs, props.rotation);

                    dataSource.entities.add({
                        position: position,
                        orientation: orientation,
                        
                        // 1. The Camera Icon (Billboard)
                        billboard: {
                            image: cameraIconUrl,
                            scale: 0.06, 
                            color: CesiumJs.Color.WHITE, 
                            verticalOrigin: CesiumJs.VerticalOrigin.BOTTOM,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY, 
                            heightReference: CesiumJs.HeightReference.NONE,
                            alignedAxis: CesiumJs.Cartesian3.UNIT_Z, 
                            rotation: 0,
                        },

                        // 2. The "Drop Line" (Anchor to ground) - Helps depth perception
                        polyline: {
                            positions: [position, groundPosition],
                            width: 1,
                            material: new CesiumJs.ColorMaterialProperty(
                                CesiumJs.Color.WHITE.withAlpha(0.4)
                            ),
                            distanceDisplayCondition: new CesiumJs.DistanceDisplayCondition(0.0, 200.0)
                        },

                        // Metadata
                        properties: {
                            type: 'camera-point',
                            filename: filename,
                            cameraData: cameraData,
                            rawData: feature.properties,
                            exactPosition: { lon, lat, alt }
                        }
                    });
                });

            } catch (error) {
                console.error("Error loading cameras:", error);
            }
        };

        loadCameras();

        return () => {
            if (cesiumViewer.current && camerasDataSourceRef.current) {
                cesiumViewer.current.dataSources.remove(camerasDataSourceRef.current);
                camerasDataSourceRef.current = null;
            }
        };
    }, [camerasUrl, viewerReady, CesiumJs]);


    // ---------------------------------------------------------------------------
    //  CLICK HANDLER 
    // ---------------------------------------------------------------------------
    useEffect(() => {
        if (!cesiumViewer.current) return;
        
        const handler = new CesiumJs.ScreenSpaceEventHandler(cesiumViewer.current.scene.canvas);
        
        handler.setInputAction((click: any) => {
            if (drawingMode !== 'none') return;

            const scene = cesiumViewer.current!.scene;
            const pickedObject = cesiumViewer.current!.scene.pick(click.position);
            
            if (CesiumJs.defined(pickedObject) && pickedObject.id instanceof CesiumJs.Entity) {
                const entity = pickedObject.id;

                // CASE A: Defect Selected
                if (entity.properties && entity.properties.hasProperty('detectionData')) {
                    const currentTime = cesiumViewer.current!.clock.currentTime;
                    const defectData = entity.properties.getValue(currentTime)['detectionData'];
                    if (onDefectSelected && defectData) {
                        onDefectSelected(defectData);
                    }
                }
                
                // CASE B: Camera Selected
                else if (entity.properties && entity.properties.hasProperty('type') &&
                        entity.properties.getValue(CesiumJs.JulianDate.now()).type === 'camera-point') {
                    
                    // --- A. RESET PREVIOUS ---
                    if (selectedCameraEntity.current) {
                        // Reset previous icon to White and normal size
                        selectedCameraEntity.current.billboard!.color = new CesiumJs.ConstantProperty(CesiumJs.Color.WHITE);
                        selectedCameraEntity.current.billboard!.scale = new CesiumJs.ConstantProperty(0.06);
                    }

                    //
                    // Make it Green (Lime) and 50% larger
                    entity.billboard!.color = new CesiumJs.ConstantProperty(CesiumJs.Color.LIME);
                    entity.billboard!.scale = new CesiumJs.ConstantProperty(0.1);
                    selectedCameraEntity.current = entity;

                    // ---  LOAD IMAGE ---
                    const filename = entity.properties.getValue(CesiumJs.JulianDate.now()).filename;
                    const pos = entity.properties.getValue(CesiumJs.JulianDate.now()).exactPosition;

                    if (proxyBaseUrl && filename) {
                        setSelectedImage(`${proxyBaseUrl}/${filename}`);
                    }

                    // --- . FLY TO ---
                    // cesiumViewer.current!.camera.flyTo({
                    //     destination: CesiumJs.Cartesian3.fromDegrees(pos.lon, pos.lat, pos.alt),
                    //     orientation: {
                    //         heading: cesiumViewer.current!.camera.heading,
                    //         pitch: CesiumJs.Math.toRadians(-15),
                    //         roll: 0
                    //     },
                    //     duration: 1.5
                    // });
                }
            }
            // If we clicked the TILESET (The Building)
            else {
                // Get the exact 3D coordinate on the building
                const pickedPosition = scene.pickPosition(click.position);

                if (pickedPosition) {
                    console.log("Building Clicked at:", pickedPosition);
                    setTemp3DLocation(pickedPosition);
                    // 1. CALCULATE NORMAL (New)
                    const normal = getSurfaceNormal(scene, click.position);

                    // 2. PASS NORMAL TO FINDER
                    const cameras = camerasDataSourceRef.current?.entities.values || [];
                    
                    // Pass the normal to the ranking function
                    const bestCamera = findBestCamera(CesiumJs, pickedPosition, normal, cameras);

                    if (bestCamera) {
                        console.log("Best Camera Found:", bestCamera.properties?.getValue(CesiumJs.JulianDate.now()).filename);
                        
                        // B. Auto-select this camera
                        selectedCameraEntity.current = bestCamera;
                        
                        // C. Get the URL
                        const filename = bestCamera.properties?.getValue(CesiumJs.JulianDate.now()).filename;
                        // if (proxyBaseUrl && filename) {
                        //     setSelectedImage(`${proxyBaseUrl}/${filename}`);
                        // }

                        // D. Highlight it visually (Optional)
                        bestCamera.billboard!.color = new CesiumJs.ConstantProperty(CesiumJs.Color.LIME);
                        bestCamera.billboard!.scale = new CesiumJs.ConstantProperty(0.1);
                        
                        // E. Optional: Save the click position to state if you want to use it for the defect marker later
                        // setTemp3DLocation(pickedPosition); 
                    } else {
                        console.log("No suitable camera found for this location.");
                    }
                
                // This triggers the "Draft Mode"
                if (onDefectDetected) {
                    const draftCandidate: DefectCandidate = {
                        positions: [pickedPosition],
                        type: 'point',
                        measurement: 'Point',
                        labelPosition: pickedPosition,
                        // Optional: Pass pre-calculated data
                        locationOn3dModel: { 
                            type: 'point', 
                            coordinates: [{ x: pickedPosition.x, y: pickedPosition.y, z: pickedPosition.z }] 
                        }
                    };
                    
                    // We pass [] for entities because we aren't using the Drawing Manager's temp shapes
                    onDefectDetected(draftCandidate, []);
                    }
                }

            }

        }, CesiumJs.ScreenSpaceEventType.LEFT_CLICK);

        return () => handler.destroy();
    }, [CesiumJs, drawingMode, viewerReady, proxyBaseUrl, onDefectSelected, onDefectDetected]);

    // Reset highlight when image is closed
    useEffect(() => {
        if (!selectedImage && selectedCameraEntity.current) {
            selectedCameraEntity.current.billboard!.color = new CesiumJs.ConstantProperty(CesiumJs.Color.WHITE);
            selectedCameraEntity.current.billboard!.scale = new CesiumJs.ConstantProperty(0.06);
            selectedCameraEntity.current = null;
        }
    }, [selectedImage, CesiumJs]);



    
    // Effect to Fly To Defect when focusedDefectId changes
    useEffect(() => {
        if (!cesiumViewer.current || !focusedDefectId || !defectsDataSourceRef.current) return;

        const dataSource = defectsDataSourceRef.current;
        const entity = dataSource.entities.getById(focusedDefectId);

        if (entity) {
            cesiumViewer.current.flyTo(entity, {
                duration: 1.5,
                offset: new CesiumJs.HeadingPitchRange(
                    0, 
                    CesiumJs.Math.toRadians(-45), 
                    50 // Distance in meters
                )
            });
            // Optional: Select it visually
            cesiumViewer.current.selectedEntity = entity;
        }
    }, [focusedDefectId, CesiumJs]);

    // NEW: Handle Resize (Important for Split Pane)
    useEffect(() => {
        if (!cesiumContainerRef.current || !cesiumViewer.current) return;

        const resizeObserver = new ResizeObserver(() => {
            if (cesiumViewer.current && !cesiumViewer.current.isDestroyed()) {
                cesiumViewer.current.resize();
            }
        });
        
        resizeObserver.observe(cesiumContainerRef.current);

        return () => resizeObserver.disconnect();
    }, [viewerReady, cesiumContainerRef]);

    
        // EFFECT: Toggle Tileset Visibility
    useEffect(() => {
        if (!cesiumViewer.current || !currentTilesetRef.current) return;
        currentTilesetRef.current.show = showTileset;
    }, [showTileset]);

    // EFFECT: Toggle Defects Visibility
    useEffect(() => {
        if (!cesiumViewer.current || !defectsDataSourceRef.current) return;
        
        const entities = defectsDataSourceRef.current.entities.values;
        
        entities.forEach((entity: InstanceType<typeof CesiumJs.Entity>)  => {
            // Get the severity stored in the property bag
            // Note: Cesium properties can be tricky. We need to access the raw value.
            if (entity.properties && entity.properties.hasProperty('detectionData')) {
                const defectData = entity.properties.getValue(CesiumJs.JulianDate.now())['detectionData'];
                const severity = defectData.severity as keyof SeverityVisibility;
                
                // Show if the toggle for this severity is TRUE
                entity.show = severityVisibility[severity] ?? true; 
            }
        });
        
        // Force a re-render of the scene
        cesiumViewer.current.scene.requestRender();

    }, [severityVisibility, CesiumJs]);

    // 3. Initialize Viewer (With Strict Cleanup)
    useEffect(() => {
        if (!cesiumContainerRef.current) return;
        if (cesiumViewer.current && !cesiumViewer.current.isDestroyed()) return;


        // Safe token assignment
        CesiumJs.Ion.defaultAccessToken = '' // process.env.NEXT_PUBLIC_CESIUM_TOKEN || '';
        
        const imageryViewModels = basemapsLayers(CesiumJs);
        
        const viewer = new CesiumJs.Viewer(cesiumContainerRef.current, {
            creditContainer: document.createElement("div"),
        
            // ADD THESE LINES TO FIX THE OVERLAP:
            navigationHelpButton: false, // Hides the "?" button
            sceneModePicker: false,      // Hides the 2D/3D toggle (optional)
            //baseLayerPicker: false,      // Hides the map layer picker (since you have a custom one)

            geocoder: false,
            imageryProviderViewModels: imageryViewModels,
            selectedImageryProviderViewModel: imageryViewModels[0],
            animation: false,
            timeline: false,
            infoBox: false, 
            homeButton: false,
            fullscreenButton: false,
            selectionIndicator: false,
            orderIndependentTranslucency: false,
        });

        viewer.baseLayerPicker.viewModel.terrainProviderViewModels = [];
        viewer.clock.clockStep = CesiumJs.ClockStep.SYSTEM_CLOCK_MULTIPLIER;
        (viewer.scene as any).pickTranslucentDepth = true;
        
        // Enable picking functions binding
        viewer.scene.pick = viewer.scene.pick.bind(viewer.scene);
        viewer.scene.pickPosition = viewer.scene.pickPosition.bind(viewer.scene);   

        // Initialize Data Source
        const dataSource = new CesiumJs.CustomDataSource("Defects");
        viewer.dataSources.add(dataSource);
        defectsDataSourceRef.current = dataSource;

        cesiumViewer.current = viewer;
        setViewerReady(true);

        // Cleanup to prevent "Fragment Shader" crash on re-mount
        return () => {
            if (cesiumViewer.current && !cesiumViewer.current.isDestroyed()) {
                try {
                    cesiumViewer.current.destroy();
                } catch (e) {
                    console.warn("Cesium destroy error", e);
                }
                cesiumViewer.current = null;
                setViewerReady(false);
                isLoaded.current = false;
            }
        };
    }, [CesiumJs, cesiumContainerRef]);

    // Helper to clean up primitives
    const cleanUpPrimitives = React.useCallback(() => {
        addedScenePrimitives.current.forEach(scenePrimitive => {
            if (cesiumViewer.current && !cesiumViewer.current.isDestroyed()) {
                cesiumViewer.current.scene.primitives.remove(scenePrimitive);
            }
        });
        addedScenePrimitives.current = [];
    }, []);

    // 4. Load Tileset 
    useEffect(() => {
        if (!viewerReady || isLoaded.current) return;

        const initializeCesiumJs = async () => {
            if (cesiumViewer.current !== null) {
                cleanUpPrimitives();

                try {
                    const loadTileset = async () => {
                        console.log("Loading Tileset from:", tilesetUrl);
                        
                        const tileset = await CesiumJs.Cesium3DTileset.fromUrl(tilesetUrl);

                        const result = await autoAlignTileset(
                            tileset,
                            cesiumViewer,
                            CesiumJs,
                            { debug: true }
                        );
                        console.log("Auto Align Result:", result);

                        currentTilesetRef.current = tileset;

                        // Add primitive manually as per your original logic
                        const targetBuildingsTilesetPrimitive = cesiumViewer.current!.scene.primitives.add(tileset);
                        addedScenePrimitives.current.push(targetBuildingsTilesetPrimitive);
                        
                        console.log('Tileset added');

                        await cesiumViewer.current!.zoomTo(tileset);

                        // Important settings for 3D tileset interaction
                        cesiumViewer.current!.scene.globe.depthTestAgainstTerrain = false;
                        //cesiumViewer.current!.scene.logarithmicDepthBuffer = true;
                    }

                    await loadTileset();
           
                } catch (error) {
                    console.error(`Error creating tileset: ${error}`);
                }

                // Set loaded flag
                isLoaded.current = true;
            }
        };

        initializeCesiumJs();
    }, [viewerReady, tilesetUrl, CesiumJs, cleanUpPrimitives]);

    // 5. Load Detections
    useEffect(() => {
        if (!viewerReady || !defectsDataSourceRef.current) return;

        clearActiveDrawing();
        const dataSource = defectsDataSourceRef.current;
        dataSource.entities.removeAll();

        console.log("Loading defects...", initialDetections.length);

        initialDetections.forEach(detection => {
             const location = detection.locationOn3dModel as any;
             if (!location || !location.coordinates) return;
             let pinPosition: Cartesian3 | null = null;
             const positions = location.coordinates.map(
                (pos: {x: number, y: number, z: number}) => 
                    new CesiumJs.Cartesian3(pos.x, pos.y, pos.z)
            );
            if (location?.coordinates && location.coordinates.length > 0) {
                 // Use the first point, or calculate center of the box
                 const p = location.coordinates[0];
                 pinPosition = new CesiumJs.Cartesian3(p.x, p.y, p.z);
             }

             if (!pinPosition) return;

            const propertyBag = new CesiumJs.PropertyBag();
            propertyBag.addProperty('detectionData', detection);
            
            //  Get the Dynamic Color
            const severityColor = getSeverityColor(CesiumJs, detection.severity || 'LOW');

            // RENDER AS BILLBOARD (PIN)
            dataSource.entities.add({
                id: detection.id,
                position: pinPosition,
                properties: propertyBag,
                billboard: {
                    image:triangleAlertSvg,
                    verticalOrigin: CesiumJs.VerticalOrigin.BOTTOM,
                    scale: 1.0,
                    color: severityColor,
                    heightReference: CesiumJs.HeightReference.NONE, // Exact 3D match
                    disableDepthTestDistance: Number.POSITIVE_INFINITY, // Always visible on top
                }
            });
        });
    }, [viewerReady, initialDetections, CesiumJs, clearActiveDrawing]);

    // Handler for search selection
    const handleSearchSelect = (id: string) => {
        if (!cesiumViewer.current || !defectsDataSourceRef.current) return;
        
        const entity = defectsDataSourceRef.current.entities.getById(id);
        if (entity) {
            cesiumViewer.current.flyTo(entity, {
                duration: 1.5,
                offset: new CesiumJs.HeadingPitchRange(
                    0, 
                    CesiumJs.Math.toRadians(-45), 
                    30 // Closer zoom for search result
                )
            });
            cesiumViewer.current.selectedEntity = entity;
        }
    };

    const handleSave2DDefect = (data: { points: { x: number; y: number }[];
    imageId: string | null;
    defectId?: string | null;
    type: string;}) => {
        if (!onDefectDetected) return;

        if (data.type !== 'polygon' && data.type !== 'polyline') {
            console.warn('Unsupported drawing type:', data.type);
            return;
            }

        // 1. Validations
        if (!temp3DLocation) {
            console.warn("Cannot save defect: No 3D location found. Please click on the 3D model first.");
            return;
        }

        // 2. Construct the Hybrid Object
        // We use 'as any' here to bypass strict type checking locally, 
        const candidate: DefectCandidate = { // Explicitly type this to ensure match
                    // A. Geometry: Pass the single 3D anchor point so the 3D map knows where to put the pin
                    positions: [temp3DLocation], 
                    
                    // B. Type: Map the 2D tool type to your schema
                    type: data.type ,
                    
                    // C. Measurement: 
                    // Since we can't easily calculate real-world meters from pixels without depth data for every pixel,
                    // we leave this as "2D Annotation" or calculate a pixel-based metric if needed.
                    measurement: "2D Annotation", 
                    
                    // D. Label Position: The anchor point
                    labelPosition: temp3DLocation,
                    
                    // --- EXTENDED PROPS (The ones we added to the Form in the previous step) ---
                    // We cast to 'any' or update DefectCandidate interface to include these optional fields
                    ...({
                        annotation2D: data.points,
                        sourceImageId: data.imageId,
                        locationOn3dModel: { 
                            type: 'point', 
                            coordinates: [{ x: temp3DLocation.x, y: temp3DLocation.y, z: temp3DLocation.z }]
                        },
                        status: 'NEW', 
                        severity: 'LOW'
                    } as any)
                };

            onDefectDetected(candidate, []);
                // Close modal
            //setSelectedImage(null);
            setTemp3DLocation(null);
        };
    
    useEffect(() => {
            if (defectToEditImage && defectToEditImage.sourceImageId) {
                console.log("Opening Image for Edit:", defectToEditImage.sourceImageId);
                
                // 1. Construct URL
                const imageUrl = `${proxyBaseUrl}/${defectToEditImage.sourceImageId}`;
                
                // 2. Open Image Modal
                setSelectedImage(imageUrl);
            }
        }, [defectToEditImage, proxyBaseUrl]);

    const handleCrackProjection = async (points2D: { x: number; y: number }[]) => {
        console.log("╔═══════════════════════════════════════════════════════════╗");
        console.log("║  PROJECTION START                                         ║");
        console.log("╚═══════════════════════════════════════════════════════════╝");
        console.log(`📥 Received ${points2D?.length || 0} points`);

        if (!cesiumViewer.current || !selectedCameraEntity.current || !points2D.length) {
            console.error("❌ Missing required data");
            return;
        }

        const entity = selectedCameraEntity.current;
        const props = entity.properties!.getValue(CesiumJs.JulianDate.now());
        const cameraData = props.cameraData;
        const scene = cesiumViewer.current.scene;
        const tileset = currentTilesetRef.current;
        const localToWorldTransform = tileset && tileset.root && tileset.root.transform ? tileset.root.transform : CesiumJs.Matrix4.IDENTITY;

            // Force tileset refinement to improve picking
        if (tileset) {
            try {
                tileset.maximumScreenSpaceError = 1; // force high quality
                tileset.dynamicScreenSpaceError = false;
                tileset.maximumCacheOverflowBytes = Math.max(tileset.maximumCacheOverflowBytes || 512, 1024);
            } catch (e) {
                console.warn("Could not set tileset LOD hints:", e);
            }
        }

        console.log("📷 Camera:", cameraData.filename);

        // Camera position
        const cameraPosECEF = CesiumJs.Cartesian3.fromDegrees(
            cameraData.gpsPosition.lon,
            cameraData.gpsPosition.lat,
            cameraData.gpsPosition.alt
        );

        // Tileset info
        let distanceToTileset = 50;
        let tilesetCenterHeight = 0;
        let tilesetCenter: any = null;

        if (tileset?.boundingSphere) {
            tilesetCenter = tileset.boundingSphere.center;
            const tilesetCarto = CesiumJs.Cartographic.fromCartesian(tilesetCenter);
            tilesetCenterHeight = tilesetCarto.height;
            distanceToTileset = CesiumJs.Cartesian3.distance(cameraPosECEF, tilesetCenter);
            
            console.log(`📏 Distance to tileset: ${distanceToTileset.toFixed(2)}m`);
            console.log(`📏 Tileset center height: ${tilesetCenterHeight.toFixed(2)}m`);
            console.log(`📏 Tileset radius: ${tileset.boundingSphere.radius.toFixed(2)}m`);
        }

        // Make sure depth picking is enabled
        scene.globe.depthTestAgainstTerrain = true;
        scene.pickTranslucentDepth = true;

        // 1) Align Cesium camera to drone camera pose and FOV so pickPosition depth lines up
        await setCesiumCameraToDrone(CesiumJs, scene, cameraData, cameraPosECEF, localToWorldTransform);

        // Ensure the scene renders fully and tiles refine
        scene.requestRender();
        // wait briefly for depth buffer & tileset LOD which gives pickPosition a chance to succeed
        await new Promise<void>((resolve) => {
            let attempts = 0;
            const check = () => {
                attempts++;
                scene.requestRender();
                if ((!tileset || tileset.tilesLoaded) || attempts > 30) {
                    if (attempts > 30) console.warn("Timeout waiting for tiles to refine, proceeding anyway");
                    return resolve();
                }
                setTimeout(check, 150);
            };
            check();
        });

        // Precompute intrinsics
        const cx = cameraData.width / 2;
        const cy = cameraData.height / 2;
        const f = cameraData.focal * Math.max(cameraData.width, cameraData.height);
        console.log(`📷 Intrinsics: cx=${cx}, cy=${cy}, f=${f.toFixed(2)}`);

        // Rotation mat and transpose
        const R = rodriguesToMatrix(CesiumJs, cameraData.rotation);
        const Rt = CesiumJs.Matrix3.transpose(R, new CesiumJs.Matrix3());

        const worldPositions: any[] = [];
        const hitTypes: string[] = [];
        let tilesetHits = 0;

        for (let i = 0; i < points2D.length; i++) {
            const pixel = points2D[i];

            // --- produce normalized undistorted coords (your existing code)
            let xn = (pixel.x - cx) / f;
            let yn = (pixel.y - cy) / f;

            const k1 = cameraData.k1 || 0;
            const k2 = cameraData.k2 || 0;
            if (Math.abs(k1) > 1e-8 || Math.abs(k2) > 1e-8) {
                const xd = xn, yd = yn;
                for (let iter = 0; iter < 20; iter++) {
                    const r2 = xn * xn + yn * yn;
                    const r4 = r2 * r2;
                    const radialDist = 1 + k1 * r2 + k2 * r4;
                    xn = xd / radialDist;
                    yn = yd / radialDist;
                }
            }

            // Direction in camera coords, rotate into world and ECEF like before
            const dirCam = new CesiumJs.Cartesian3(xn, yn, 1.0);
            CesiumJs.Cartesian3.normalize(dirCam, dirCam);
            const dirLocal = CesiumJs.Matrix3.multiplyByVector(Rt, dirCam, new CesiumJs.Cartesian3());

            // Apply the same ENU transform that you used earlier
            const enuTransform = CesiumJs.Transforms.eastNorthUpToFixedFrame(cameraPosECEF);
            const enuRot = CesiumJs.Matrix4.getMatrix3(enuTransform, new CesiumJs.Matrix3());

            const dirENU = new CesiumJs.Cartesian3(dirLocal.x, dirLocal.y, dirLocal.z);
            const dirECEF = CesiumJs.Matrix3.multiplyByVector(enuRot, dirENU, new CesiumJs.Cartesian3());
            CesiumJs.Cartesian3.normalize(dirECEF, dirECEF);

            const dotWithDown = CesiumJs.Cartesian3.dot(
                dirECEF,
                CesiumJs.Cartesian3.normalize(
                    CesiumJs.Cartesian3.negate(cameraPosECEF, new CesiumJs.Cartesian3()),
                    new CesiumJs.Cartesian3()
                )
            );
            console.log(`  Pixel ${i}: (${pixel.x.toFixed(0)}, ${pixel.y.toFixed(0)}) → normalized (${xn.toFixed(4)}, ${yn.toFixed(4)})`);
            console.log(` Direction dot with down: ${dotWithDown.toFixed(4)} (should be positive for downward)`);

            // Build ray
            const ray = new CesiumJs.Ray(cameraPosECEF, dirECEF);

            // Debug ray preview
            const rayEndpoint = CesiumJs.Ray.getPoint(ray, Math.min(distanceToTileset, 100));
            defectsDataSourceRef.current!.entities.add({
                id: `debug_ray_${i}_${Date.now()}`,
                polyline: {
                    positions: [cameraPosECEF, rayEndpoint],
                    width: 2,
                    material: CesiumJs.Color.MAGENTA.withAlpha(0.5)
                }
            });

            // ====== NEW: map to window coords and use pickPosition first ======
            // Pick a test point somewhere near the tileset along the ray so screen mapping matches pixel
            const testDist = Math.min(distanceToTileset, 100); // pick a sensible distance
            const testPoint = CesiumJs.Ray.getPoint(ray, testDist);

            const screenPosRaw = CesiumJs.SceneTransforms.worldToWindowCoordinates(scene, testPoint);
            let finalPosition: any = null;
            let hitType: string = 'none';

            if (screenPosRaw && Number.isFinite(screenPosRaw.x) && Number.isFinite(screenPosRaw.y)) {
                const windowPos = new CesiumJs.Cartesian2(screenPosRaw.x, screenPosRaw.y);

                // Ensure a render so depth buffer is ready
                scene.requestRender();

                try {
                    const picked = scene.pickPosition(windowPos);
                    const centerScreen = new CesiumJs.Cartesian2(scene.canvas.clientWidth/2, scene.canvas.clientHeight/2);
                    console.log('center pick', scene.pickPosition(centerScreen));

                    if (picked) {
                        finalPosition = picked;
                        hitType = 'pickPosition-tileset';
                        tilesetHits++;
                    }
                } catch (e) {
                    console.debug("pickPosition error:", e);
                }
            }

            // If pickPosition failed, fallback to your existing ray intersection (unchanged)
            if (!finalPosition) {
                const intersection = await intersectRayWithTileset(
                    CesiumJs, scene, ray, tileset, distanceToTileset * 3, cameraPosECEF
                );

                const isValidHit = intersection && !intersection.hitType.includes('boundingSphere');

                if (isValidHit) {
                    finalPosition = intersection!.position;
                    hitType = intersection!.hitType;
                    if (hitType.includes('tileset')) tilesetHits++;
                } else {
                    // fallback plane projection (you had this)
                    const planeHit = intersectRayWithPlane(CesiumJs, ray, tilesetCenterHeight || 0);
                    if (planeHit) {
                        finalPosition = planeHit;
                        hitType = 'fallback-plane';
                        // optionally count this as a hit
                        // tilesetHits++;
                    } else {
                        finalPosition = CesiumJs.Ray.getPoint(ray, distanceToTileset);
                        hitType = 'fallback-floating';
                    }
                }
            }

            // Log and store
            const hitCarto = CesiumJs.Cartographic.fromCartesian(finalPosition);
            const distFromCamera = CesiumJs.Cartesian3.distance(cameraPosECEF, finalPosition);

            console.log(`Point ${i}: (${pixel.x.toFixed(0)}, ${pixel.y.toFixed(0)}) → ${hitType}`);
            console.log(`  ↳ Height: ${hitCarto.height.toFixed(2)}m, Dist: ${distFromCamera.toFixed(2)}m`);

            hitTypes.push(hitType);
            worldPositions.push(finalPosition);
        } // end loop over points

        console.log(`📊 Tileset hits: ${tilesetHits}/${points2D.length}`);
        console.log(`📊 Hit types: ${[...new Set(hitTypes)].join(', ')}`);

        if (worldPositions.length < 2) {
            console.error("❌ Insufficient points");
            return;
        }

        // Visualization unchanged (polyline, points)...
        const id = `projection_${Date.now()}`;
        const color = tilesetHits >= points2D.length / 2 ? CesiumJs.Color.LIME : CesiumJs.Color.YELLOW;

        defectsDataSourceRef.current!.entities.add({
            id: id,
            polyline: {
                positions: worldPositions,
                width: 10,
                material: new CesiumJs.PolylineGlowMaterialProperty({
                    glowPower: 0.4,
                    color: color
                }),
                clampToGround: true,
                classificationType: CesiumJs.ClassificationType.CESIUM_3D_TILE,
                arcType: CesiumJs.ArcType.GEODESIC,
            }
        });

        worldPositions.forEach((pos, idx) => {
            const ht = hitTypes[idx];
            let ptColor = CesiumJs.Color.ORANGE;
            if (ht.includes('tileset')) ptColor = CesiumJs.Color.LIME;
            else if (ht.includes('globe')) ptColor = CesiumJs.Color.CYAN;
            else if (ht === 'boundingSphere') ptColor = CesiumJs.Color.YELLOW;
            else if (ht.includes('fallback')) ptColor = CesiumJs.Color.ORANGE;

            defectsDataSourceRef.current!.entities.add({
                id: `${id}_pt_${idx}`,
                position: pos,
                point: {
                    pixelSize: 14,
                    color: ptColor,
                    outlineColor: CesiumJs.Color.BLACK,
                    outlineWidth: 3,
                    disableDepthTestDistance: Number.POSITIVE_INFINITY,
                }
            });
        });

        console.log(`✅ Created: ${id}`);

        // Fly to see result
        cesiumViewer.current.flyTo(defectsDataSourceRef.current!.entities.getById(id)!, {
            duration: 1.0,
            offset: new CesiumJs.HeadingPitchRange(0, CesiumJs.Math.toRadians(-45), distanceToTileset * 0.8)
        });

        scene.requestRender();
    };

    return (
        <div className="relative w-full h-full">
            <div ref={cesiumContainerRef} className="w-full h-full" suppressHydrationWarning={true}/>

            {/* --- IMAGE OVERLAY MODAL --- */}
            {selectedImage && (
                <ImageViewerModal 
                    src={selectedImage} 
                    imageId={defectToEditImage?.sourceImageId || selectedCameraEntity.current?.properties?.getValue(CesiumJs.JulianDate.now())?.filename}
                    onClose={() => {setSelectedImage(null); 
                                    onCloseImageEdit();}} 
                    onSave={handleSave2DDefect}
                    
                    
                    cameraContext={selectedCameraEntity.current ? getCameraContext(selectedCameraEntity.current, CesiumJs) : undefined}
                    
                    nearbyDefects={initialDetections}
                    
                    initialData={defectToEditImage ? {
                        id: defectToEditImage.id,
                        points: defectToEditImage.annotation2D as {x:number, y:number}[]
                    } : undefined}
                />
            
            )}

            {/* Toolbar with Dark Mode fix */}
            <div className="absolute top-4 left-4 z-10 flex flex-col gap-2 p-2 bg-card border border-border rounded-lg shadow-md w-12 items-center">

                {/* Layer Control */}
                <LayerControl 
                    showTileset={showTileset}
                    toggleTileset={onToggleTileset}
                    severityVisibility={severityVisibility}
                    toggleSeverity={onToggleSeverity}
                    toggleAllDefects={onToggleAllDefects}
                />
                
                {/* <div className="h-px w-full bg-border my-1" /> */}

                {/* <Button
                    onClick={() => startDrawing('none')}
                    variant={drawingMode === 'none' ? 'default' : 'outline'}
                    size="sm"
                >
                    <Hand className="w-4 h-4" />
                </Button>
                <Button
                    onClick={() => startDrawing('polyline')}
                    variant={drawingMode === 'polyline' ? 'default' : 'outline'}
                    size="sm"
                >
                    <Pencil className="w-4 h-4" />
                </Button>
                <Button
                    onClick={() => startDrawing('polygon')}
                    variant={drawingMode === 'polygon' ? 'default' : 'outline'}
                    size="sm"
                >
                    <Square className="w-4 h-4 rotate-45" />
                </Button>

                <div className="h-px w-full bg-border my-1" />
                
                <Button
                    onClick={() => clearActiveDrawing()}
                    variant="destructive"
                    size="sm"
                >
                    <Trash2 className="w-4 h-4" />
                </Button> */}

            </div>

            {/* --- TOP RIGHT CONTROLS CONTAINER --- */}
            <div className="absolute top-1 right-30 z-10 flex flex-col items-end gap-2">
                
                {/* Search & Primary Actions */}
                <div className="flex items-center gap-2">
                    {/* The Search Bar (Expands to the left) */}
                    {/* <DefectSearch 
                        defects={initialDetections} 
                        onSelectDefect={handleSearchSelect} 
                    /> */}
                  
                    {/* <Button variant="secondary" size="icon" className="shadow-md">
                        <Settings className="h-4 w-4" />
                    </Button> */}
                </div>

                {/* Row 2: Secondary Controls (Optional - stacked below) */}
            </div>

        {   isMapFullscreen &&
            (         
            <div className="absolute bottom-4 left-4 z-10 bg-card/80 backdrop-blur-sm p-3 rounded-lg border border-border shadow-lg text-xs">
                <div className="font-semibold mb-2 text-foreground">Defect Severity</div>
                <div className="space-y-1.5">
                    <div className="flex items-center gap-2">
                        <div className="w-3 h-3 bg-red-600 rounded-full shadow-sm"></div> 
                        <span className="text-muted-foreground">Critical</span>
                    </div>
                    <div className="flex items-center gap-2">
                        <div className="w-3 h-3 bg-orange-500 rounded-full shadow-sm"></div> 
                        <span className="text-muted-foreground">High</span>
                    </div>
                    <div className="flex items-center gap-2">
                        <div className="w-3 h-3 bg-yellow-400 rounded-full shadow-sm"></div> 
                        <span className="text-muted-foreground">Medium</span>
                    </div>
                    <div className="flex items-center gap-2">
                        <div className="w-3 h-3 bg-green-500 rounded-full shadow-sm"></div> 
                        <span className="text-muted-foreground">Low</span>
                    </div>
                </div>
            </div>)
        }

            {/* <Button
                onClick={onFullscreenToggle}
                className="absolute bottom-4 right-4 z-10 rounded-full shadow-md"
                size="icon"
            >
                <LucideFullscreen className="w-4 h-4" />
            </Button> */}
        </div>
    );
};

export default CesiumComponent;
</file>

</files>
