import{a as t}from"./chunk-VTK7G5BX.js";import"./chunk-QORMFUM4.js";import"./chunk-FWF3VNA2.js";import{a as e}from"./chunk-APG2S62J.js";import"./chunk-AZLP5742.js";import"./chunk-5HPISDSZ.js";import"./chunk-HSJ6GSLC.js";import"./chunk-SXKYZMEL.js";import{a as i}from"./chunk-T6Q6HX5J.js";import{a as n}from"./chunk-4MJDNHOT.js";import{b as o,c as r,d as a}from"./chunk-EDF5FKWJ.js";import{d as s}from"./chunk-XQIJGAVD.js";import"./chunk-UTYWXSQT.js";import{a as m}from"./chunk-RCHWDG3R.js";import"./chunk-4WJUWBRK.js";import"./chunk-5G23AKP3.js";import{a as l,d as p,f as u}from"./chunk-KWAHJ72S.js";import{a as h}from"./chunk-MKDADUG3.js";import{a as c}from"./chunk-NOIUI5SY.js";import{e as g}from"./chunk-XRRBRTKL.js";var f=new l,d=new l,y=new l,k=new l,w=new l,A=new l,_=new l;function v(t){let i=(t=t??u.EMPTY_OBJECT).positions,n=t.maximumHeights,o=t.minimumHeights;if(!g(i))throw new c("options.positions is required.");if(g(n)&&n.length!==i.length)throw new c("options.positions and options.maximumHeights must have the same length.");if(g(o)&&o.length!==i.length)throw new c("options.positions and options.minimumHeights must have the same length.");let r=t.vertexFormat??e.DEFAULT,a=t.granularity??h.RADIANS_PER_DEGREE,s=t.ellipsoid??p.default;this._positions=i,this._minimumHeights=o,this._maximumHeights=n,this._vertexFormat=e.clone(r),this._granularity=a,this._ellipsoid=p.clone(s),this._workerName="createWallGeometry";let m=1+i.length*l.packedLength+2;g(o)&&(m+=o.length),g(n)&&(m+=n.length),this.packedLength=m+p.packedLength+e.packedLength+1}v.pack=function(t,i,n){if(!g(t))throw new c("value is required");if(!g(i))throw new c("array is required");n=n??0;let o,r=t._positions,a=r.length;for(i[n++]=a,o=0;o<a;++o,n+=l.packedLength)l.pack(r[o],i,n);let s=t._minimumHeights;if(a=g(s)?s.length:0,i[n++]=a,g(s))for(o=0;o<a;++o)i[n++]=s[o];let m=t._maximumHeights;if(a=g(m)?m.length:0,i[n++]=a,g(m))for(o=0;o<a;++o)i[n++]=m[o];return p.pack(t._ellipsoid,i,n),n+=p.packedLength,e.pack(t._vertexFormat,i,n),i[n+=e.packedLength]=t._granularity,i};var x=p.clone(p.UNIT_SPHERE),H=new e,F={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:x,vertexFormat:H,granularity:void 0};v.unpack=function(t,i,n){let o,r;if(!g(t))throw new c("array is required");i=i??0;let a,s=t[i++],m=Array(s);for(a=0;a<s;++a,i+=l.packedLength)m[a]=l.unpack(t,i);if((s=t[i++])>0)for(o=Array(s),a=0;a<s;++a)o[a]=t[i++];if((s=t[i++])>0)for(r=Array(s),a=0;a<s;++a)r[a]=t[i++];let u=p.unpack(t,i,x);i+=p.packedLength;let h=e.unpack(t,i,H),f=t[i+=e.packedLength];return g(n)?(n._positions=m,n._minimumHeights=o,n._maximumHeights=r,n._ellipsoid=p.clone(u,n._ellipsoid),n._vertexFormat=e.clone(h,n._vertexFormat),n._granularity=f,n):(F.positions=m,F.minimumHeights=o,F.maximumHeights=r,F.granularity=f,new v(F))},v.fromConstantHeights=function(t){let e=(t=t??u.EMPTY_OBJECT).positions;if(!g(e))throw new c("options.positions is required.");let i,n,o=t.minimumHeight,r=t.maximumHeight,a=g(o),s=g(r);if(a||s){let t=e.length;i=a?Array(t):void 0,n=s?Array(t):void 0;for(let e=0;e<t;++e)a&&(i[e]=o),s&&(n[e]=r)}return new v({positions:e,maximumHeights:n,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},v.createGeometry=function(e){let p=e._positions,u=e._minimumHeights,c=e._maximumHeights,v=e._vertexFormat,x=e._granularity,H=e._ellipsoid,F=t.computePositions(H,p,c,u,x,!0);if(!g(F))return;let L=F.bottomPositions,j=F.topPositions,E=F.numCorners,b=j.length,T=2*b,P=v.position?new Float64Array(T):void 0,D=v.normal?new Float32Array(T):void 0,S=v.tangent?new Float32Array(T):void 0,O=v.bitangent?new Float32Array(T):void 0,R=v.st?new Float32Array(T/3*2):void 0,G=0,z=0,J=0,N=0,I=0,K=_,U=A,W=w,q=!0,M,B=0,C=1/((b/=3)-E-1);for(M=0;M<b;++M){let t=3*M,e=l.fromArray(j,t,f),i=l.fromArray(L,t,d);if(v.position&&(P[G++]=i.x,P[G++]=i.y,P[G++]=i.z,P[G++]=e.x,P[G++]=e.y,P[G++]=e.z),v.st&&(R[I++]=B,R[I++]=0,R[I++]=B,R[I++]=1),v.normal||v.tangent||v.bitangent){let i=l.clone(l.ZERO,k),n=l.subtract(e,H.geodeticSurfaceNormal(e,d),d);if(M+1<b&&(i=l.fromArray(j,t+3,k)),q){let t=l.subtract(i,e,y),o=l.subtract(n,e,f);K=l.normalize(l.cross(o,t,K),K),q=!1}l.equalsEpsilon(e,i,h.EPSILON10)?q=!0:(B+=C,v.tangent&&(U=l.normalize(l.subtract(i,e,U),U)),v.bitangent&&(W=l.normalize(l.cross(K,U,W),W))),v.normal&&(D[z++]=K.x,D[z++]=K.y,D[z++]=K.z,D[z++]=K.x,D[z++]=K.y,D[z++]=K.z),v.tangent&&(S[N++]=U.x,S[N++]=U.y,S[N++]=U.z,S[N++]=U.x,S[N++]=U.y,S[N++]=U.z),v.bitangent&&(O[J++]=W.x,O[J++]=W.y,O[J++]=W.z,O[J++]=W.x,O[J++]=W.y,O[J++]=W.z)}}let X=new n;v.position&&(X.position=new a({componentDatatype:m.DOUBLE,componentsPerAttribute:3,values:P})),v.normal&&(X.normal=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:D})),v.tangent&&(X.tangent=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:S})),v.bitangent&&(X.bitangent=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:O})),v.st&&(X.st=new a({componentDatatype:m.FLOAT,componentsPerAttribute:2,values:R}));let Y=T/3;T-=6*(E+1);let Q=i.createTypedArray(Y,T),V=0;for(M=0;M<Y-2;M+=2){let t=M,e=M+2,i=l.fromArray(P,3*t,f),n=l.fromArray(P,3*e,d);if(l.equalsEpsilon(i,n,h.EPSILON10))continue;let o=M+1,r=M+3;Q[V++]=o,Q[V++]=t,Q[V++]=r,Q[V++]=r,Q[V++]=t,Q[V++]=e}return new r({attributes:X,indices:Q,primitiveType:o.TRIANGLES,boundingSphere:new s.fromVertices(P)})};var L=function(t,e){return g(e)&&(t=v.unpack(t,e)),t._ellipsoid=p.clone(t._ellipsoid),v.createGeometry(t)};export{L as default};