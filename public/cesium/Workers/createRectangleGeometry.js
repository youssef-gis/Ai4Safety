import{a as t}from"./chunk-RYOF6QSA.js";import{a as e}from"./chunk-2ZPEMRCT.js";import{a as n}from"./chunk-3BSRJTW3.js";import"./chunk-VHZAK4GN.js";import"./chunk-OFCC6BNI.js";import{a as o}from"./chunk-T77EB7BE.js";import{a as a}from"./chunk-APG2S62J.js";import{b as r}from"./chunk-IYO6TYGP.js";import"./chunk-5HPISDSZ.js";import"./chunk-HSJ6GSLC.js";import"./chunk-SXKYZMEL.js";import{a as i}from"./chunk-T6Q6HX5J.js";import{a as s}from"./chunk-4MJDNHOT.js";import{b as l,c as u,d as c}from"./chunk-EDF5FKWJ.js";import{d as m}from"./chunk-XQIJGAVD.js";import{g as p,i as h,j as g}from"./chunk-UTYWXSQT.js";import{a as f}from"./chunk-RCHWDG3R.js";import"./chunk-4WJUWBRK.js";import"./chunk-5G23AKP3.js";import{a as d,b as _,c as y,d as b,e as w,f as A}from"./chunk-KWAHJ72S.js";import{a as v}from"./chunk-MKDADUG3.js";import{a as x,b as k}from"./chunk-NOIUI5SY.js";import{e as R}from"./chunk-XRRBRTKL.js";var E=new d,F=new d,P=new d,T=new d,O=new h,L=new y,N=new m,D=new m;function S(t,e){let n=new u({attributes:new s,primitiveType:l.TRIANGLES});return n.attributes.position=new c({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(n.attributes.normal=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(n.attributes.tangent=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(n.attributes.bitangent=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.bitangents})),n}var j=new d,H=new d;function I(e,n){let o=e._vertexFormat,a=e._ellipsoid,r=n.height,s=n.width,l=n.northCap,u=n.southCap,m=0,p=r,h=r,g=0;l&&(m=1,h-=1,g+=1),u&&(p-=1,h-=1,g+=1),g+=s*h;let _=o.position?new Float64Array(3*g):void 0,y=o.st?new Float32Array(2*g):void 0,b=0,A=0,v=Number.MAX_VALUE,x=Number.MAX_VALUE,k=-Number.MAX_VALUE,R=-Number.MAX_VALUE;for(let e=m;e<p;++e)for(let r=0;r<s;++r)t.computePosition(n,a,o.st,e,r,E,L),_[b++]=E.x,_[b++]=E.y,_[b++]=E.z,o.st&&(y[A++]=L.x,y[A++]=L.y,v=Math.min(v,L.x),x=Math.min(x,L.y),k=Math.max(k,L.x),R=Math.max(R,L.y));if(l&&(t.computePosition(n,a,o.st,0,0,E,L),_[b++]=E.x,_[b++]=E.y,_[b++]=E.z,o.st&&(y[A++]=L.x,y[A++]=L.y,v=L.x,x=L.y,k=L.x,R=L.y)),u&&(t.computePosition(n,a,o.st,r-1,0,E,L),_[b++]=E.x,_[b++]=E.y,_[b]=E.z,o.st&&(y[A++]=L.x,y[A]=L.y,v=Math.min(v,L.x),x=Math.min(x,L.y),k=Math.max(k,L.x),R=Math.max(R,L.y))),o.st&&(v<0||x<0||k>1||R>1))for(let t=0;t<y.length;t+=2)y[t]=(y[t]-v)/(k-v),y[t+1]=(y[t+1]-x)/(R-x);let O=function(t,e,n,o){let a=t.length,r=e.normal?new Float32Array(a):void 0,i=e.tangent?new Float32Array(a):void 0,s=e.bitangent?new Float32Array(a):void 0,l=0,u=F;if(e.normal||e.tangent||e.bitangent)for(let c=0;c<a;c+=3){let a=d.fromArray(t,c,E),m=l+1,p=l+2;u=n.geodeticSurfaceNormal(a,u),(e.tangent||e.bitangent)&&(d.cross(d.UNIT_Z,u,P),w.multiplyByVector(o,P,P),d.normalize(P,P),e.bitangent&&d.normalize(d.cross(u,P,T),T)),e.normal&&(r[l]=u.x,r[m]=u.y,r[p]=u.z),e.tangent&&(i[l]=P.x,i[m]=P.y,i[p]=P.z),e.bitangent&&(s[l]=T.x,s[m]=T.y,s[p]=T.z),l+=3}return S(e,{positions:t,normals:r,tangents:i,bitangents:s})}(_,o,a,n.tangentRotationMatrix),N=6*(s-1)*(h-1);l&&(N+=3*(s-1)),u&&(N+=3*(s-1));let D=i.createTypedArray(g,N),j=0,H=0,I;for(I=0;I<h-1;++I){for(let t=0;t<s-1;++t){let t=j,e=t+s,n=e+1,o=t+1;D[H++]=t,D[H++]=e,D[H++]=o,D[H++]=o,D[H++]=e,D[H++]=n,++j}++j}if(l||u){let t,e,n=g-1,o=g-1;if(l&&u&&(n=g-2),j=0,l)for(I=0;I<s-1;I++)e=(t=j)+1,D[H++]=n,D[H++]=t,D[H++]=e,++j;if(u)for(j=(h-1)*s,I=0;I<s-1;I++)e=(t=j)+1,D[H++]=t,D[H++]=o,D[H++]=e,++j}return O.indices=D,o.st&&(O.attributes.st=new c({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:y})),O}function M(t,e,n,o,a){return t[e++]=o[n],t[e++]=o[n+1],t[e++]=o[n+2],t[e++]=a[n],t[e++]=a[n+1],t[e]=a[n+2],t}function G(t,e,n,o){return t[e++]=o[n],t[e++]=o[n+1],t[e++]=o[n],t[e]=o[n+1],t}var C=new a,U=[new d,new d,new d,new d],V=new _,z=new _;function B(e,n,o,a,r){if(0===o)return h.clone(e,r);let i=t.computeOptions(e,n,o,0,O,V),s=i.height,l=i.width;return t.computePosition(i,a,!1,0,0,U[0]),t.computePosition(i,a,!1,0,l-1,U[1]),t.computePosition(i,a,!1,s-1,0,U[2]),t.computePosition(i,a,!1,s-1,l-1,U[3]),h.fromCartesianArray(U,a,r)}function Y(t){let e=(t=t??A.EMPTY_OBJECT).rectangle;if(k.typeOf.object("rectangle",e),h._validate(e),e.north<e.south)throw new x("options.rectangle.north must be greater than or equal to options.rectangle.south");let n=t.height??0,o=t.extrudedHeight??n;this._rectangle=h.clone(e),this._granularity=t.granularity??v.RADIANS_PER_DEGREE,this._ellipsoid=b.clone(t.ellipsoid??b.default),this._surfaceHeight=Math.max(n,o),this._rotation=t.rotation??0,this._stRotation=t.stRotation??0,this._vertexFormat=a.clone(t.vertexFormat??a.DEFAULT),this._extrudedHeight=Math.min(n,o),this._shadowVolume=t.shadowVolume??!1,this._workerName="createRectangleGeometry",this._offsetAttribute=t.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}Y.packedLength=h.packedLength+b.packedLength+a.packedLength+7,Y.pack=function(t,e,n){return k.typeOf.object("value",t),k.defined("array",e),n=n??0,h.pack(t._rectangle,e,n),n+=h.packedLength,b.pack(t._ellipsoid,e,n),n+=b.packedLength,a.pack(t._vertexFormat,e,n),n+=a.packedLength,e[n++]=t._granularity,e[n++]=t._surfaceHeight,e[n++]=t._rotation,e[n++]=t._stRotation,e[n++]=t._extrudedHeight,e[n++]=+!!t._shadowVolume,e[n]=t._offsetAttribute??-1,e};var J=new h,X=b.clone(b.UNIT_SPHERE),K={rectangle:J,ellipsoid:X,vertexFormat:C,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};Y.unpack=function(t,e,n){k.defined("array",t),e=e??0;let o=h.unpack(t,e,J);e+=h.packedLength;let r=b.unpack(t,e,X);e+=b.packedLength;let i=a.unpack(t,e,C);e+=a.packedLength;let s=t[e++],l=t[e++],u=t[e++],c=t[e++],m=t[e++],p=1===t[e++],g=t[e];return R(n)?(n._rectangle=h.clone(o,n._rectangle),n._ellipsoid=b.clone(r,n._ellipsoid),n._vertexFormat=a.clone(i,n._vertexFormat),n._granularity=s,n._surfaceHeight=l,n._rotation=u,n._stRotation=c,n._extrudedHeight=m,n._shadowVolume=p,n._offsetAttribute=-1===g?void 0:g,n):(K.granularity=s,K.height=l,K.rotation=u,K.stRotation=c,K.extrudedHeight=m,K.shadowVolume=p,K.offsetAttribute=-1===g?void 0:g,new Y(K))},Y.computeRectangle=function(t,e){let n=(t=t??A.EMPTY_OBJECT).rectangle;if(k.typeOf.object("rectangle",n),h._validate(n),n.north<n.south)throw new x("options.rectangle.north must be greater than or equal to options.rectangle.south");let o=t.granularity??v.RADIANS_PER_DEGREE,a=t.ellipsoid??b.default;return B(n,o,t.rotation??0,a,e)};var q=new w,W=new p,Q=new _;Y.createGeometry=function(s){let l,g;if(v.equalsEpsilon(s._rectangle.north,s._rectangle.south,v.EPSILON10)||v.equalsEpsilon(s._rectangle.east,s._rectangle.west,v.EPSILON10))return;let _=s._rectangle,y=s._ellipsoid,b=s._rotation,A=s._stRotation,x=s._vertexFormat,k=t.computeOptions(_,s._granularity,b,A,O,V,z);if(0!==A||0!==b){let t=h.center(_,Q),e=y.geodeticSurfaceNormalCartographic(t,j);p.fromAxisAngle(e,-A,W),w.fromQuaternion(W,q)}else w.clone(w.IDENTITY,q);let L=s._surfaceHeight,U=s._extrudedHeight,B=!v.equalsEpsilon(L,U,0,v.EPSILON2);if(k.lonScalar=1/s._rectangle.width,k.latScalar=1/s._rectangle.height,k.tangentRotationMatrix=q,_=s._rectangle,B){l=function(t,s){let l=t._shadowVolume,u=t._offsetAttribute,m=t._vertexFormat,p=t._extrudedHeight,h=t._surfaceHeight,g=t._ellipsoid,_=s.height,y=s.width,b;if(l){let e=a.clone(m,C);e.normal=!0,t._vertexFormat=e}let w=I(t,s);l&&(t._vertexFormat=m);let A=r.scaleToGeodeticHeight(w.attributes.position.values,h,g,!1),x=(A=new Float64Array(A)).length,k=2*x,O=new Float64Array(k);O.set(A);let L=r.scaleToGeodeticHeight(w.attributes.position.values,p,g);O.set(L,x),w.attributes.position.values=O;let N=m.normal?new Float32Array(k):void 0,D=m.tangent?new Float32Array(k):void 0,U=m.bitangent?new Float32Array(k):void 0,V=m.st?new Float32Array(k/3*2):void 0,z,B;if(m.normal){for(B=w.attributes.normal.values,N.set(B),b=0;b<x;b++)B[b]=-B[b];N.set(B,x),w.attributes.normal.values=N}if(l){B=w.attributes.normal.values,m.normal||(w.attributes.normal=void 0);let t=new Float32Array(k);for(b=0;b<x;b++)B[b]=-B[b];t.set(B,x),w.attributes.extrudeDirection=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:t})}let Y,J=R(u);if(J){let t=x/3*2,e=new Uint8Array(t);u===o.TOP?e=e.fill(1,0,t/2):(Y=+(u!==o.NONE),e=e.fill(Y)),w.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(m.tangent){let t=w.attributes.tangent.values;for(D.set(t),b=0;b<x;b++)t[b]=-t[b];D.set(t,x),w.attributes.tangent.values=D}if(m.bitangent){let t=w.attributes.bitangent.values;U.set(t),U.set(t,x),w.attributes.bitangent.values=U}m.st&&(z=w.attributes.st.values,V.set(z),V.set(z,x/3*2),w.attributes.st.values=V);let X=w.indices,K=X.length,q=x/3,W=i.createTypedArray(k/3,2*K);for(W.set(X),b=0;b<K;b+=3)W[b+K]=X[b+2]+q,W[b+1+K]=X[b+1]+q,W[b+2+K]=X[b]+q;w.indices=W;let Q=s.northCap,Z=s.southCap,$=_,tt=2,te=0,tn=4,to=4;Q&&(tt-=1,$-=1,te+=1,tn-=2,to-=1),Z&&(tt-=1,$-=1,te+=1,tn-=2,to-=1);let ta=((te+=tt*y+2*$-tn)+to)*2,tr=new Float64Array(3*ta),ti=l?new Float32Array(3*ta):void 0,ts=J?new Uint8Array(ta):void 0,tl=m.st?new Float32Array(2*ta):void 0,tu=u===o.TOP;J&&!tu&&(Y=+(u===o.ALL),ts=ts.fill(Y));let tc=0,tm=0,tp=0,th=0,tg=y*$,tf;for(b=0;b<tg;b+=y)tr=M(tr,tc,tf=3*b,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);if(Z){let t=Q?tg+1:tg;for(tf=3*t,b=0;b<2;b++)tr=M(tr,tc,tf,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*t,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1)}else for(b=tg-y;b<tg;b++)tr=M(tr,tc,tf=3*b,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);for(b=tg-1;b>0;b-=y)tr=M(tr,tc,tf=3*b,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);if(Q)for(tf=3*tg,b=0;b<2;b++)tr=M(tr,tc,tf,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*tg,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);else for(b=y-1;b>=0;b--)tr=M(tr,tc,tf=3*b,A,L),tc+=6,m.st&&(tl=G(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=B[tf],ti[tp++]=B[tf+1],ti[tp++]=B[tf+2]),tu&&(ts[th++]=1,th+=1);let td=function(t,e,n){let o=t.length,a=e.normal?new Float32Array(o):void 0,r=e.tangent?new Float32Array(o):void 0,i=e.bitangent?new Float32Array(o):void 0,s=0,l=0,u=0,c=!0,m=T,p=P,h=F;if(e.normal||e.tangent||e.bitangent)for(let g=0;g<o;g+=6){let f=d.fromArray(t,g,E),_=d.fromArray(t,(g+6)%o,j);if(c){let e=d.fromArray(t,(g+3)%o,H);d.subtract(_,f,_),d.subtract(e,f,e),h=d.normalize(d.cross(e,_,h),h),c=!1}d.equalsEpsilon(_,f,v.EPSILON10)&&(c=!0),(e.tangent||e.bitangent)&&(m=n.geodeticSurfaceNormal(f,m),e.tangent&&(p=d.normalize(d.cross(m,h,p),p))),e.normal&&(a[s++]=h.x,a[s++]=h.y,a[s++]=h.z,a[s++]=h.x,a[s++]=h.y,a[s++]=h.z),e.tangent&&(r[l++]=p.x,r[l++]=p.y,r[l++]=p.z,r[l++]=p.x,r[l++]=p.y,r[l++]=p.z),e.bitangent&&(i[u++]=m.x,i[u++]=m.y,i[u++]=m.z,i[u++]=m.x,i[u++]=m.y,i[u++]=m.z)}return S(e,{positions:t,normals:a,tangents:r,bitangents:i})}(tr,m,g);m.st&&(td.attributes.st=new c({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:tl})),l&&(td.attributes.extrudeDirection=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:ti})),J&&(td.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:ts}));let t_=i.createTypedArray(ta,6*te),ty,tb,tw,tA;x=tr.length/3;let tv=0;for(b=0;b<x-1;b+=2){tA=((ty=b)+2)%x;let t=d.fromArray(tr,3*ty,j),e=d.fromArray(tr,3*tA,H);d.equalsEpsilon(t,e,v.EPSILON10)||(tw=((tb=(ty+1)%x)+2)%x,t_[tv++]=ty,t_[tv++]=tb,t_[tv++]=tA,t_[tv++]=tA,t_[tv++]=tb,t_[tv++]=tw)}return td.indices=t_,(td=n.combineInstances([new e({geometry:w}),new e({geometry:td})]))[0]}(s,k);let t=m.fromRectangle3D(_,y,L,D),u=m.fromRectangle3D(_,y,U,N);g=m.union(t,u)}else{if((l=I(s,k)).attributes.position.values=r.scaleToGeodeticHeight(l.attributes.position.values,L,y,!1),R(s._offsetAttribute)){let t=l.attributes.position.values.length,e=+(s._offsetAttribute!==o.NONE),n=new Uint8Array(t/3).fill(e);l.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}g=m.fromRectangle3D(_,y,L)}return x.position||delete l.attributes.position,new u({attributes:l.attributes,indices:l.indices,primitiveType:l.primitiveType,boundingSphere:g,offsetAttribute:s._offsetAttribute})},Y.createShadowVolume=function(t,e,n){let o=t._granularity,r=t._ellipsoid,i=e(o,r),s=n(o,r);return new Y({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:r,stRotation:t._stRotation,granularity:o,extrudedHeight:s,height:i,vertexFormat:a.POSITION_ONLY,shadowVolume:!0})};var Z=new h,$=[new y,new y,new y],tt=new g,te=new _;Object.defineProperties(Y.prototype,{rectangle:{get:function(){return R(this._rotatedRectangle)||(this._rotatedRectangle=B(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return R(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];let e=h.clone(t._rectangle,Z),n=t._granularity,o=t._ellipsoid,a=B(e,n,t._rotation-t._stRotation,o,Z);$[0].x=a.west,$[0].y=a.south,$[1].x=a.west,$[1].y=a.north,$[2].x=a.east,$[2].y=a.south;let r=t.rectangle,i=g.fromRotation(t._stRotation,tt),s=h.center(r,te);for(let t=0;t<3;++t){let e=$[t];e.x-=s.longitude,e.y-=s.latitude,g.multiplyByVector(i,e,e),e.x+=s.longitude,e.y+=s.latitude,e.x=(e.x-r.west)/r.width,e.y=(e.y-r.south)/r.height}let l=$[0],u=$[1],c=$[2],m=Array(6);return y.pack(l,m),y.pack(u,m,2),y.pack(c,m,4),m}(this)),this._textureCoordinateRotationPoints}}});var tn=function(t,e){return R(e)&&(t=Y.unpack(t,e)),t._ellipsoid=b.clone(t._ellipsoid),t._rectangle=h.clone(t._rectangle),Y.createGeometry(t)};export{tn as default};