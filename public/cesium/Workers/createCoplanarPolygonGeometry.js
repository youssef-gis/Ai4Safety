import{a as t}from"./chunk-U6GWZBRL.js";import{a as e}from"./chunk-42MGKNSS.js";import"./chunk-SCO7TMKT.js";import{a as n}from"./chunk-3WSHJXU2.js";import"./chunk-OXJ2LJUE.js";import{a as o}from"./chunk-2ZPEMRCT.js";import{a as r}from"./chunk-3BSRJTW3.js";import"./chunk-VHZAK4GN.js";import"./chunk-OFCC6BNI.js";import{a as i}from"./chunk-APG2S62J.js";import"./chunk-ET7KY3BS.js";import"./chunk-CUP6SILZ.js";import{b as a}from"./chunk-IYO6TYGP.js";import{a as s}from"./chunk-AZLP5742.js";import"./chunk-5HPISDSZ.js";import"./chunk-HSJ6GSLC.js";import"./chunk-SXKYZMEL.js";import{a as c}from"./chunk-T6Q6HX5J.js";import{a as p}from"./chunk-4MJDNHOT.js";import{b as l,c as u,d as m}from"./chunk-EDF5FKWJ.js";import{d as h}from"./chunk-XQIJGAVD.js";import{g as y}from"./chunk-UTYWXSQT.js";import{a as g}from"./chunk-RCHWDG3R.js";import"./chunk-4WJUWBRK.js";import"./chunk-5G23AKP3.js";import{a as d,c as k,d as f,e as w,f as j}from"./chunk-KWAHJ72S.js";import{a as T}from"./chunk-MKDADUG3.js";import{b as x}from"./chunk-NOIUI5SY.js";import{e as A}from"./chunk-XRRBRTKL.js";var v=new d,P=new t,_=new k,F=new k,L=new d,b=new d,H=new d,R=new d,S=new d,D=new d,E=new y,C=new w,I=new w,O=new d;function G(t){let e=(t=t??j.EMPTY_OBJECT).polygonHierarchy,o=t.textureCoordinates;x.defined("options.polygonHierarchy",e);let r=t.vertexFormat??i.DEFAULT;this._vertexFormat=i.clone(r),this._polygonHierarchy=e,this._stRotation=t.stRotation??0,this._ellipsoid=f.clone(t.ellipsoid??f.default),this._workerName="createCoplanarPolygonGeometry",this._textureCoordinates=o,this.packedLength=n.computeHierarchyPackedLength(e,d)+i.packedLength+f.packedLength+(A(o)?n.computeHierarchyPackedLength(o,k):1)+2}G.fromPositions=function(t){return t=t??j.EMPTY_OBJECT,x.defined("options.positions",t.positions),new G({polygonHierarchy:{positions:t.positions},vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,textureCoordinates:t.textureCoordinates})},G.pack=function(t,e,o){return x.typeOf.object("value",t),x.defined("array",e),o=o??0,o=n.packPolygonHierarchy(t._polygonHierarchy,e,o,d),f.pack(t._ellipsoid,e,o),o+=f.packedLength,i.pack(t._vertexFormat,e,o),o+=i.packedLength,e[o++]=t._stRotation,A(t._textureCoordinates)?o=n.packPolygonHierarchy(t._textureCoordinates,e,o,k):e[o++]=-1,e[o++]=t.packedLength,e};var J=f.clone(f.UNIT_SPHERE),B=new i,K={polygonHierarchy:{}};G.unpack=function(t,e,o){x.defined("array",t),e=e??0;let r=n.unpackPolygonHierarchy(t,e,d);e=r.startingIndex,delete r.startingIndex;let a=f.unpack(t,e,J);e+=f.packedLength;let s=i.unpack(t,e,B);e+=i.packedLength;let c=t[e++],p=-1===t[e]?void 0:n.unpackPolygonHierarchy(t,e,k);A(p)?(e=p.startingIndex,delete p.startingIndex):e++;let l=t[e++];return A(o)||(o=new G(K)),o._polygonHierarchy=r,o._ellipsoid=f.clone(a,o._ellipsoid),o._vertexFormat=i.clone(s,o._vertexFormat),o._stRotation=c,o._textureCoordinates=p,o.packedLength=l,o},G.createGeometry=function(t){let i=t._vertexFormat,f=t._polygonHierarchy,j=t._stRotation,x=t._textureCoordinates,G=A(x),J=f.positions;if((J=s(J,d.equalsEpsilon,!0)).length<3)return;let B=L,K=b,N=H,U=S;if(!e.computeProjectTo2DArguments(J,R,U,D))return;if(B=d.cross(U,D,B),B=d.normalize(B,B),!d.equalsEpsilon(R,d.ZERO,T.EPSILON6)){let e=t._ellipsoid.geodeticSurfaceNormal(R,O);0>d.dot(B,e)&&(B=d.negate(B,B),U=d.negate(U,U))}let W=e.createProjectPointsTo2DFunction(R,U,D),Y=e.createProjectPointTo2DFunction(R,U,D);i.tangent&&(K=d.clone(U,K)),i.bitangent&&(N=d.clone(D,N));let M=n.polygonsFromHierarchy(f,G,W,!1),X=M.hierarchy,Z=M.polygons,z=G?n.polygonsFromHierarchy(x,!0,function(t){return t},!1).polygons:void 0;if(0===X.length)return;J=X[0].outerRing;let Q=h.fromPoints(J),V=n.computeBoundingRectangle(B,Y,J,j,P),q=[];for(let t=0;t<Z.length;t++){let e=new o({geometry:function(t,e,n,o,r,i,s,h,f){let j=t.positions,x=a.triangulate(t.positions2D,t.holes);x.length<3&&(x=[0,1,2]);let P=c.createTypedArray(j.length,x.length);P.set(x);let L=C;if(0!==o){let t=y.fromAxisAngle(s,o,E);if(L=w.fromQuaternion(t,L),e.tangent||e.bitangent){t=y.fromAxisAngle(s,-o,E);let n=w.fromQuaternion(t,I);h=d.normalize(w.multiplyByVector(n,h,h),h),e.bitangent&&(f=d.normalize(d.cross(s,h,f),f))}}else L=w.clone(w.IDENTITY,L);e.st&&(F.x=n.x,F.y=n.y);let b=j.length,H=3*b,R=new Float64Array(H),S=e.normal?new Float32Array(H):void 0,D=e.tangent?new Float32Array(H):void 0,O=e.bitangent?new Float32Array(H):void 0,G=e.st?new Float32Array(2*b):void 0,J=0,B=0,K=0,N=0,U=0;for(let t=0;t<b;t++){let o=j[t];if(R[J++]=o.x,R[J++]=o.y,R[J++]=o.z,e.st)if(A(r)&&r.positions.length===b)G[U++]=r.positions[t].x,G[U++]=r.positions[t].y;else{let t=i(w.multiplyByVector(L,o,v),_);k.subtract(t,F,t);let e=T.clamp(t.x/n.width,0,1),r=T.clamp(t.y/n.height,0,1);G[U++]=e,G[U++]=r}e.normal&&(S[B++]=s.x,S[B++]=s.y,S[B++]=s.z),e.tangent&&(D[N++]=h.x,D[N++]=h.y,D[N++]=h.z),e.bitangent&&(O[K++]=f.x,O[K++]=f.y,O[K++]=f.z)}let W=new p;return e.position&&(W.position=new m({componentDatatype:g.DOUBLE,componentsPerAttribute:3,values:R})),e.normal&&(W.normal=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:S})),e.tangent&&(W.tangent=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:D})),e.bitangent&&(W.bitangent=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:O})),e.st&&(W.st=new m({componentDatatype:g.FLOAT,componentsPerAttribute:2,values:G})),new u({attributes:W,indices:P,primitiveType:l.TRIANGLES})}(Z[t],i,V,j,G?z[t]:void 0,Y,B,K,N)});q.push(e)}let $=r.combineInstances(q)[0];$.attributes.position.values=new Float64Array($.attributes.position.values),$.indices=c.createTypedArray($.attributes.position.values.length/3,$.indices);let tt=$.attributes;return i.position||delete tt.position,new u({attributes:tt,indices:$.indices,primitiveType:$.primitiveType,boundingSphere:Q})};var N=function(t,e){return A(e)&&(t=G.unpack(t,e)),G.createGeometry(t)};export{N as default};