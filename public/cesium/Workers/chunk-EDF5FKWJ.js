import{b as t,g as e,h as n,i as i,j as r}from"./chunk-UTYWXSQT.js";import{a as o}from"./chunk-4WJUWBRK.js";import{a as s,b as a,c as u,e as p,f as m}from"./chunk-KWAHJ72S.js";import{a as N,b as c}from"./chunk-NOIUI5SY.js";import{e as I}from"./chunk-XRRBRTKL.js";var l=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3}),h={POINTS:o.POINTS,LINES:o.LINES,LINE_LOOP:o.LINE_LOOP,LINE_STRIP:o.LINE_STRIP,TRIANGLES:o.TRIANGLES,TRIANGLE_STRIP:o.TRIANGLE_STRIP,TRIANGLE_FAN:o.TRIANGLE_FAN};h.isLines=function(t){return t===h.LINES||t===h.LINE_LOOP||t===h.LINE_STRIP},h.isTriangles=function(t){return t===h.TRIANGLES||t===h.TRIANGLE_STRIP||t===h.TRIANGLE_FAN},h.validate=function(t){return t===h.POINTS||t===h.LINES||t===h.LINE_LOOP||t===h.LINE_STRIP||t===h.TRIANGLES||t===h.TRIANGLE_STRIP||t===h.TRIANGLE_FAN};var T=Object.freeze(h);function b(t){t=t??m.EMPTY_OBJECT,c.typeOf.object("options.attributes",t.attributes),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=t.primitiveType??T.TRIANGLES,this.boundingSphere=t.boundingSphere,this.geometryType=t.geometryType??l.NONE,this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}b.computeNumberOfVertices=function(t){c.typeOf.object("geometry",t);let e=-1;for(let n in t.attributes)if(t.attributes.hasOwnProperty(n)&&I(t.attributes[n])&&I(t.attributes[n].values)){let i=t.attributes[n],r=i.values.length/i.componentsPerAttribute;if(e!==r&&-1!==e)throw new N("All attribute lists must have the same number of attributes.");e=r}return e};var f=new a,L=new s,y=new t,A=[new a,new a,new a],E=[new u,new u,new u],w=[new u,new u,new u],P=new s,S=new e,R=new t,O=new r;b._textureCoordinateRotationPoints=function(o,m,N,c){let I,l=i.center(c,f),h=a.toCartesian(l,N,L),T=n.eastNorthUpToFixedFrame(h,N,y),b=t.inverse(T,y);A[0].longitude=c.west,A[0].latitude=c.south,A[1].longitude=c.west,A[1].latitude=c.north,A[2].longitude=c.east,A[2].latitude=c.south;let d=P;for(I=0;I<3;I++)a.toCartesian(A[I],N,d),d=t.multiplyByPointAsVector(b,d,d),E[I].x=d.x,E[I].y=d.y;let _=e.fromAxisAngle(s.UNIT_Z,-m,S),x=p.fromQuaternion(_,R),g=o.length,v=1/0,G=1/0,j=-1/0,k=-1/0;for(I=0;I<g;I++)d=t.multiplyByPointAsVector(b,o[I],d),v=Math.min(v,(d=p.multiplyByVector(x,d,d)).x),G=Math.min(G,d.y),j=Math.max(j,d.x),k=Math.max(k,d.y);let B=r.fromRotation(m,O);w[0].x=v,w[0].y=G,w[1].x=v,w[1].y=k,w[2].x=j,w[2].y=G;let C=E[0],F=E[2].x-C.x,M=E[1].y-C.y;for(I=0;I<3;I++){let t=w[I];r.multiplyByVector(B,t,t),t.x=(t.x-C.x)/F,t.y=(t.y-C.y)/M}let V=w[0],U=w[1],Y=w[2],z=Array(6);return u.pack(V,z),u.pack(U,z,2),u.pack(Y,z,4),z};var d=b,_=function(t){if(!I((t=t??m.EMPTY_OBJECT).componentDatatype))throw new N("options.componentDatatype is required.");if(!I(t.componentsPerAttribute))throw new N("options.componentsPerAttribute is required.");if(t.componentsPerAttribute<1||t.componentsPerAttribute>4)throw new N("options.componentsPerAttribute must be between 1 and 4.");if(!I(t.values))throw new N("options.values is required.");this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=t.normalize??!1,this.values=t.values};export{l as a,T as b,d as c,_ as d};