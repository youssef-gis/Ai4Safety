import{a as e}from"./chunk-YHWHVNY2.js";import{a as t}from"./chunk-T77EB7BE.js";import{a as i}from"./chunk-T6Q6HX5J.js";import{a as r}from"./chunk-4MJDNHOT.js";import{b as n,c as o,d as s}from"./chunk-EDF5FKWJ.js";import{d as a}from"./chunk-XQIJGAVD.js";import{a as u}from"./chunk-RCHWDG3R.js";import{a as l,d as c,f as f}from"./chunk-KWAHJ72S.js";import{a as h}from"./chunk-MKDADUG3.js";import{a as m}from"./chunk-NOIUI5SY.js";import{e as d}from"./chunk-XRRBRTKL.js";var p=new l,_=new l,A=new a,g=new a;function b(e){let t=(e=e??f.EMPTY_OBJECT).center,i=e.ellipsoid??c.default,r=e.semiMajorAxis,n=e.semiMinorAxis,o=e.granularity??h.RADIANS_PER_DEGREE;if(!d(t))throw new m("center is required.");if(!d(r))throw new m("semiMajorAxis is required.");if(!d(n))throw new m("semiMinorAxis is required.");if(r<n)throw new m("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(o<=0)throw new m("granularity must be greater than zero.");let s=e.height??0,a=e.extrudedHeight??s;this._center=l.clone(t),this._semiMajorAxis=r,this._semiMinorAxis=n,this._ellipsoid=c.clone(i),this._rotation=e.rotation??0,this._height=Math.max(a,s),this._granularity=o,this._extrudedHeight=Math.min(a,s),this._numberOfVerticalLines=Math.max(e.numberOfVerticalLines??16,0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}b.packedLength=l.packedLength+c.packedLength+8,b.pack=function(e,t,i){if(!d(e))throw new m("value is required");if(!d(t))throw new m("array is required");return i=i??0,l.pack(e._center,t,i),i+=l.packedLength,c.pack(e._ellipsoid,t,i),i+=c.packedLength,t[i++]=e._semiMajorAxis,t[i++]=e._semiMinorAxis,t[i++]=e._rotation,t[i++]=e._height,t[i++]=e._granularity,t[i++]=e._extrudedHeight,t[i++]=e._numberOfVerticalLines,t[i]=e._offsetAttribute??-1,t};var x=new l,w=new c,M={center:x,ellipsoid:w,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};b.unpack=function(e,t,i){if(!d(e))throw new m("array is required");t=t??0;let r=l.unpack(e,t,x);t+=l.packedLength;let n=c.unpack(e,t,w);t+=c.packedLength;let o=e[t++],s=e[t++],a=e[t++],u=e[t++],f=e[t++],h=e[t++],p=e[t++],_=e[t];return d(i)?(i._center=l.clone(r,i._center),i._ellipsoid=c.clone(n,i._ellipsoid),i._semiMajorAxis=o,i._semiMinorAxis=s,i._rotation=a,i._height=u,i._granularity=f,i._extrudedHeight=h,i._numberOfVerticalLines=p,i._offsetAttribute=-1===_?void 0:_,i):(M.height=u,M.extrudedHeight=h,M.granularity=f,M.rotation=a,M.semiMajorAxis=o,M.semiMinorAxis=s,M.numberOfVerticalLines=p,M.offsetAttribute=-1===_?void 0:_,new b(M))},b.createGeometry=function(c){if(c._semiMajorAxis<=0||c._semiMinorAxis<=0)return;let f=c._height,m=c._extrudedHeight,b=!h.equalsEpsilon(f,m,0,h.EPSILON2);c._center=c._ellipsoid.scaleToGeodeticSurface(c._center,c._center);let x={center:c._center,semiMajorAxis:c._semiMajorAxis,semiMinorAxis:c._semiMinorAxis,ellipsoid:c._ellipsoid,rotation:c._rotation,height:f,granularity:c._granularity,numberOfVerticalLines:c._numberOfVerticalLines},w;if(b)x.extrudedHeight=m,x.offsetAttribute=c._offsetAttribute,w=function(n){let o,c=n.center,f=n.ellipsoid,m=n.semiMajorAxis,_=l.multiplyByScalar(f.geodeticSurfaceNormal(c,p),n.height,p);A.center=l.add(c,_,A.center),A.radius=m,_=l.multiplyByScalar(f.geodeticSurfaceNormal(c,_),n.extrudedHeight,_),g.center=l.add(c,_,g.center),g.radius=m;let b=e.computeEllipsePositions(n,!1,!0).outerPositions,x=new r({position:new s({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:e.raisePositionsToHeight(b,n,!0)})});b=x.position.values;let w=a.union(A,g),M=b.length/3;if(d(n.offsetAttribute)){let e=new Uint8Array(M);if(n.offsetAttribute===t.TOP)e=e.fill(1,0,M/2);else{let i=+(n.offsetAttribute!==t.NONE);e=e.fill(i)}x.applyOffset=new s({componentDatatype:u.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let y=n.numberOfVerticalLines??16;y=h.clamp(y,0,M/2);let k=i.createTypedArray(M,2*M+2*y);M/=2;let j=0,E;for(E=0;E<M;++E)k[j++]=E,k[j++]=(E+1)%M,k[j++]=E+M,k[j++]=(E+1)%M+M;if(y>0){let e=Math.min(y,M),t=Math.min((o=Math.round(M/e))*y,M);for(E=0;E<t;E+=o)k[j++]=E,k[j++]=E+M}return{boundingSphere:w,attributes:x,indices:k}}(x);else if(w=function(t){let n=t.center;_=l.multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(n,_),t.height,_);let o=new a(_=l.add(n,_,_),t.semiMajorAxis),c=e.computeEllipsePositions(t,!1,!0).outerPositions,f=new r({position:new s({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:e.raisePositionsToHeight(c,t,!1)})}),h=c.length/3,m=i.createTypedArray(h,2*h),d=0;for(let e=0;e<h;++e)m[d++]=e,m[d++]=(e+1)%h;return{boundingSphere:o,attributes:f,indices:m}}(x),d(c._offsetAttribute)){let e=w.attributes.position.values.length,i=+(c._offsetAttribute!==t.NONE),r=new Uint8Array(e/3).fill(i);w.attributes.applyOffset=new s({componentDatatype:u.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new o({attributes:w.attributes,indices:w.indices,primitiveType:n.LINES,boundingSphere:w.boundingSphere,offsetAttribute:c._offsetAttribute})};var y=b;export{y as a};