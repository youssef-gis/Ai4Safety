import{a as e}from"./chunk-YY6GMQGO.js";import{a as t,b as i}from"./chunk-BJAB7QAF.js";import{a as n}from"./chunk-D2NFCOGE.js";import{a as r}from"./chunk-XBWRWNYZ.js";import"./chunk-VHZAK4GN.js";import{a as o}from"./chunk-CUP6SILZ.js";import{a as a}from"./chunk-T6Q6HX5J.js";import"./chunk-XQIJGAVD.js";import{b as s,h as c,i as h}from"./chunk-UTYWXSQT.js";import"./chunk-RCHWDG3R.js";import"./chunk-4WJUWBRK.js";import"./chunk-5G23AKP3.js";import{a as l,b as u,c as m,d as d}from"./chunk-KWAHJ72S.js";import{a as g}from"./chunk-MKDADUG3.js";import"./chunk-NOIUI5SY.js";import{e as p}from"./chunk-XRRBRTKL.js";var f=new l,y=new l,I=new l,k=new u,x=new m;function T(e,t,i,n,r,o,a,c,h){let u=1/0,m=r.north,d=r.south,p=r.east,y=r.west;p<y&&(p+=g.TWO_PI);let I=e.length;for(let r=0;r<I;++r){let I=e[r],x=i[I],T=n[I];k.longitude=g.lerp(y,p,T.x),k.latitude=g.lerp(d,m,T.y),k.height=x-t;let S=o.cartographicToCartesian(k,f);s.multiplyByPoint(a,S,S),l.minimumByComponent(S,c,c),l.maximumByComponent(S,h,h),u=Math.min(u,k.height)}return u}function S(e,t,i,n,o,a,s,c,h,l,u,m,d,y){let I=p(s),T=h.north,S=h.south,w=h.east,A=h.west;w<A&&(w+=g.TWO_PI);let H=i.length;for(let h=0;h<H;++h){let p,H,M=i[h],j=o[M],W=a[M];k.longitude=g.lerp(A,w,W.x)+d,k.latitude=g.lerp(S,T,W.y)+y,k.height=j-l;let b=c.cartographicToCartesian(k,f);if(I){let e=2*M;x.x=s[e],x.y=s[e+1]}n.hasWebMercatorT&&(p=(r.geodeticLatitudeToMercatorAngle(k.latitude)-u)*m),n.hasGeodeticSurfaceNormals&&(H=c.geodeticSurfaceNormal(b)),t=n.encode(e,t,b,W,k.height,x,p,H)}}function w(e,t){let i;return"function"==typeof e.slice&&"function"!=typeof(i=e.slice()).sort&&(i=void 0),p(i)||(i=Array.prototype.slice.call(e)),i.sort(t),i}var A=n(function(n,u){let A=n.quantizedVertices,H=A.length/3,M=n.octEncodedNormals,j=n.westIndices.length+n.eastIndices.length+n.southIndices.length+n.northIndices.length,W=n.includeWebMercatorT,b=n.exaggeration,C=n.exaggerationRelativeHeight,B=1!==b,N=h.clone(n.rectangle),G=N.west,P=N.south,v=N.east,R=N.north,U=d.clone(n.ellipsoid),K=n.minimumHeight,L=n.maximumHeight,D=n.relativeToCenter,E=c.eastNorthUpToFixedFrame(D,U),F=s.inverseTransformation(E,new s),J,O;W&&(J=r.geodeticLatitudeToMercatorAngle(P),O=1/(r.geodeticLatitudeToMercatorAngle(R)-J));let Q=A.subarray(0,H),X=A.subarray(H,2*H),Y=A.subarray(2*H,3*H),z=p(M),V=Array(H),Z=Array(H),_=Array(H),q=W?Array(H):[],$=B?Array(H):[];y.x=1/0,y.y=1/0,y.z=1/0,I.x=-1/0,I.y=-1/0,I.z=-1/0;let ee=1/0,et=-1/0,ei=1/0,en=-1/0;for(let e=0;e<H;++e){let t=Q[e],i=X[e],n=t/32767,o=i/32767,a=g.lerp(K,L,Y[e]/32767);k.longitude=g.lerp(G,v,n),k.latitude=g.lerp(P,R,o),k.height=a,ee=Math.min(k.longitude,ee),et=Math.max(k.longitude,et),ei=Math.min(k.latitude,ei),en=Math.max(k.latitude,en);let c=U.cartographicToCartesian(k);V[e]=new m(n,o),Z[e]=a,_[e]=c,W&&(q[e]=(r.geodeticLatitudeToMercatorAngle(k.latitude)-J)*O),B&&($[e]=U.geodeticSurfaceNormal(c)),s.multiplyByPoint(F,c,f),l.minimumByComponent(f,y,y),l.maximumByComponent(f,I,I)}let er=w(n.westIndices,function(e,t){return V[e].y-V[t].y}),eo=w(n.eastIndices,function(e,t){return V[t].y-V[e].y}),ea=w(n.southIndices,function(e,t){return V[t].x-V[e].x}),es=w(n.northIndices,function(e,t){return V[e].x-V[t].x}),ec;K<0&&(ec=new t(U).computeHorizonCullingPointPossiblyUnderEllipsoid(D,_,K));let eh=K;eh=Math.min(eh=Math.min(eh=Math.min(eh=Math.min(eh,T(n.westIndices,n.westSkirtHeight,Z,V,N,U,F,y,I)),T(n.southIndices,n.southSkirtHeight,Z,V,N,U,F,y,I)),T(n.eastIndices,n.eastSkirtHeight,Z,V,N,U,F,y,I)),T(n.northIndices,n.northSkirtHeight,Z,V,N,U,F,y,I));let el=new o(y,I,D),eu=new i(D,el,eh,L,E,z,W,B,b,C),em=eu.stride,ed=new Float32Array(H*em+j*em),eg=0;for(let e=0;e<H;++e){if(z){let t=2*e;x.x=M[t],x.y=M[t+1]}eg=eu.encode(ed,eg,_[e],V[e],Z[e],x,q[e],$[e])}let ep=Math.max(0,(j-4)*2),ef=n.indices.length+3*ep,ey=a.createTypedArray(H+j,ef);ey.set(n.indices,0);let eI=(et-ee)*1e-4,ek=(en-ei)*1e-4,ex=H*em;return S(ed,ex,er,eu,Z,V,M,U,N,n.westSkirtHeight,J,O,-eI,0),S(ed,ex+=n.westIndices.length*em,ea,eu,Z,V,M,U,N,n.southSkirtHeight,J,O,0,-ek),S(ed,ex+=n.southIndices.length*em,eo,eu,Z,V,M,U,N,n.eastSkirtHeight,J,O,eI,0),S(ed,ex+=n.eastIndices.length*em,es,eu,Z,V,M,U,N,n.northSkirtHeight,J,O,0,ek),e.addSkirtIndices(er,ea,eo,es,H,ey,n.indices.length),u.push(ed.buffer,ey.buffer),{vertices:ed.buffer,indices:ey.buffer,westIndicesSouthToNorth:er,southIndicesEastToWest:ea,eastIndicesNorthToSouth:eo,northIndicesWestToEast:es,vertexStride:em,center:D,minimumHeight:K,maximumHeight:L,occludeePointInScaledSpace:ec,encoding:eu,indexCountWithoutSkirts:n.indices.length}});export{A as default};