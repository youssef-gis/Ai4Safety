import{a as r}from"./chunk-4WJUWBRK.js";import{a as e}from"./chunk-MKDADUG3.js";import{a as t}from"./chunk-NOIUI5SY.js";import{e as n}from"./chunk-XRRBRTKL.js";var a={UNSIGNED_BYTE:r.UNSIGNED_BYTE,UNSIGNED_SHORT:r.UNSIGNED_SHORT,UNSIGNED_INT:r.UNSIGNED_INT};a.getSizeInBytes=function(r){switch(r){case a.UNSIGNED_BYTE:return Uint8Array.BYTES_PER_ELEMENT;case a.UNSIGNED_SHORT:return Uint16Array.BYTES_PER_ELEMENT;case a.UNSIGNED_INT:return Uint32Array.BYTES_PER_ELEMENT}throw new t("indexDatatype is required and must be a valid IndexDatatype constant.")},a.fromSizeInBytes=function(r){switch(r){case 2:return a.UNSIGNED_SHORT;case 4:return a.UNSIGNED_INT;case 1:return a.UNSIGNED_BYTE;default:throw new t("Size in bytes cannot be mapped to an IndexDatatype")}},a.validate=function(r){return n(r)&&(r===a.UNSIGNED_BYTE||r===a.UNSIGNED_SHORT||r===a.UNSIGNED_INT)},a.createTypedArray=function(r,a){if(!n(r))throw new t("numberOfVertices is required.");return r>=e.SIXTY_FOUR_KILOBYTES?new Uint32Array(a):new Uint16Array(a)},a.createTypedArrayFromArrayBuffer=function(r,a,i,N){if(!n(r))throw new t("numberOfVertices is required.");if(!n(a))throw new t("sourceArray is required.");if(!n(i))throw new t("byteOffset is required.");return r>=e.SIXTY_FOUR_KILOBYTES?new Uint32Array(a,i,N):new Uint16Array(a,i,N)},a.fromTypedArray=function(r){if(r instanceof Uint8Array)return a.UNSIGNED_BYTE;if(r instanceof Uint16Array)return a.UNSIGNED_SHORT;if(r instanceof Uint32Array)return a.UNSIGNED_INT;throw new t("array must be a Uint8Array, Uint16Array, or Uint32Array.")};var i=Object.freeze(a);export{i as a};