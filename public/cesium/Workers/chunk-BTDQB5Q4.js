import{a as t}from"./chunk-XQDTMI7Q.js";import{a as e}from"./chunk-T77EB7BE.js";import{a as o}from"./chunk-APG2S62J.js";import{a as n}from"./chunk-T6Q6HX5J.js";import{a as r}from"./chunk-4MJDNHOT.js";import{b as a,c as i,d as s}from"./chunk-EDF5FKWJ.js";import{d as u}from"./chunk-XQIJGAVD.js";import{a as m}from"./chunk-RCHWDG3R.js";import{a as f,c as p,f as l}from"./chunk-KWAHJ72S.js";import{a as c}from"./chunk-MKDADUG3.js";import{a as d}from"./chunk-NOIUI5SY.js";import{e as h}from"./chunk-XRRBRTKL.js";var b,w=new p,A=new f,g=new f,y=new f,_=new f;function v(t){let n=(t=t??l.EMPTY_OBJECT).length,r=t.topRadius,a=t.bottomRadius,i=t.vertexFormat??o.DEFAULT,s=t.slices??128;if(!h(n))throw new d("options.length must be defined.");if(!h(r))throw new d("options.topRadius must be defined.");if(!h(a))throw new d("options.bottomRadius must be defined.");if(s<3)throw new d("options.slices must be greater than or equal to 3.");if(h(t.offsetAttribute)&&t.offsetAttribute===e.TOP)throw new d("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=n,this._topRadius=r,this._bottomRadius=a,this._vertexFormat=o.clone(i),this._slices=s,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}v.packedLength=o.packedLength+5,v.pack=function(t,e,n){if(!h(t))throw new d("value is required");if(!h(e))throw new d("array is required");return n=n??0,o.pack(t._vertexFormat,e,n),n+=o.packedLength,e[n++]=t._length,e[n++]=t._topRadius,e[n++]=t._bottomRadius,e[n++]=t._slices,e[n]=t._offsetAttribute??-1,e};var R=new o,k={vertexFormat:R,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};v.unpack=function(t,e,n){if(!h(t))throw new d("array is required");e=e??0;let r=o.unpack(t,e,R);e+=o.packedLength;let a=t[e++],i=t[e++],s=t[e++],u=t[e++],m=t[e];return h(n)?(n._vertexFormat=o.clone(r,n._vertexFormat),n._length=a,n._topRadius=i,n._bottomRadius=s,n._slices=u,n._offsetAttribute=-1===m?void 0:m,n):(k.length=a,k.topRadius=i,k.bottomRadius=s,k.slices=u,k.offsetAttribute=-1===m?void 0:m,new v(k))},v.createGeometry=function(o){let l=o._length,d=o._topRadius,b=o._bottomRadius,v=o._vertexFormat,R=o._slices;if(l<=0||d<0||b<0||0===d&&0===b)return;let k=R+R,T=R+k,x=k+k,F=t.computePositions(l,d,b,R,!0),O=v.st?new Float32Array(2*x):void 0,D=v.normal?new Float32Array(3*x):void 0,L=v.tangent?new Float32Array(3*x):void 0,P=v.bitangent?new Float32Array(3*x):void 0,j,E=v.normal||v.tangent||v.bitangent;if(E){let t=v.tangent||v.bitangent,e=0,o=0,n=0,r=Math.atan2(b-d,l);A.z=Math.sin(r);let a=Math.cos(r),i=y,s=g;for(j=0;j<R;j++){let r=j/R*c.TWO_PI,u=a*Math.cos(r),m=a*Math.sin(r);E&&(A.x=u,A.y=m,t&&(i=f.normalize(f.cross(f.UNIT_Z,A,i),i)),v.normal&&(D[e++]=A.x,D[e++]=A.y,D[e++]=A.z,D[e++]=A.x,D[e++]=A.y,D[e++]=A.z),v.tangent&&(L[o++]=i.x,L[o++]=i.y,L[o++]=i.z,L[o++]=i.x,L[o++]=i.y,L[o++]=i.z),v.bitangent&&(s=f.normalize(f.cross(A,i,s),s),P[n++]=s.x,P[n++]=s.y,P[n++]=s.z,P[n++]=s.x,P[n++]=s.y,P[n++]=s.z))}for(j=0;j<R;j++)v.normal&&(D[e++]=0,D[e++]=0,D[e++]=-1),v.tangent&&(L[o++]=1,L[o++]=0,L[o++]=0),v.bitangent&&(P[n++]=0,P[n++]=-1,P[n++]=0);for(j=0;j<R;j++)v.normal&&(D[e++]=0,D[e++]=0,D[e++]=1),v.tangent&&(L[o++]=1,L[o++]=0,L[o++]=0),v.bitangent&&(P[n++]=0,P[n++]=1,P[n++]=0)}let M=n.createTypedArray(x,12*R-12),N=0,G=0;for(j=0;j<R-1;j++)M[N++]=G,M[N++]=G+2,M[N++]=G+3,M[N++]=G,M[N++]=G+3,M[N++]=G+1,G+=2;for(M[N++]=k-2,M[N++]=0,M[N++]=1,M[N++]=k-2,M[N++]=1,M[N++]=k-1,j=1;j<R-1;j++)M[N++]=k+j+1,M[N++]=k+j,M[N++]=k;for(j=1;j<R-1;j++)M[N++]=T,M[N++]=T+j,M[N++]=T+j+1;let I=0;if(v.st){let t=Math.max(d,b);for(j=0;j<x;j++){let e=f.fromArray(F,3*j,_);O[I++]=(e.x+t)/(2*t),O[I++]=(e.y+t)/(2*t)}}let z=new r;v.position&&(z.position=new s({componentDatatype:m.DOUBLE,componentsPerAttribute:3,values:F})),v.normal&&(z.normal=new s({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:D})),v.tangent&&(z.tangent=new s({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:L})),v.bitangent&&(z.bitangent=new s({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:P})),v.st&&(z.st=new s({componentDatatype:m.FLOAT,componentsPerAttribute:2,values:O})),w.x=.5*l,w.y=Math.max(b,d);let U=new u(f.ZERO,p.magnitude(w));if(h(o._offsetAttribute)){l=F.length;let t=+(o._offsetAttribute!==e.NONE),n=new Uint8Array(l/3).fill(t);z.applyOffset=new s({componentDatatype:m.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new i({attributes:z,indices:M,primitiveType:a.TRIANGLES,boundingSphere:U,offsetAttribute:o._offsetAttribute})},v.getUnitCylinder=function(){return h(b)||(b=v.createGeometry(new v({topRadius:1,bottomRadius:1,length:1,vertexFormat:o.POSITION_ONLY}))),b};var T=v;export{T as a};