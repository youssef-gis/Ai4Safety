import{a as e}from"./chunk-GTQ3WXPT.js";import{a as t}from"./chunk-OXJ2LJUE.js";import{a as o}from"./chunk-QORMFUM4.js";import"./chunk-FWF3VNA2.js";import"./chunk-5HPISDSZ.js";import"./chunk-HSJ6GSLC.js";import"./chunk-SXKYZMEL.js";import{a as r}from"./chunk-T6Q6HX5J.js";import{a as a}from"./chunk-4MJDNHOT.js";import{b as n,c as i,d as l}from"./chunk-EDF5FKWJ.js";import{d as s}from"./chunk-XQIJGAVD.js";import"./chunk-UTYWXSQT.js";import{a as p}from"./chunk-RCHWDG3R.js";import"./chunk-4WJUWBRK.js";import"./chunk-5G23AKP3.js";import{a as c,d as h,f as u}from"./chunk-KWAHJ72S.js";import{a as f}from"./chunk-MKDADUG3.js";import{a as y}from"./chunk-NOIUI5SY.js";import{e as m}from"./chunk-XRRBRTKL.js";function d(o){let r=(o=o??u.EMPTY_OBJECT).positions,a=o.colors,n=o.colorsPerVertex??!1;if(!m(r)||r.length<2)throw new y("At least two positions are required.");if(m(a)&&(n&&a.length<r.length||!n&&a.length<r.length-1))throw new y("colors has an invalid length.");this._positions=r,this._colors=a,this._colorsPerVertex=n,this._arcType=o.arcType??t.GEODESIC,this._granularity=o.granularity??f.RADIANS_PER_DEGREE,this._ellipsoid=o.ellipsoid??h.default,this._workerName="createSimplePolylineGeometry";let i=1+r.length*c.packedLength;i+=m(a)?1+a.length*e.packedLength:1,this.packedLength=i+h.packedLength+3}d.pack=function(t,o,r){if(!m(t))throw new y("value is required");if(!m(o))throw new y("array is required");r=r??0;let a,n=t._positions,i=n.length;for(o[r++]=i,a=0;a<i;++a,r+=c.packedLength)c.pack(n[a],o,r);let l=t._colors;for(i=m(l)?l.length:0,o[r++]=i,a=0;a<i;++a,r+=e.packedLength)e.pack(l[a],o,r);return h.pack(t._ellipsoid,o,r),r+=h.packedLength,o[r++]=+!!t._colorsPerVertex,o[r++]=t._arcType,o[r]=t._granularity,o},d.unpack=function(t,o,r){if(!m(t))throw new y("array is required");o=o??0;let a,n=t[o++],i=Array(n);for(a=0;a<n;++a,o+=c.packedLength)i[a]=c.unpack(t,o);let l=(n=t[o++])>0?Array(n):void 0;for(a=0;a<n;++a,o+=e.packedLength)l[a]=e.unpack(t,o);let s=h.unpack(t,o);o+=h.packedLength;let p=1===t[o++],u=t[o++],f=t[o];return m(r)?(r._positions=i,r._colors=l,r._ellipsoid=s,r._colorsPerVertex=p,r._arcType=u,r._granularity=f,r):new d({positions:i,colors:l,ellipsoid:s,colorsPerVertex:p,arcType:u,granularity:f})};var g=[,,],k=[,,],T={positions:g,height:k,ellipsoid:void 0,minDistance:void 0,granularity:void 0};d.createGeometry=function(h){let u=h._positions,y=h._colors,d=h._colorsPerVertex,_=h._arcType,B=h._granularity,w=h._ellipsoid,A=f.chordLength(B,w.maximumRadius),E=m(y)&&!d,j,D=u.length,L,P,b,S,G=0;if(_===t.GEODESIC||_===t.RHUMB){let r,a,n;_===t.GEODESIC?(r=f.chordLength(B,w.maximumRadius),a=o.numberOfPoints,n=o.generateArc):(r=B,a=o.numberOfPointsRhumbLine,n=o.generateRhumbArc);let i=o.extractHeights(u,w);if(_===t.GEODESIC?T.minDistance=A:T.granularity=B,T.ellipsoid=w,E){let t=0;for(j=0;j<D-1;j++)t+=a(u[j],u[j+1],r)+1;L=new Float64Array(3*t),b=new Uint8Array(4*t),T.positions=g,T.height=k;let o=0;for(j=0;j<D-1;++j){g[0]=u[j],g[1]=u[j+1],k[0]=i[j],k[1]=i[j+1];let t=n(T);if(m(y)){let r=t.length/3;S=y[j];for(let t=0;t<r;++t)b[o++]=e.floatToByte(S.red),b[o++]=e.floatToByte(S.green),b[o++]=e.floatToByte(S.blue),b[o++]=e.floatToByte(S.alpha)}L.set(t,G),G+=t.length}}else if(T.positions=u,T.height=i,L=new Float64Array(n(T)),m(y)){for(b=new Uint8Array(L.length/3*4),j=0;j<D-1;++j)G=function(t,r,a,n,i,l,s){let p=o.numberOfPoints(t,r,i),c,h=a.red,u=a.green,f=a.blue,y=a.alpha,m=n.red,d=n.green,g=n.blue,k=n.alpha;if(e.equals(a,n)){for(c=0;c<p;c++)l[s++]=e.floatToByte(h),l[s++]=e.floatToByte(u),l[s++]=e.floatToByte(f),l[s++]=e.floatToByte(y);return s}let T=(m-h)/p,_=(d-u)/p,B=(g-f)/p,w=(k-y)/p,A=s;for(c=0;c<p;c++)l[A++]=e.floatToByte(h+c*T),l[A++]=e.floatToByte(u+c*_),l[A++]=e.floatToByte(f+c*B),l[A++]=e.floatToByte(y+c*w);return A}(u[j],u[j+1],y[j],y[j+1],A,b,G);let t=y[D-1];b[G++]=e.floatToByte(t.red),b[G++]=e.floatToByte(t.green),b[G++]=e.floatToByte(t.blue),b[G++]=e.floatToByte(t.alpha)}}else{L=new Float64Array(3*(P=E?2*D-2:D)),b=m(y)?new Uint8Array(4*P):void 0;let t=0,o=0;for(j=0;j<D;++j){let r=u[j];if(E&&j>0&&(c.pack(r,L,t),t+=3,S=y[j-1],b[o++]=e.floatToByte(S.red),b[o++]=e.floatToByte(S.green),b[o++]=e.floatToByte(S.blue),b[o++]=e.floatToByte(S.alpha)),E&&j===D-1)break;c.pack(r,L,t),t+=3,m(y)&&(S=y[j],b[o++]=e.floatToByte(S.red),b[o++]=e.floatToByte(S.green),b[o++]=e.floatToByte(S.blue),b[o++]=e.floatToByte(S.alpha))}}let R=new a;R.position=new l({componentDatatype:p.DOUBLE,componentsPerAttribute:3,values:L}),m(y)&&(R.color=new l({componentDatatype:p.UNSIGNED_BYTE,componentsPerAttribute:4,values:b,normalize:!0}));let O=((P=L.length/3)-1)*2,v=r.createTypedArray(P,O),U=0;for(j=0;j<P-1;++j)v[U++]=j,v[U++]=j+1;return new i({attributes:R,indices:v,primitiveType:n.LINES,boundingSphere:s.fromPoints(u)})};var _=function(e,t){return m(t)&&(e=d.unpack(e,t)),e._ellipsoid=h.clone(e._ellipsoid),d.createGeometry(e)};export{_ as default};