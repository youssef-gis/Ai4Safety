import{a as t}from"./chunk-U6GWZBRL.js";import{a as e}from"./chunk-3WSHJXU2.js";import{a as o}from"./chunk-OXJ2LJUE.js";import{a as i}from"./chunk-2ZPEMRCT.js";import{a as n}from"./chunk-3BSRJTW3.js";import"./chunk-VHZAK4GN.js";import"./chunk-OFCC6BNI.js";import{a as r}from"./chunk-T77EB7BE.js";import{a as a}from"./chunk-APG2S62J.js";import{a as s}from"./chunk-ET7KY3BS.js";import"./chunk-CUP6SILZ.js";import{a as l,b as u}from"./chunk-IYO6TYGP.js";import"./chunk-AZLP5742.js";import"./chunk-5HPISDSZ.js";import{a as c,b as h}from"./chunk-HSJ6GSLC.js";import"./chunk-SXKYZMEL.js";import{a as p}from"./chunk-T6Q6HX5J.js";import"./chunk-4MJDNHOT.js";import{c as g,d as m}from"./chunk-EDF5FKWJ.js";import{d as d}from"./chunk-XQIJGAVD.js";import{g as f,i as y}from"./chunk-UTYWXSQT.js";import{a as _}from"./chunk-RCHWDG3R.js";import"./chunk-4WJUWBRK.js";import"./chunk-5G23AKP3.js";import{a as P,b as w,c as T,d as O,e as b,f as A}from"./chunk-KWAHJ72S.js";import{a as E}from"./chunk-MKDADUG3.js";import{a as x,b as v}from"./chunk-NOIUI5SY.js";import{e as H}from"./chunk-XRRBRTKL.js";function I(t,e){this.position=t,H(this.position)||(this.position=new T),this.tangentPlane=e,H(this.tangentPlane)||(this.tangentPlane=I.NORTH_POLE_TANGENT_PLANE)}Object.defineProperties(I.prototype,{ellipsoid:{get:function(){return this.tangentPlane.ellipsoid}},x:{get:function(){return this.position.x}},y:{get:function(){return this.position.y}},conformalLatitude:{get:function(){let t=T.magnitude(this.position),e=2*this.ellipsoid.maximumRadius;return this.tangentPlane.plane.normal.z*(E.PI_OVER_TWO-2*Math.atan2(t,e))}},longitude:{get:function(){let t=E.PI_OVER_TWO+Math.atan2(this.y,this.x);return t>Math.PI&&(t-=E.TWO_PI),t}}});var R=new w,L=new P;I.prototype.getLatitude=function(t){H(t)||(t=O.default),R.latitude=this.conformalLatitude,R.longitude=this.longitude,R.height=0;let e=this.ellipsoid.cartographicToCartesian(R,L);return t.cartesianToCartographic(e,R),R.latitude};var N=new c,k=new P,C=new P;I.fromCartesian=function(t,e){v.defined("cartesian",t);let o=E.signNotZero(t.z),i=I.NORTH_POLE_TANGENT_PLANE,n=I.SOUTH_POLE;o<0&&(i=I.SOUTH_POLE_TANGENT_PLANE,n=I.NORTH_POLE),N.origin=i.ellipsoid.scaleToGeocentricSurface(t,N.origin),N.direction=P.subtract(N.origin,n,k),P.normalize(N.direction,N.direction);let r=h.rayPlane(N,i.plane,C),a=P.subtract(r,n,r),s=P.dot(i.xAxis,a),l=o*P.dot(i.yAxis,a);return H(e)?(e.position=new T(s,l),e.tangentPlane=i,e):new I(new T(s,l),i)},I.fromCartesianArray=function(t,e){v.defined("cartesians",t);let o=t.length;H(e)?e.length=o:e=Array(o);for(let i=0;i<o;i++)e[i]=I.fromCartesian(t[i],e[i]);return e},I.clone=function(t,e){if(H(t))return H(e)?(e.position=t.position,e.tangentPlane=t.tangentPlane,e):new I(t.position,t.tangentPlane)},I.HALF_UNIT_SPHERE=Object.freeze(new O(.5,.5,.5)),I.NORTH_POLE=Object.freeze(new P(0,0,.5)),I.SOUTH_POLE=Object.freeze(new P(0,0,-.5)),I.NORTH_POLE_TANGENT_PLANE=Object.freeze(new s(I.NORTH_POLE,I.HALF_UNIT_SPHERE)),I.SOUTH_POLE_TANGENT_PLANE=Object.freeze(new s(I.SOUTH_POLE,I.HALF_UNIT_SPHERE));var j=new w,S=new w,F=new t,G=new P,B=new P,U=new P,W=new P,D=new P,M=new P,z=new P,V=new P,J=new P,Y=new T,K=new T,Z=new P,X=new f,q=new b,Q=new b;function $(t){let e=t.vertexFormat,o=t.geometry,i=t.shadowVolume,n=o.attributes.position.values,a=H(o.attributes.st)?o.attributes.st.values:void 0,s=n.length,l=t.wall,u=t.top||l,c=t.bottom||l;if(e.st||e.normal||e.tangent||e.bitangent||i){let r=t.boundingRectangle,h=t.rotationAxis,p=t.projectTo2d,g=t.ellipsoid,d=t.stRotation,y=t.perPositionHeight;Y.x=r.x,Y.y=r.y;let w=e.st?new Float32Array(s/3*2):void 0,O;e.normal&&(O=y&&u&&!l?o.attributes.normal.values:new Float32Array(s));let A=e.tangent?new Float32Array(s):void 0,x=e.bitangent?new Float32Array(s):void 0,v=i?new Float32Array(s):void 0,I=0,R=0,L=B,N=U,k=W,C=!0,F=q,$=Q;if(0!==d){let t=f.fromAxisAngle(h,d,X);F=b.fromQuaternion(t,F),t=f.fromAxisAngle(h,-d,X),$=b.fromQuaternion(t,$)}else F=b.clone(b.IDENTITY,F),$=b.clone(b.IDENTITY,$);let tt=0,te=0;u&&c&&(tt=s/2,te=s/3,s/=2);for(let o=0;o<s;o+=3){let h=P.fromArray(n,o,Z);if(e.st&&!H(a)){let t=b.multiplyByVector(F,h,G),e=p([t=g.scaleToGeodeticSurface(t,t)],K)[0];T.subtract(e,Y,e);let o=E.clamp(e.x/r.width,0,1),i=E.clamp(e.y/r.height,0,1);c&&(w[I+te]=o,w[I+1+te]=i),u&&(w[I]=o,w[I+1]=i),I+=2}if(e.normal||e.tangent||e.bitangent||i){let r=R+1,a=R+2;if(l){if(o+3<s){let t=P.fromArray(n,o+3,D);if(C){let e=P.fromArray(n,o+s,M);y&&function(t,e,o,i){let n=i.cartesianToCartographic(t,j).height,r=i.cartesianToCartographic(e,S);r.height=n,i.cartographicToCartesian(r,e);let a=i.cartesianToCartographic(o,S);a.height=n-100,i.cartographicToCartesian(a,o)}(h,t,e,g),P.subtract(t,h,t),P.subtract(e,h,e),L=P.normalize(P.cross(e,t,L),L),C=!1}P.equalsEpsilon(t,h,E.EPSILON10)&&(C=!0)}(e.tangent||e.bitangent)&&(k=g.geodeticSurfaceNormal(h,k),e.tangent&&(N=P.normalize(P.cross(k,L,N),N)))}else L=g.geodeticSurfaceNormal(h,L),(e.tangent||e.bitangent)&&(y&&(z=P.fromArray(O,R,z),V=P.cross(P.UNIT_Z,z,V),V=P.normalize(b.multiplyByVector($,V,V),V),e.bitangent&&(J=P.normalize(P.cross(z,V,J),J))),N=P.cross(P.UNIT_Z,L,N),N=P.normalize(b.multiplyByVector($,N,N),N),e.bitangent&&(k=P.normalize(P.cross(L,N,k),k)));e.normal&&(t.wall?(O[R+tt]=L.x,O[r+tt]=L.y,O[a+tt]=L.z):c&&(O[R+tt]=-L.x,O[r+tt]=-L.y,O[a+tt]=-L.z),(u&&!y||l)&&(O[R]=L.x,O[r]=L.y,O[a]=L.z)),i&&(l&&(L=g.geodeticSurfaceNormal(h,L)),v[R+tt]=-L.x,v[r+tt]=-L.y,v[a+tt]=-L.z),e.tangent&&(t.wall?(A[R+tt]=N.x,A[r+tt]=N.y,A[a+tt]=N.z):c&&(A[R+tt]=-N.x,A[r+tt]=-N.y,A[a+tt]=-N.z),u&&(y?(A[R]=V.x,A[r]=V.y,A[a]=V.z):(A[R]=N.x,A[r]=N.y,A[a]=N.z))),e.bitangent&&(c&&(x[R+tt]=k.x,x[r+tt]=k.y,x[a+tt]=k.z),u&&(y?(x[R]=J.x,x[r]=J.y,x[a]=J.z):(x[R]=k.x,x[r]=k.y,x[a]=k.z))),R+=3}}e.st&&!H(a)&&(o.attributes.st=new m({componentDatatype:_.FLOAT,componentsPerAttribute:2,values:w})),e.normal&&(o.attributes.normal=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:O})),e.tangent&&(o.attributes.tangent=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:A})),e.bitangent&&(o.attributes.bitangent=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:x})),i&&(o.attributes.extrudeDirection=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:v}))}if(t.extrude&&H(t.offsetAttribute)){let e=n.length/3,i=new Uint8Array(e);if(t.offsetAttribute===r.TOP)u&&c||l?i=i.fill(1,0,e/2):u&&(i=i.fill(1));else{let e=+(t.offsetAttribute!==r.NONE);i=i.fill(e)}o.attributes.applyOffset=new m({componentDatatype:_.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return o}var tt=[];function te(t){if(v.typeOf.object("options",t),v.typeOf.object("options.polygonHierarchy",t.polygonHierarchy),H(t.perPositionHeight)&&t.perPositionHeight&&H(t.height))throw new x("Cannot use both options.perPositionHeight and options.height");if(H(t.arcType)&&t.arcType!==o.GEODESIC&&t.arcType!==o.RHUMB)throw new x("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");let i=t.polygonHierarchy,n=t.vertexFormat??a.DEFAULT,r=t.ellipsoid??O.default,s=t.granularity??E.RADIANS_PER_DEGREE,l=t.stRotation??0,u=t.textureCoordinates,c=t.perPositionHeight??!1,h=c&&H(t.extrudedHeight),p=t.height??0,g=t.extrudedHeight??p;if(!h){let t=Math.max(p,g);g=Math.min(p,g),p=t}this._vertexFormat=a.clone(n),this._ellipsoid=O.clone(r),this._granularity=s,this._stRotation=l,this._height=p,this._extrudedHeight=g,this._closeTop=t.closeTop??!0,this._closeBottom=t.closeBottom??!0,this._polygonHierarchy=i,this._perPositionHeight=c,this._perPositionHeightExtrude=h,this._shadowVolume=t.shadowVolume??!1,this._workerName="createPolygonGeometry",this._offsetAttribute=t.offsetAttribute,this._arcType=t.arcType??o.GEODESIC,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=u,this.packedLength=e.computeHierarchyPackedLength(i,P)+O.packedLength+a.packedLength+(u?e.computeHierarchyPackedLength(u,T):1)+12}te.fromPositions=function(t){return t=t??A.EMPTY_OBJECT,v.defined("options.positions",t.positions),new te({polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates})},te.pack=function(t,o,i){return v.typeOf.object("value",t),v.defined("array",o),i=i??0,i=e.packPolygonHierarchy(t._polygonHierarchy,o,i,P),O.pack(t._ellipsoid,o,i),i+=O.packedLength,a.pack(t._vertexFormat,o,i),i+=a.packedLength,o[i++]=t._height,o[i++]=t._extrudedHeight,o[i++]=t._granularity,o[i++]=t._stRotation,o[i++]=+!!t._perPositionHeightExtrude,o[i++]=+!!t._perPositionHeight,o[i++]=+!!t._closeTop,o[i++]=+!!t._closeBottom,o[i++]=+!!t._shadowVolume,o[i++]=t._offsetAttribute??-1,o[i++]=t._arcType,H(t._textureCoordinates)?i=e.packPolygonHierarchy(t._textureCoordinates,o,i,T):o[i++]=-1,o[i++]=t.packedLength,o};var to=O.clone(O.UNIT_SPHERE),ti=new a,tn={polygonHierarchy:{}};te.unpack=function(t,o,i){v.defined("array",t),o=o??0;let n=e.unpackPolygonHierarchy(t,o,P);o=n.startingIndex,delete n.startingIndex;let r=O.unpack(t,o,to);o+=O.packedLength;let s=a.unpack(t,o,ti);o+=a.packedLength;let l=t[o++],u=t[o++],c=t[o++],h=t[o++],p=1===t[o++],g=1===t[o++],m=1===t[o++],d=1===t[o++],f=1===t[o++],y=t[o++],_=t[o++],w=-1===t[o]?void 0:e.unpackPolygonHierarchy(t,o,T);H(w)?(o=w.startingIndex,delete w.startingIndex):o++;let b=t[o++];return H(i)||(i=new te(tn)),i._polygonHierarchy=n,i._ellipsoid=O.clone(r,i._ellipsoid),i._vertexFormat=a.clone(s,i._vertexFormat),i._height=l,i._extrudedHeight=u,i._granularity=c,i._stRotation=h,i._perPositionHeightExtrude=p,i._perPositionHeight=g,i._closeTop=m,i._closeBottom=d,i._shadowVolume=f,i._offsetAttribute=-1===y?void 0:y,i._arcType=_,i._textureCoordinates=w,i.packedLength=b,i};var tr=new T,ta=new T,ts=new I;function tl(t,e,i,n,r,a){let s=t.longitude,l=s>=0?s:s+E.TWO_PI;r.westOverIdl=Math.min(r.westOverIdl,l),r.eastOverIdl=Math.max(r.eastOverIdl,l),a.west=Math.min(a.west,s),a.east=Math.max(a.east,s);let u=t.getLatitude(i),c=u;if(a.south=Math.min(a.south,u),a.north=Math.max(a.north,u),n!==o.RHUMB){let o=T.subtract(e.position,t.position,tr),n=T.dot(e.position,o)/T.dot(o,o);if(n>0&&n<1){let t=T.add(e.position,T.multiplyByScalar(o,-n,o),ta),r=I.clone(e,ts);r.position=t;let s=r.getLatitude(i);a.south=Math.min(a.south,s),a.north=Math.max(a.north,s),Math.abs(u)>Math.abs(s)&&(c=s)}}let h=Math.sign(e.x*t.y-t.x*e.y);0!==h&&(h*=T.angleBetween(e.position,t.position)),c>=0&&(r.northAngle+=h),c<=0&&(r.southAngle+=h)}var tu=new I,tc=new I,th={northAngle:0,southAngle:0,westOverIdl:0,eastOverIdl:0};te.computeRectangleFromPositions=function(t,e,o,i){if(v.defined("positions",t),H(i)||(i=new y),t.length<3)return i;i.west=1/0,i.east=-1/0,i.south=1/0,i.north=-1/0,th.northAngle=0,th.southAngle=0,th.westOverIdl=1/0,th.eastOverIdl=-1/0;let n=t.length,r=I.fromCartesian(t[0],tc);for(let a=1;a<n;a++){let n=I.fromCartesian(t[a],tu);tl(n,r,e,o,th,i),r=I.clone(n,r)}return tl(I.fromCartesian(t[0],tu),r,e,o,th,i),i.east-i.west>th.eastOverIdl-th.westOverIdl&&(i.west=th.westOverIdl,i.east=th.eastOverIdl,i.east>E.PI&&(i.east=i.east-E.TWO_PI),i.west>E.PI&&(i.west=i.west-E.TWO_PI)),E.equalsEpsilon(Math.abs(th.northAngle),E.TWO_PI,E.EPSILON10)&&(i.north=E.PI_OVER_TWO,i.east=E.PI,i.west=-E.PI),E.equalsEpsilon(Math.abs(th.southAngle),E.TWO_PI,E.EPSILON10)&&(i.south=-E.PI_OVER_TWO,i.east=E.PI,i.west=-E.PI),i};var tp=new I,tg=new w;te.createGeometry=function(o){let a=o._vertexFormat,c=o._ellipsoid,h=o._granularity,f=o._stRotation,y=o._polygonHierarchy,P=o._perPositionHeight,w=o._closeTop,O=o._closeBottom,b=o._arcType,A=o._textureCoordinates,x=H(A),v=y.positions;if(v.length<3)return;let R=o.rectangle,L=e.polygonsFromHierarchy(y,x,(t,e)=>{if(R.height>=E.PI||R.width>=E.PI){if(R.south<0&&R.north>0){H(e)||(e=[]);for(let o=0;o<t.length;++o){let i=c.cartesianToCartographic(t[o],tg);e[o]=new T(i.longitude/E.PI,i.latitude/E.PI_OVER_TWO)}return e.length=t.length,e}return I.fromCartesianArray(t,e)}return s.fromPoints(v,c).projectPointsOntoPlane(t,e)},!P,c,(t,o)=>!P&&(R.height>=E.PI_OVER_TWO||R.width>=2*E.PI_OVER_THREE)?e.splitPolygonsOnEquator(t,c,b,o):t),N=L.hierarchy,k=L.polygons,C=x?e.polygonsFromHierarchy(A,!0,function(t){return t},!1,c).polygons:void 0;if(0===N.length)return;let j=N[0].outerRing,S=function(o,i,n,r){if(i.height>=E.PI||i.width>=E.PI)return t.fromRectangle(i,void 0,F);let a=s.fromPoints(o,n);return e.computeBoundingRectangle(a.plane.normal,a.projectPointOntoPlane.bind(a),o,r,F)}(j,R,c,f),G=[],B=o._height,U=o._extrudedHeight,W=o._perPositionHeightExtrude||!E.equalsEpsilon(B,U,0,E.EPSILON2),D={perPositionHeight:P,vertexFormat:a,geometry:void 0,rotationAxis:(R.height>=E.PI||R.width>=E.PI?I.fromCartesian(j[0],tp).tangentPlane:s.fromPoints(j,c)).plane.normal,projectTo2d:function(t,e,o){if(t.height>=E.PI||t.width>=E.PI)return(e,i)=>{if(t.south<0&&t.north>0){let t=o.cartesianToCartographic(e,tg);return H(i)||(i=new T),i.x=t.longitude/E.PI,i.y=t.latitude/E.PI_OVER_TWO,i}return I.fromCartesian(e,i)};let i=s.fromPoints(e,o);return(t,e)=>i.projectPointsOntoPlane(t,e)}(R,j,c),boundingRectangle:S,ellipsoid:c,stRotation:f,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:b},M;if(W)for(D.extrude=!0,D.top=w,D.bottom=O,D.shadowVolume=o._shadowVolume,D.offsetAttribute=o._offsetAttribute,M=0;M<k.length;M++){let t=function(t,o,n,r,a,c,h,g,m,d){let f={walls:[]},y;if(h||g){let a=e.createGeometryFromPositions(t,o,n,r,c,m,d),s=a.attributes.position.values,l=a.indices,u,_;if(h&&g){let t=s.concat(s);u=t.length/3,(_=p.createTypedArray(u,2*l.length)).set(l);let e=l.length,o=u/2;for(y=0;y<e;y+=3){let t=_[y]+o,i=_[y+1]+o,n=_[y+2]+o;_[y+e]=n,_[y+1+e]=i,_[y+2+e]=t}if(a.attributes.position.values=t,c&&m.normal){let e=a.attributes.normal.values;a.attributes.normal.values=new Float32Array(t.length),a.attributes.normal.values.set(e)}if(m.st&&H(n)){let t=a.attributes.st.values;a.attributes.st.values=new Float32Array(2*u),a.attributes.st.values=t.concat(t)}a.indices=_}else if(g){for(u=s.length/3,_=p.createTypedArray(u,l.length),y=0;y<l.length;y+=3)_[y]=l[y+2],_[y+1]=l[y+1],_[y+2]=l[y];a.indices=_}f.topAndBottom=new i({geometry:a})}let _=a.outerRing,P=s.fromPoints(_,t),w=P.projectPointsOntoPlane(_,tt),T=u.computeWindingOrder2D(w);T===l.CLOCKWISE&&(_=_.slice().reverse());let O=e.computeWallGeometry(_,n,t,r,c,d);f.walls.push(new i({geometry:O}));let b=a.holes;for(y=0;y<b.length;y++){let o=b[y];w=P.projectPointsOntoPlane(o,tt),(T=u.computeWindingOrder2D(w))===l.COUNTER_CLOCKWISE&&(o=o.slice().reverse()),O=e.computeWallGeometry(o,n,t,r,c,d),f.walls.push(new i({geometry:O}))}return f}(c,k[M],x?C[M]:void 0,h,N[M],P,w,O,a,b),o;w&&O?(o=t.topAndBottom,D.geometry=e.scaleToGeodeticHeightExtruded(o.geometry,B,U,c,P)):w?((o=t.topAndBottom).geometry.attributes.position.values=u.scaleToGeodeticHeight(o.geometry.attributes.position.values,B,c,!P),D.geometry=o.geometry):O&&((o=t.topAndBottom).geometry.attributes.position.values=u.scaleToGeodeticHeight(o.geometry.attributes.position.values,U,c,!0),D.geometry=o.geometry),(w||O)&&(D.wall=!1,o.geometry=$(D),G.push(o));let n=t.walls;D.wall=!0;for(let t=0;t<n.length;t++){let o=n[t];D.geometry=e.scaleToGeodeticHeightExtruded(o.geometry,B,U,c,P),o.geometry=$(D),G.push(o)}}else for(M=0;M<k.length;M++){let t=new i({geometry:e.createGeometryFromPositions(c,k[M],x?C[M]:void 0,h,P,a,b)});if(t.geometry.attributes.position.values=u.scaleToGeodeticHeight(t.geometry.attributes.position.values,B,c,!P),D.geometry=t.geometry,t.geometry=$(D),H(o._offsetAttribute)){let e=t.geometry.attributes.position.values.length,i=+(o._offsetAttribute!==r.NONE),n=new Uint8Array(e/3).fill(i);t.geometry.attributes.applyOffset=new m({componentDatatype:_.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}G.push(t)}let z=n.combineInstances(G)[0];z.attributes.position.values=new Float64Array(z.attributes.position.values),z.indices=p.createTypedArray(z.attributes.position.values.length/3,z.indices);let V=z.attributes,J=d.fromVertices(V.position.values);return a.position||delete V.position,new g({attributes:V,indices:z.indices,primitiveType:z.primitiveType,boundingSphere:J,offsetAttribute:o._offsetAttribute})},te.createShadowVolume=function(t,e,o){let i=t._granularity,n=t._ellipsoid,r=e(i,n),s=o(i,n);return new te({polygonHierarchy:t._polygonHierarchy,ellipsoid:n,stRotation:t._stRotation,granularity:i,perPositionHeight:!1,extrudedHeight:r,height:s,vertexFormat:a.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})},Object.defineProperties(te.prototype,{rectangle:{get:function(){if(!H(this._rectangle)){let t=this._polygonHierarchy.positions;this._rectangle=te.computeRectangleFromPositions(t,this._ellipsoid,this._arcType)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return H(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){let e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];let o=t._ellipsoid,i=t._polygonHierarchy.positions,n=t.rectangle;return g._textureCoordinateRotationPoints(i,e,o,n)}(this)),this._textureCoordinateRotationPoints}}});var tm=function(t,e){return H(e)&&(t=te.unpack(t,e)),t._ellipsoid=O.clone(t._ellipsoid),te.createGeometry(t)};export{tm as default};