import{a as e}from"./chunk-GTQ3WXPT.js";import{a as t}from"./chunk-OXJ2LJUE.js";import{a as r}from"./chunk-QORMFUM4.js";import"./chunk-FWF3VNA2.js";import{a as o}from"./chunk-APG2S62J.js";import{a as n}from"./chunk-AZLP5742.js";import"./chunk-5HPISDSZ.js";import"./chunk-HSJ6GSLC.js";import"./chunk-SXKYZMEL.js";import{a as a}from"./chunk-T6Q6HX5J.js";import{a as i}from"./chunk-4MJDNHOT.js";import{a as s,b as l,c as c,d as p}from"./chunk-EDF5FKWJ.js";import{d as h}from"./chunk-XQIJGAVD.js";import"./chunk-UTYWXSQT.js";import{a as u}from"./chunk-RCHWDG3R.js";import"./chunk-4WJUWBRK.js";import"./chunk-5G23AKP3.js";import{a as m,d as d,f as f}from"./chunk-KWAHJ72S.js";import{a as g}from"./chunk-MKDADUG3.js";import{a as k}from"./chunk-NOIUI5SY.js";import{e as y}from"./chunk-XRRBRTKL.js";var w=[];function _(r){let n=(r=r??f.EMPTY_OBJECT).positions,a=r.colors,i=r.width??1,s=r.colorsPerVertex??!1;if(!y(n)||n.length<2)throw new k("At least two positions are required.");if("number"!=typeof i)throw new k("width must be a number");if(y(a)&&(s&&a.length<n.length||!s&&a.length<n.length-1))throw new k("colors has an invalid length.");this._positions=n,this._colors=a,this._width=i,this._colorsPerVertex=s,this._vertexFormat=o.clone(r.vertexFormat??o.DEFAULT),this._arcType=r.arcType??t.GEODESIC,this._granularity=r.granularity??g.RADIANS_PER_DEGREE,this._ellipsoid=d.clone(r.ellipsoid??d.default),this._workerName="createPolylineGeometry";let l=1+n.length*m.packedLength;l+=y(a)?1+a.length*e.packedLength:1,this.packedLength=l+d.packedLength+o.packedLength+4}_.pack=function(t,r,n){if(!y(t))throw new k("value is required");if(!y(r))throw new k("array is required");n=n??0;let a,i=t._positions,s=i.length;for(r[n++]=s,a=0;a<s;++a,n+=m.packedLength)m.pack(i[a],r,n);let l=t._colors;for(s=y(l)?l.length:0,r[n++]=s,a=0;a<s;++a,n+=e.packedLength)e.pack(l[a],r,n);return d.pack(t._ellipsoid,r,n),n+=d.packedLength,o.pack(t._vertexFormat,r,n),n+=o.packedLength,r[n++]=t._width,r[n++]=+!!t._colorsPerVertex,r[n++]=t._arcType,r[n]=t._granularity,r};var A=d.clone(d.UNIT_SPHERE),v=new o,L={positions:void 0,colors:void 0,ellipsoid:A,vertexFormat:v,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};_.unpack=function(t,r,n){if(!y(t))throw new k("array is required");r=r??0;let a,i=t[r++],s=Array(i);for(a=0;a<i;++a,r+=m.packedLength)s[a]=m.unpack(t,r);let l=(i=t[r++])>0?Array(i):void 0;for(a=0;a<i;++a,r+=e.packedLength)l[a]=e.unpack(t,r);let c=d.unpack(t,r,A);r+=d.packedLength;let p=o.unpack(t,r,v);r+=o.packedLength;let h=t[r++],u=1===t[r++],f=t[r++],g=t[r];return y(n)?(n._positions=s,n._colors=l,n._ellipsoid=d.clone(c,n._ellipsoid),n._vertexFormat=o.clone(p,n._vertexFormat),n._width=h,n._colorsPerVertex=u,n._arcType=f,n._granularity=g,n):(L.positions=s,L.colors=l,L.width=h,L.colorsPerVertex=u,L.arcType=f,L.granularity=g,new _(L))};var T=new m,E=new m,P=new m,D=new m;_.createGeometry=function(o){let d=o._width,f=o._vertexFormat,k=o._colors,_=o._colorsPerVertex,A=o._arcType,v=o._granularity,L=o._ellipsoid,b,j,x,F=[],S=n(o._positions,m.equalsEpsilon,!1,F);if(y(k)&&F.length>0){let e=0,t=F[0];k=k.filter(function(r,o){return!(_?o===t||0===o&&1===t:o+1===t)||(t=F[++e],!1)})}let G=S.length;if(G<2||d<=0)return;if(A===t.GEODESIC||A===t.RHUMB){let o,n;A===t.GEODESIC?(o=g.chordLength(v,L.maximumRadius),n=r.numberOfPoints):(o=v,n=r.numberOfPointsRhumbLine);let a=r.extractHeights(S,L);if(y(k)){let t=1;for(b=0;b<G-1;++b)t+=n(S[b],S[b+1],o);let r=Array(t),a=0;for(b=0;b<G-1;++b){let i=S[b],s=S[b+1],l=k[b],c=n(i,s,o);if(_&&b<t){let t=function(t,r,o,n,a){w.length=a;let i,s=o.red,l=o.green,c=o.blue,p=o.alpha,h=n.red,u=n.green,m=n.blue,d=n.alpha;if(e.equals(o,n)){for(i=0;i<a;i++)w[i]=e.clone(o);return w}let f=(h-s)/a,g=(u-l)/a,k=(m-c)/a,y=(d-p)/a;for(i=0;i<a;i++)w[i]=new e(s+i*f,l+i*g,c+i*k,p+i*y);return w}(0,0,l,k[b+1],c),o=t.length;for(j=0;j<o;++j)r[a++]=t[j]}else for(j=0;j<c;++j)r[a++]=e.clone(l)}r[a]=e.clone(k[k.length-1]),k=r,w.length=0}S=A===t.GEODESIC?r.generateCartesianArc({positions:S,minDistance:o,ellipsoid:L,height:a}):r.generateCartesianRhumbArc({positions:S,granularity:o,ellipsoid:L,height:a})}let O=4*(G=S.length)-4,R=new Float64Array(3*O),U=new Float64Array(3*O),I=new Float64Array(3*O),B=new Float32Array(2*O),J=f.st?new Float32Array(2*O):void 0,N=y(k)?new Uint8Array(4*O):void 0,W=0,C=0,H=0,V=0,M;for(j=0;j<G;++j){let t,r;0===j?(M=T,m.subtract(S[0],S[1],M),m.add(S[0],M,M)):M=S[j-1],m.clone(M,P),m.clone(S[j],E),j===G-1?(M=T,m.subtract(S[G-1],S[G-2],M),m.add(S[G-1],M,M)):M=S[j+1],m.clone(M,D),y(N)&&(t=0===j||_?k[j]:k[j-1],j!==G-1&&(r=k[j]));let o=2*(0===j),n=j===G-1?2:4;for(x=o;x<n;++x){m.pack(E,R,W),m.pack(P,U,W),m.pack(D,I,W),W+=3;let o=x-2<0?-1:1;if(B[C++]=x%2*2-1,B[C++]=o*d,f.st&&(J[H++]=j/(G-1),J[H++]=Math.max(B[C-2],0)),y(N)){let o=x<2?t:r;N[V++]=e.floatToByte(o.red),N[V++]=e.floatToByte(o.green),N[V++]=e.floatToByte(o.blue),N[V++]=e.floatToByte(o.alpha)}}}let K=new i;K.position=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:R}),K.prevPosition=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:U}),K.nextPosition=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:I}),K.expandAndWidth=new p({componentDatatype:u.FLOAT,componentsPerAttribute:2,values:B}),f.st&&(K.st=new p({componentDatatype:u.FLOAT,componentsPerAttribute:2,values:J})),y(N)&&(K.color=new p({componentDatatype:u.UNSIGNED_BYTE,componentsPerAttribute:4,values:N,normalize:!0}));let X=a.createTypedArray(O,6*G-6),q=0,Y=0,Q=G-1;for(j=0;j<Q;++j)X[Y++]=q,X[Y++]=q+2,X[Y++]=q+1,X[Y++]=q+1,X[Y++]=q+2,X[Y++]=q+3,q+=4;return new c({attributes:K,indices:X,primitiveType:l.TRIANGLES,boundingSphere:h.fromPoints(S),geometryType:s.POLYLINES})};var b=function(e,t){return y(t)&&(e=_.unpack(e,t)),e._ellipsoid=d.clone(e._ellipsoid),_.createGeometry(e)};export{b as default};