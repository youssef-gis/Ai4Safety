import{a as e}from"./chunk-VHZAK4GN.js";import{a as t}from"./chunk-OFCC6BNI.js";import{b as r}from"./chunk-HSJ6GSLC.js";import{a as i}from"./chunk-SXKYZMEL.js";import{a as n}from"./chunk-T6Q6HX5J.js";import{a as o,b as s,c as a,d as u}from"./chunk-EDF5FKWJ.js";import{a as l,b as p,d as m}from"./chunk-XQIJGAVD.js";import{a as c,b as f}from"./chunk-UTYWXSQT.js";import{a as y}from"./chunk-RCHWDG3R.js";import{a as h,b as d,c as v,e as b,f as w}from"./chunk-KWAHJ72S.js";import{a as g}from"./chunk-MKDADUG3.js";import{a as T,b as A}from"./chunk-NOIUI5SY.js";import{e as S}from"./chunk-XRRBRTKL.js";var x=new h,N=new h,P=new h,I=function(e,t,r,i,n){let o,s,a,u,l,p,m,c;if(A.defined("point",e),A.defined("p0",t),A.defined("p1",r),A.defined("p2",i),S(n)||(n=new h),S(t.z)){if(h.equalsEpsilon(e,t,g.EPSILON14))return h.clone(h.UNIT_X,n);if(h.equalsEpsilon(e,r,g.EPSILON14))return h.clone(h.UNIT_Y,n);if(h.equalsEpsilon(e,i,g.EPSILON14))return h.clone(h.UNIT_Z,n);o=h.subtract(r,t,x),s=h.subtract(i,t,N),a=h.subtract(e,t,P),u=h.dot(o,o),l=h.dot(o,s),p=h.dot(o,a),m=h.dot(s,s),c=h.dot(s,a)}else{if(v.equalsEpsilon(e,t,g.EPSILON14))return h.clone(h.UNIT_X,n);if(v.equalsEpsilon(e,r,g.EPSILON14))return h.clone(h.UNIT_Y,n);if(v.equalsEpsilon(e,i,g.EPSILON14))return h.clone(h.UNIT_Z,n);o=v.subtract(r,t,x),s=v.subtract(i,t,N),a=v.subtract(e,t,P),u=v.dot(o,o),l=v.dot(o,s),p=v.dot(o,a),m=v.dot(s,s),c=v.dot(s,a)}n.y=m*p-l*c,n.z=u*c-l*p;let f=u*m-l*l;if(0!==f)return n.y/=f,n.z/=f,n.x=1-n.y-n.z,n},E={};E.calculateACMR=function(e){let t=(e=e??w.EMPTY_OBJECT).indices,r=e.maximumIndex,i=e.cacheSize??24;if(!S(t))throw new T("indices is required.");let n=t.length;if(n<3||n%3!=0)throw new T("indices length must be a multiple of three.");if(r<=0)throw new T("maximumIndex must be greater than zero.");if(i<3)throw new T("cacheSize must be greater than two.");if(!S(r)){r=0;let e=0,i=t[0];for(;e<n;)i>r&&(r=i),i=t[++e]}let o=[];for(let e=0;e<r+1;e++)o[e]=0;let s=i+1;for(let e=0;e<n;++e)s-o[t[e]]>i&&(o[t[e]]=s,++s);return(s-i+1)/(n/3)},E.tipsify=function(e){let t,r,i=(e=e??w.EMPTY_OBJECT).indices,n=e.maximumIndex,o=e.cacheSize??24,s;if(!S(i))throw new T("indices is required.");let a=i.length;if(a<3||a%3!=0)throw new T("indices length must be a multiple of three.");if(n<=0)throw new T("maximumIndex must be greater than zero.");if(o<3)throw new T("cacheSize must be greater than two.");let u=0,l=0,p=i[0];if(S(n))u=n+1;else{for(;l<a;)p>u&&(u=p),p=i[++l];if(-1===u)return 0;++u}let m=[],c;for(c=0;c<u;c++)m[c]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};l=0;let f=0;for(;l<a;)m[i[l]].vertexTriangles.push(f),++m[i[l]].numLiveTriangles,m[i[l+1]].vertexTriangles.push(f),++m[i[l+1]].numLiveTriangles,m[i[l+2]].vertexTriangles.push(f),++m[i[l+2]].numLiveTriangles,++f,l+=3;let y=0,h=o+1;s=1;let d=[],v=[],b,g,A=0,x=[],N=a/3,P=[];for(c=0;c<N;c++)P[c]=!1;for(;-1!==y;){d=[],r=(g=m[y]).vertexTriangles.length;for(let e=0;e<r;++e)if(!P[f=g.vertexTriangles[e]]){P[f]=!0,l=f+f+f;for(let e=0;e<3;++e)t=i[l],d.push(t),v.push(t),x[A]=t,++A,b=m[t],--b.numLiveTriangles,h-b.timeStamp>o&&(b.timeStamp=h,++h),++l}y=function(e,t,r,i,n,o,a){let u=-1,l,p=-1,m=0;for(;m<r.length;){let e=r[m];i[e].numLiveTriangles&&(l=0,n-i[e].timeStamp+2*i[e].numLiveTriangles<=t&&(l=n-i[e].timeStamp),(l>p||-1===p)&&(p=l,u=e)),++m}return -1===u?function(e,t,r,i){for(;t.length>=1;){let r=t[t.length-1];if(t.splice(t.length-1,1),e[r].numLiveTriangles>0)return r}for(;s<i;){if(e[s].numLiveTriangles>0)return++s-1;++s}return -1}(i,o,0,a):u}(0,o,d,m,h,v,u)}return x};var O={};function L(e,t,r,i,n){e[t++]=r,e[t++]=i,e[t++]=i,e[t++]=n,e[t++]=n,e[t]=r}function z(e){let t={};for(let r in e)if(e.hasOwnProperty(r)&&S(e[r])&&S(e[r].values)){let i=e[r];t[r]=new u({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return t}O.toWireframe=function(e){if(!S(e))throw new T("geometry is required.");let t=e.indices;if(S(t)){switch(e.primitiveType){case s.TRIANGLES:e.indices=function(e){let t=e.length,r=n.createTypedArray(t,t/3*6),i=0;for(let n=0;n<t;n+=3,i+=6)L(r,i,e[n],e[n+1],e[n+2]);return r}(t);break;case s.TRIANGLE_STRIP:e.indices=function(e){let t=e.length;if(t>=3){let r=n.createTypedArray(t,(t-2)*6);L(r,0,e[0],e[1],e[2]);let i=6;for(let n=3;n<t;++n,i+=6)L(r,i,e[n-1],e[n],e[n-2]);return r}return new Uint16Array}(t);break;case s.TRIANGLE_FAN:e.indices=function(e){if(e.length>0){let t=e.length-1,r=n.createTypedArray(t,(t-1)*6),i=e[0],o=0;for(let n=1;n<t;++n,o+=6)L(r,o,i,e[n],e[n+1]);return r}return new Uint16Array}(t);break;default:throw new T("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")}e.primitiveType=s.LINES}return e},O.createLineSegmentsForVectors=function(e,t,r){if(t=t??"normal",!S(e))throw new T("geometry is required.");if(!S(e.attributes.position))throw new T("geometry.attributes.position is required.");if(!S(e.attributes[t]))throw new T(`geometry.attributes must have an attribute with the same name as the attributeName parameter, ${t}.`);r=r??1e4;let i=e.attributes.position.values,n=e.attributes[t].values,o=i.length,l=new Float64Array(2*o),p=0;for(let e=0;e<o;e+=3)l[p++]=i[e],l[p++]=i[e+1],l[p++]=i[e+2],l[p++]=i[e]+n[e]*r,l[p++]=i[e+1]+n[e+1]*r,l[p++]=i[e+2]+n[e+2]*r;let c,f=e.boundingSphere;return S(f)&&(c=new m(f.center,f.radius+r)),new a({attributes:{position:new u({componentDatatype:y.DOUBLE,componentsPerAttribute:3,values:l})},primitiveType:s.LINES,boundingSphere:c})},O.createAttributeLocations=function(e){if(!S(e))throw new T("geometry is required.");let t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],r=e.attributes,i={},n=0,o,s=t.length;for(o=0;o<s;++o){let e=t[o];S(r[e])&&(i[e]=n++)}for(let e in r)r.hasOwnProperty(e)&&!S(i[e])&&(i[e]=n++);return i},O.reorderForPreVertexCache=function(e){if(!S(e))throw new T("geometry is required.");let t=a.computeNumberOfVertices(e),r=e.indices;if(S(r)){let i=new Int32Array(t);for(let e=0;e<t;e++)i[e]=-1;let o=r.length,s=n.createTypedArray(t,o),a=0,u=0,l=0,p;for(;a<o;)-1!==(p=i[r[a]])?s[u]=p:(i[p=r[a]]=l,s[u]=l,++l),++a,++u;e.indices=s;let m=e.attributes;for(let e in m)if(m.hasOwnProperty(e)&&S(m[e])&&S(m[e].values)){let r=m[e],n=r.values,o=0,s=r.componentsPerAttribute,a=y.createTypedArray(r.componentDatatype,l*s);for(;o<t;){let e=i[o];if(-1!==e)for(let t=0;t<s;t++)a[s*e+t]=n[s*o+t];++o}r.values=a}}return e},O.reorderForPostVertexCache=function(e,t){if(!S(e))throw new T("geometry is required.");let r=e.indices;if(e.primitiveType===s.TRIANGLES&&S(r)){let i=r.length,n=0;for(let e=0;e<i;e++)r[e]>n&&(n=r[e]);e.indices=E.tipsify({indices:r,maximumIndex:n,cacheSize:t})}return e},O.fitToUnsignedShortIndices=function(e){if(!S(e))throw new T("geometry is required.");if(S(e.indices)&&e.primitiveType!==s.TRIANGLES&&e.primitiveType!==s.LINES&&e.primitiveType!==s.POINTS)throw new T("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");let t=[],r=a.computeNumberOfVertices(e);if(S(e.indices)&&r>=g.SIXTY_FOUR_KILOBYTES){let r=[],i=[],n=0,o=z(e.attributes),u=e.indices,l=u.length,p;e.primitiveType===s.TRIANGLES?p=3:e.primitiveType===s.LINES?p=2:e.primitiveType===s.POINTS&&(p=1);for(let s=0;s<l;s+=p){for(let t=0;t<p;++t){let a=u[s+t],l=r[a];S(l)||(l=n++,r[a]=l,function(e,t,r){for(let i in t)if(t.hasOwnProperty(i)&&S(t[i])&&S(t[i].values)){let n=t[i];for(let t=0;t<n.componentsPerAttribute;++t)e[i].values.push(n.values[r*n.componentsPerAttribute+t])}}(o,e.attributes,a)),i.push(l)}n+p>=g.SIXTY_FOUR_KILOBYTES&&(t.push(new a({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),r=[],i=[],n=0,o=z(e.attributes))}0!==i.length&&t.push(new a({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};var D=new h,q=new d;O.projectTo2D=function(e,t,r,i,n){if(!S(e))throw new T("geometry is required.");if(!S(t))throw new T("attributeName is required.");if(!S(r))throw new T("attributeName3D is required.");if(!S(i))throw new T("attributeName2D is required.");if(!S(e.attributes[t]))throw new T(`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==y.DOUBLE)throw new T("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");let o=e.attributes[t],s=(n=S(n)?n:new l).ellipsoid,a=o.values,p=new Float64Array(a.length),m=0;for(let e=0;e<a.length;e+=3){let t=h.fromArray(a,e,D),r=s.cartesianToCartographic(t,q);if(!S(r))throw new T(`Could not project point (${t.x}, ${t.y}, ${t.z}) to 2D.`);let i=n.project(r,D);p[m++]=i.x,p[m++]=i.y,p[m++]=i.z}return e.attributes[r]=o,e.attributes[i]=new u({componentDatatype:y.DOUBLE,componentsPerAttribute:3,values:p}),delete e.attributes[t],e};var R={high:0,low:0};O.encodeAttribute=function(e,r,i,n){if(!S(e))throw new T("geometry is required.");if(!S(r))throw new T("attributeName is required.");if(!S(i))throw new T("attributeHighName is required.");if(!S(n))throw new T("attributeLowName is required.");if(!S(e.attributes[r]))throw new T(`geometry must have attribute matching the attributeName argument: ${r}.`);if(e.attributes[r].componentDatatype!==y.DOUBLE)throw new T("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");let o=e.attributes[r],s=o.values,a=s.length,l=new Float32Array(a),p=new Float32Array(a);for(let e=0;e<a;++e)t.encode(s[e],R),l[e]=R.high,p[e]=R.low;let m=o.componentsPerAttribute;return e.attributes[i]=new u({componentDatatype:y.FLOAT,componentsPerAttribute:m,values:l}),e.attributes[n]=new u({componentDatatype:y.FLOAT,componentsPerAttribute:m,values:p}),delete e.attributes[r],e};var k=new h;function G(e,t){if(S(t)){let r=t.values,i=r.length;for(let t=0;t<i;t+=3)h.unpack(r,t,k),f.multiplyByPoint(e,k,k),h.pack(k,r,t)}}function F(e,t){if(S(t)){let r=t.values,i=r.length;for(let t=0;t<i;t+=3)h.unpack(r,t,k),b.multiplyByVector(e,k,k),k=h.normalize(k,k),h.pack(k,r,t)}}var C=new f,B=new b;O.transformToWorldCoordinates=function(e){if(!S(e))throw new T("instance is required.");let t=e.modelMatrix;if(f.equals(t,f.IDENTITY))return e;let r=e.geometry.attributes;G(t,r.position),G(t,r.prevPosition),G(t,r.nextPosition),(S(r.normal)||S(r.tangent)||S(r.bitangent))&&(f.inverse(t,C),f.transpose(C,C),f.getMatrix3(C,B),F(B,r.normal),F(B,r.tangent),F(B,r.bitangent));let i=e.geometry.boundingSphere;return S(i)&&(e.geometry.boundingSphere=m.transform(i,t,i)),e.modelMatrix=f.clone(f.IDENTITY),e};var _=new h;function U(e,t){let r,i=e.length,o,l,p,c,d=e[0].modelMatrix,v=S(e[0][t].indices),b=e[0][t].primitiveType;for(l=1;l<i;++l){if(!f.equals(e[l].modelMatrix,d))throw new T("All instances must have the same modelMatrix.");if(S(e[l][t].indices)!==v)throw new T("All instance geometries must have an indices or not have one.");if(e[l][t].primitiveType!==b)throw new T("All instance geometries must have the same primitiveType.")}let w=function(e,t){let r=e.length,i={},n=e[0][t].attributes,o;for(o in n)if(n.hasOwnProperty(o)&&S(n[o])&&S(n[o].values)){let s=n[o],a=s.values.length,l=!0;for(let i=1;i<r;++i){let r=e[i][t].attributes[o];if(!S(r)||s.componentDatatype!==r.componentDatatype||s.componentsPerAttribute!==r.componentsPerAttribute||s.normalize!==r.normalize){l=!1;break}a+=r.values.length}l&&(i[o]=new u({componentDatatype:s.componentDatatype,componentsPerAttribute:s.componentsPerAttribute,normalize:s.normalize,values:y.createTypedArray(s.componentDatatype,a)}))}return i}(e,t),g,A,x;for(o in w)if(w.hasOwnProperty(o))for(g=w[o].values,c=0,l=0;l<i;++l)for(x=(A=e[l][t].attributes[o].values).length,p=0;p<x;++p)g[c++]=A[p];if(v){let o=0;for(l=0;l<i;++l)o+=e[l][t].indices.length;let u=a.computeNumberOfVertices(new a({attributes:w,primitiveType:s.POINTS})),p=n.createTypedArray(u,o),m=0,f=0;for(l=0;l<i;++l){let r=e[l][t].indices,i=r.length;for(c=0;c<i;++c)p[m++]=f+r[c];f+=a.computeNumberOfVertices(e[l][t])}r=p}let N=new h,P=0,I;for(l=0;l<i;++l){if(!S(I=e[l][t].boundingSphere)){N=void 0;break}h.add(I.center,N,N)}if(S(N))for(h.divideByScalar(N,i,N),l=0;l<i;++l){I=e[l][t].boundingSphere;let r=h.magnitude(h.subtract(I.center,N,_))+I.radius;r>P&&(P=r)}return new a({attributes:w,indices:r,primitiveType:b,boundingSphere:S(N)?new m(N,P):void 0})}O.combineInstances=function(e){if(!S(e)||e.length<1)throw new T("instances is required and must have length greater than zero.");let t=[],r=[],i=e.length;for(let n=0;n<i;++n){let i=e[n];S(i.geometry)?t.push(i):S(i.westHemisphereGeometry)&&S(i.eastHemisphereGeometry)&&r.push(i)}let n=[];return t.length>0&&n.push(U(t,"geometry")),r.length>0&&(n.push(U(r,"westHemisphereGeometry")),n.push(U(r,"eastHemisphereGeometry"))),n};var V=new h,M=new h,Y=new h,j=new h;O.computeNormal=function(e){let t;if(!S(e))throw new T("geometry is required.");if(!S(e.attributes.position)||!S(e.attributes.position.values))throw new T("geometry.attributes.position.values is required.");if(!S(e.indices))throw new T("geometry.indices is required.");if(e.indices.length<2||e.indices.length%3!=0)throw new T("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==s.TRIANGLES)throw new T("geometry.primitiveType must be PrimitiveType.TRIANGLES.");let r=e.indices,i=e.attributes,n=i.position.values,o=i.position.values.length/3,a=r.length,l=Array(o),p=Array(a/3),m=Array(a),c;for(c=0;c<o;c++)l[c]={indexOffset:0,count:0,currentCount:0};let f=0;for(c=0;c<a;c+=3){let e=r[c],t=r[c+1],i=r[c+2],o=3*e,s=3*t,a=3*i;M.x=n[o],M.y=n[o+1],M.z=n[o+2],Y.x=n[s],Y.y=n[s+1],Y.z=n[s+2],j.x=n[a],j.y=n[a+1],j.z=n[a+2],l[e].count++,l[t].count++,l[i].count++,h.subtract(Y,M,Y),h.subtract(j,M,j),p[f]=h.cross(Y,j,new h),f++}let d=0;for(c=0;c<o;c++)l[c].indexOffset+=d,d+=l[c].count;for(c=0,f=0;c<a;c+=3){let e=(t=l[r[c]]).indexOffset+t.currentCount;m[e]=f,t.currentCount++,m[e=(t=l[r[c+1]]).indexOffset+t.currentCount]=f,t.currentCount++,m[e=(t=l[r[c+2]]).indexOffset+t.currentCount]=f,t.currentCount++,f++}let v=new Float32Array(3*o);for(c=0;c<o;c++){let e=3*c;if(t=l[c],h.clone(h.ZERO,V),t.count>0){for(f=0;f<t.count;f++)h.add(V,p[m[t.indexOffset+f]],V);h.equalsEpsilon(h.ZERO,V,g.EPSILON10)&&h.clone(p[m[t.indexOffset]],V)}h.equalsEpsilon(h.ZERO,V,g.EPSILON10)&&(V.z=1),h.normalize(V,V),v[e]=V.x,v[e+1]=V.y,v[e+2]=V.z}return e.attributes.normal=new u({componentDatatype:y.FLOAT,componentsPerAttribute:3,values:v}),e};var H=new h,Z=new h,W=new h;O.computeTangentAndBitangent=function(e){let t,r,i;if(!S(e))throw new T("geometry is required.");let n=e.attributes,o=e.indices;if(!S(n.position)||!S(n.position.values))throw new T("geometry.attributes.position.values is required.");if(!S(n.normal)||!S(n.normal.values))throw new T("geometry.attributes.normal.values is required.");if(!S(n.st)||!S(n.st.values))throw new T("geometry.attributes.st.values is required.");if(!S(o))throw new T("geometry.indices is required.");if(o.length<2||o.length%3!=0)throw new T("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==s.TRIANGLES)throw new T("geometry.primitiveType must be PrimitiveType.TRIANGLES.");let a=e.attributes.position.values,l=e.attributes.normal.values,p=e.attributes.st.values,m=e.attributes.position.values.length/3,c=o.length,f=Array(3*m),d;for(d=0;d<f.length;d++)f[d]=0;for(d=0;d<c;d+=3){let e=o[d],n=o[d+1],s=o[d+2];t=3*e,r=3*n,i=3*s;let u=2*e,l=2*n,m=2*s,c=a[t],y=a[t+1],h=a[t+2],v=p[u],b=p[u+1],w=p[l+1]-b,g=p[m+1]-b,T=1/((p[l]-v)*g-(p[m]-v)*w),A=(g*(a[r]-c)-w*(a[i]-c))*T,S=(g*(a[r+1]-y)-w*(a[i+1]-y))*T,x=(g*(a[r+2]-h)-w*(a[i+2]-h))*T;f[t]+=A,f[t+1]+=S,f[t+2]+=x,f[r]+=A,f[r+1]+=S,f[r+2]+=x,f[i]+=A,f[i+1]+=S,f[i+2]+=x}let v=new Float32Array(3*m),b=new Float32Array(3*m);for(d=0;d<m;d++){r=(t=3*d)+1,i=t+2;let e=h.fromArray(l,t,H),n=h.fromArray(f,t,W),o=h.dot(e,n);h.multiplyByScalar(e,o,Z),h.normalize(h.subtract(n,Z,n),n),v[t]=n.x,v[r]=n.y,v[i]=n.z,h.normalize(h.cross(e,n,n),n),b[t]=n.x,b[r]=n.y,b[i]=n.z}return e.attributes.tangent=new u({componentDatatype:y.FLOAT,componentsPerAttribute:3,values:v}),e.attributes.bitangent=new u({componentDatatype:y.FLOAT,componentsPerAttribute:3,values:b}),e};var X=new v,K=new h,J=new h,$=new h,Q=new v;function ee(e,t){Math.abs(e.y)<g.EPSILON6&&(t?e.y=-g.EPSILON6:e.y=g.EPSILON6)}O.compressVertices=function(t){if(!S(t))throw new T("geometry is required.");let r=t.attributes.extrudeDirection,i,n;if(S(r)){let o=r.values,s=new Float32Array(2*(n=o.length/3)),a=0;for(i=0;i<n;++i){if(h.fromArray(o,3*i,K),h.equals(K,h.ZERO)){a+=2;continue}Q=e.octEncodeInRange(K,65535,Q),s[a++]=Q.x,s[a++]=Q.y}return t.attributes.compressedAttributes=new u({componentDatatype:y.FLOAT,componentsPerAttribute:2,values:s}),delete t.attributes.extrudeDirection,t}let o=t.attributes.normal,s=t.attributes.st,a=S(o),l=S(s);if(!a&&!l)return t;let p=t.attributes.tangent,m=t.attributes.bitangent,c=S(p),f=S(m),d,b,w,g;a&&(d=o.values),l&&(b=s.values),c&&(w=p.values),f&&(g=m.values);let A=n=(a?d.length:b.length)/(a?3:2),x=l&&a?2:1;x+=c||f?1:0;let N=new Float32Array(A*=x),P=0;for(i=0;i<n;++i){l&&(v.fromArray(b,2*i,X),N[P++]=e.compressTextureCoordinates(X));let t=3*i;a&&S(w)&&S(g)?(h.fromArray(d,t,K),h.fromArray(w,t,J),h.fromArray(g,t,$),e.octPack(K,J,$,X),N[P++]=X.x,N[P++]=X.y):(a&&(h.fromArray(d,t,K),N[P++]=e.octEncodeFloat(K)),c&&(h.fromArray(w,t,K),N[P++]=e.octEncodeFloat(K)),f&&(h.fromArray(g,t,K),N[P++]=e.octEncodeFloat(K)))}return t.attributes.compressedAttributes=new u({componentDatatype:y.FLOAT,componentsPerAttribute:x,values:N}),a&&delete t.attributes.normal,l&&delete t.attributes.st,f&&delete t.attributes.bitangent,c&&delete t.attributes.tangent,t};var et=new h;function er(e,t,r,i){h.add(e,h.multiplyByScalar(h.subtract(t,e,et),e.y/(e.y-t.y),et),r),h.clone(r,i),ee(r,!0),ee(i,!1)}var ei=new h,en=new h,eo=new h,es=new h,ea={positions:Array(7),indices:Array(9)};function eu(e,t){let r=e.attributes;if(0===r.position.values.length)return;for(let e in r)if(r.hasOwnProperty(e)&&S(r[e])&&S(r[e].values)){let t=r[e];t.values=y.createTypedArray(t.componentDatatype,t.values)}let i=a.computeNumberOfVertices(e);return e.indices=n.createTypedArray(i,e.indices),t&&(e.boundingSphere=m.fromVertices(r.position.values)),e}function el(e){let t=e.attributes,r={};for(let e in t)if(t.hasOwnProperty(e)&&S(t[e])&&S(t[e].values)){let i=t[e];r[e]=new u({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return new a({attributes:r,indices:[],primitiveType:e.primitiveType})}function ep(e,t,r){let i=S(e.geometry.boundingSphere);t=eu(t,i),S(r=eu(r,i))&&!S(t)?e.geometry=r:!S(r)&&S(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=r,e.geometry=void 0)}function em(e,t){let r=new e,i=new e,n=new e;return function(o,s,a,u,l,p,m,c){let f=e.fromArray(l,o*t,r),y=e.fromArray(l,s*t,i),h=e.fromArray(l,a*t,n);e.multiplyByScalar(f,u.x,f),e.multiplyByScalar(y,u.y,y),e.multiplyByScalar(h,u.z,h);let d=e.add(f,y,f);e.add(d,h,d),c&&e.normalize(d,d),e.pack(d,p,m*t)}}var ec=em(c,4),ef=em(h,3),ey=em(v,2),eh=function(e,t,r,i,n,o,s){let a=n[e]*i.x,u=n[t]*i.y,l=n[r]*i.z;o[s]=+(a+u+l>g.EPSILON6)},ed=new h,ev=new h,eb=new h,ew=new h;function eg(e,t,r,i,n,o,s,a,u,l,p,m,c,f,y,d){if(!S(o)&&!S(s)&&!S(a)&&!S(u)&&!S(l)&&0===f)return;let v=I(i,h.fromArray(n,3*e,ed),h.fromArray(n,3*t,ev),h.fromArray(n,3*r,eb),ew);if(S(v)){if(S(o)&&ef(e,t,r,v,o,m.normal.values,d,!0),S(l)){let i,n=h.fromArray(l,3*e,ed),o=h.fromArray(l,3*t,ev),s=h.fromArray(l,3*r,eb);h.multiplyByScalar(n,v.x,n),h.multiplyByScalar(o,v.y,o),h.multiplyByScalar(s,v.z,s),h.equals(n,h.ZERO)&&h.equals(o,h.ZERO)&&h.equals(s,h.ZERO)?((i=ed).x=0,i.y=0,i.z=0):(i=h.add(n,o,n),h.add(i,s,i),h.normalize(i,i)),h.pack(i,m.extrudeDirection.values,3*d)}if(S(p)&&eh(e,t,r,v,p,m.applyOffset.values,d),S(s)&&ef(e,t,r,v,s,m.tangent.values,d,!0),S(a)&&ef(e,t,r,v,a,m.bitangent.values,d,!0),S(u)&&ey(e,t,r,v,u,m.st.values,d),f>0)for(let i=0;i<f;i++){let n=c[i];!function(e,t,r,i,n,o,s){let a=o.componentsPerAttribute,u=o.values,l=s.values;switch(a){case 4:ec(e,t,r,i,u,l,n,!1);break;case 3:ef(e,t,r,i,u,l,n,!1);break;case 2:ey(e,t,r,i,u,l,n,!1);break;default:l[n]=u[e]*i.x+u[t]*i.y+u[r]*i.z}}(e,t,r,v,d,y[n],m[n])}}}function eT(e,t,r,i,n,o){let s=e.position.values.length/3;if(-1!==n){let a=i[n],u=r[a];return -1===u?(r[a]=s,e.position.values.push(o.x,o.y,o.z),t.push(s),s):(t.push(u),u)}return e.position.values.push(o.x,o.y,o.z),t.push(s),s}var eA={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function eS(e){let t=e.geometry,r=t.attributes,i=r.position.values,n=S(r.normal)?r.normal.values:void 0,o=S(r.bitangent)?r.bitangent.values:void 0,s=S(r.tangent)?r.tangent.values:void 0,a=S(r.st)?r.st.values:void 0,u=S(r.extrudeDirection)?r.extrudeDirection.values:void 0,l=S(r.applyOffset)?r.applyOffset.values:void 0,p=t.indices,m=[];for(let e in r)r.hasOwnProperty(e)&&!eA[e]&&S(r[e])&&m.push(e);let c=m.length,f=el(t),y=el(t),d,v,b,w,T,A=[];A.length=i.length/3;let x=[];for(x.length=i.length/3,T=0;T<A.length;++T)A[T]=-1,x[T]=-1;let N=p.length;for(T=0;T<N;T+=3){let e=p[T],t=p[T+1],N=p[T+2],P=h.fromArray(i,3*e),I=h.fromArray(i,3*t),E=h.fromArray(i,3*N),O=function(e,t,r){if(e.x>=0||t.x>=0||r.x>=0)return;!function(e,t,r){if(0!==e.y&&0!==t.y&&0!==r.y){ee(e,e.y<0),ee(t,t.y<0),ee(r,r.y<0);return}let i=Math.abs(e.y),n=Math.abs(t.y),o=Math.abs(r.y),s=(i>n?i>o?g.sign(e.y):g.sign(r.y):n>o?g.sign(t.y):g.sign(r.y))<0;ee(e,s),ee(t,s),ee(r,s)}(e,t,r);let i=e.y<0,n=t.y<0,o=r.y<0,s;s=0+(+!!i+ +!!n+ +!!o);let a=ea.indices;1===s?(a[1]=3,a[2]=4,a[5]=6,a[7]=6,a[8]=5,i?(er(e,t,ei,eo),er(e,r,en,es),a[0]=0,a[3]=1,a[4]=2,a[6]=1):n?(er(t,r,ei,eo),er(t,e,en,es),a[0]=1,a[3]=2,a[4]=0,a[6]=2):o&&(er(r,e,ei,eo),er(r,t,en,es),a[0]=2,a[3]=0,a[4]=1,a[6]=0)):2===s&&(a[2]=4,a[4]=4,a[5]=3,a[7]=5,a[8]=6,i?n?o||(er(r,e,ei,eo),er(r,t,en,es),a[0]=0,a[1]=1,a[3]=0,a[6]=2):(er(t,r,ei,eo),er(t,e,en,es),a[0]=2,a[1]=0,a[3]=2,a[6]=1):(er(e,t,ei,eo),er(e,r,en,es),a[0]=1,a[1]=2,a[3]=1,a[6]=0));let u=ea.positions;return u[0]=e,u[1]=t,u[2]=r,u.length=3,(1===s||2===s)&&(u[3]=ei,u[4]=en,u[5]=eo,u[6]=es,u.length=7),ea}(P,I,E);if(S(O)&&O.positions.length>3){let h=O.positions,g=O.indices,S=g.length;for(let P=0;P<S;++P){let S=g[P],I=h[S];I.y<0?(d=y.attributes,v=y.indices,b=A):(d=f.attributes,v=f.indices,b=x),w=eT(d,v,b,p,S<3?T+S:-1,I),eg(e,t,N,I,i,n,s,o,a,u,l,d,m,c,r,w)}}else S(O)&&(P=O.positions[0],I=O.positions[1],E=O.positions[2]),P.y<0?(d=y.attributes,v=y.indices,b=A):(d=f.attributes,v=f.indices,b=x),w=eT(d,v,b,p,T,P),eg(e,t,N,P,i,n,s,o,a,u,l,d,m,c,r,w),w=eT(d,v,b,p,T+1,I),eg(e,t,N,I,i,n,s,o,a,u,l,d,m,c,r,w),w=eT(d,v,b,p,T+2,E),eg(e,t,N,E,i,n,s,o,a,u,l,d,m,c,r,w)}ep(e,y,f)}var ex=i.fromPointNormal(h.ZERO,h.UNIT_Y),eN=new h,eP=new h;function eI(e,t,r,i,n,o,s){if(!S(s))return;let a=h.fromArray(i,3*e,ed);h.equalsEpsilon(a,r,g.EPSILON10)?o.applyOffset.values[n]=s[e]:o.applyOffset.values[n]=s[t]}function eE(e){let t=e.geometry,i=t.attributes,n=i.position.values,o=S(i.applyOffset)?i.applyOffset.values:void 0,s=t.indices,a=el(t),u=el(t),l,p=s.length,m=[];m.length=n.length/3;let c=[];for(c.length=n.length/3,l=0;l<m.length;++l)m[l]=-1,c[l]=-1;for(l=0;l<p;l+=2){let e=s[l],t=s[l+1],i=h.fromArray(n,3*e,ed),p=h.fromArray(n,3*t,ev),f;Math.abs(i.y)<g.EPSILON6&&(i.y<0?i.y=-g.EPSILON6:i.y=g.EPSILON6),Math.abs(p.y)<g.EPSILON6&&(p.y<0?p.y=-g.EPSILON6:p.y=g.EPSILON6);let y=a.attributes,d=a.indices,v=c,b=u.attributes,w=u.indices,T=m,A=r.lineSegmentPlane(i,p,ex,eb);if(S(A)){let r=h.multiplyByScalar(h.UNIT_Y,5*g.EPSILON9,eN);i.y<0&&(h.negate(r,r),y=u.attributes,d=u.indices,v=m,b=a.attributes,w=a.indices,T=c);let S=h.add(A,r,eP);f=eT(y,d,v,s,l,i),eI(e,t,i,n,f,y,o),f=eT(y,d,v,s,-1,S),eI(e,t,S,n,f,y,o),h.negate(r,r),h.add(A,r,S),f=eT(b,w,T,s,-1,S),eI(e,t,S,n,f,b,o),f=eT(b,w,T,s,l+1,p),eI(e,t,p,n,f,b,o)}else{let r,y,h;i.y<0?(r=u.attributes,y=u.indices,h=m):(r=a.attributes,y=a.indices,h=c),f=eT(r,y,h,s,l,i),eI(e,t,i,n,f,r,o),f=eT(r,y,h,s,l+1,p),eI(e,t,p,n,f,r,o)}}ep(e,u,a)}var eO=new v,eL=new v,ez=new h,eD=new h,eq=new h,eR=new h,ek=new h,eG=new h,eF=new c;function eC(e){let t=e.attributes,r=t.position.values,i=t.prevPosition.values,n=t.nextPosition.values,o=r.length;for(let e=0;e<o;e+=3){let t=h.unpack(r,e,ez);if(t.x>0)continue;let s=h.unpack(i,e,eD);(t.y<0&&s.y>0||t.y>0&&s.y<0)&&(e-3>0?(i[e]=r[e-3],i[e+1]=r[e-2],i[e+2]=r[e-1]):h.pack(t,i,e));let a=h.unpack(n,e,eq);(t.y<0&&a.y>0||t.y>0&&a.y<0)&&(e+3<o?(n[e]=r[e+3],n[e+1]=r[e+4],n[e+2]=r[e+5]):h.pack(t,n,e))}}var eB=5*g.EPSILON9,e_=g.EPSILON6;O.splitLongitude=function(e){if(!S(e))throw new T("instance is required.");let t=e.geometry,u=t.boundingSphere;if(S(u)&&(u.center.x-u.radius>0||m.intersectPlane(u,i.ORIGIN_ZX_PLANE)!==p.INTERSECTING))return e;if(t.geometryType!==o.NONE)switch(t.geometryType){case o.POLYLINES:!function(e){let t=e.geometry,i=t.attributes,n=i.position.values,o=i.prevPosition.values,s=i.nextPosition.values,a=i.expandAndWidth.values,u=S(i.st)?i.st.values:void 0,l=S(i.color)?i.color.values:void 0,p=el(t),m=el(t),f,y,d,b=!1,w=n.length/3;for(f=0;f<w;f+=4){let e=f,t=f+2,i=h.fromArray(n,3*e,ez),w=h.fromArray(n,3*t,eD);if(Math.abs(i.y)<e_)for(i.y=e_*(w.y<0?-1:1),n[3*f+1]=i.y,n[(f+1)*3+1]=i.y,y=3*e;y<3*e+12;y+=3)o[y]=n[3*f],o[y+1]=n[3*f+1],o[y+2]=n[3*f+2];if(Math.abs(w.y)<e_)for(w.y=e_*(i.y<0?-1:1),n[(f+2)*3+1]=w.y,n[(f+3)*3+1]=w.y,y=3*e;y<3*e+12;y+=3)s[y]=n[(f+2)*3],s[y+1]=n[(f+2)*3+1],s[y+2]=n[(f+2)*3+2];let T=p.attributes,A=p.indices,x=m.attributes,N=m.indices,P=r.lineSegmentPlane(i,w,ex,eR);if(S(P)){b=!0;let r=h.multiplyByScalar(h.UNIT_Y,eB,ek);i.y<0&&(h.negate(r,r),T=m.attributes,A=m.indices,x=p.attributes,N=p.indices);let n=h.add(P,r,eG);T.position.values.push(i.x,i.y,i.z,i.x,i.y,i.z),T.position.values.push(n.x,n.y,n.z),T.position.values.push(n.x,n.y,n.z),T.prevPosition.values.push(o[3*e],o[3*e+1],o[3*e+2]),T.prevPosition.values.push(o[3*e+3],o[3*e+4],o[3*e+5]),T.prevPosition.values.push(i.x,i.y,i.z,i.x,i.y,i.z),T.nextPosition.values.push(n.x,n.y,n.z),T.nextPosition.values.push(n.x,n.y,n.z),T.nextPosition.values.push(n.x,n.y,n.z),T.nextPosition.values.push(n.x,n.y,n.z),h.negate(r,r),h.add(P,r,n),x.position.values.push(n.x,n.y,n.z),x.position.values.push(n.x,n.y,n.z),x.position.values.push(w.x,w.y,w.z,w.x,w.y,w.z),x.prevPosition.values.push(n.x,n.y,n.z),x.prevPosition.values.push(n.x,n.y,n.z),x.prevPosition.values.push(n.x,n.y,n.z),x.prevPosition.values.push(n.x,n.y,n.z),x.nextPosition.values.push(w.x,w.y,w.z,w.x,w.y,w.z),x.nextPosition.values.push(s[3*t],s[3*t+1],s[3*t+2]),x.nextPosition.values.push(s[3*t+3],s[3*t+4],s[3*t+5]);let I=Math.abs(v.fromArray(a,2*e,eO).y);T.expandAndWidth.values.push(-1,I,1,I),T.expandAndWidth.values.push(-1,-I,1,-I),x.expandAndWidth.values.push(-1,I,1,I),x.expandAndWidth.values.push(-1,-I,1,-I);let E=h.magnitudeSquared(h.subtract(P,i,eq));if(E/=h.magnitudeSquared(h.subtract(w,i,eq)),S(l)){let r=c.fromArray(l,4*e,eF),i=c.fromArray(l,4*t,eF),n=g.lerp(r.x,i.x,E),o=g.lerp(r.y,i.y,E),s=g.lerp(r.z,i.z,E),a=g.lerp(r.w,i.w,E);for(y=4*e;y<4*e+8;++y)T.color.values.push(l[y]);for(T.color.values.push(n,o,s,a),T.color.values.push(n,o,s,a),x.color.values.push(n,o,s,a),x.color.values.push(n,o,s,a),y=4*t;y<4*t+8;++y)x.color.values.push(l[y])}if(S(u)){let r=v.fromArray(u,2*e,eO),i=v.fromArray(u,(f+3)*2,eL),n=g.lerp(r.x,i.x,E);for(y=2*e;y<2*e+4;++y)T.st.values.push(u[y]);for(T.st.values.push(n,r.y),T.st.values.push(n,i.y),x.st.values.push(n,r.y),x.st.values.push(n,i.y),y=2*t;y<2*t+4;++y)x.st.values.push(u[y])}d=T.position.values.length/3-4,A.push(d,d+2,d+1),A.push(d+1,d+2,d+3),d=x.position.values.length/3-4,N.push(d,d+2,d+1),N.push(d+1,d+2,d+3)}else{let e,t;for(i.y<0?(e=m.attributes,t=m.indices):(e=p.attributes,t=p.indices),e.position.values.push(i.x,i.y,i.z),e.position.values.push(i.x,i.y,i.z),e.position.values.push(w.x,w.y,w.z),e.position.values.push(w.x,w.y,w.z),y=3*f;y<3*f+12;++y)e.prevPosition.values.push(o[y]),e.nextPosition.values.push(s[y]);for(y=2*f;y<2*f+8;++y)e.expandAndWidth.values.push(a[y]),S(u)&&e.st.values.push(u[y]);if(S(l))for(y=4*f;y<4*f+16;++y)e.color.values.push(l[y]);d=e.position.values.length/3-4,t.push(d,d+2,d+1),t.push(d+1,d+2,d+3)}}b&&(eC(m),eC(p)),ep(e,m,p)}(e);break;case o.TRIANGLES:eS(e);break;case o.LINES:eE(e)}else(function(e){switch(e.primitiveType){case s.TRIANGLE_FAN:let t=a.computeNumberOfVertices(e);if(t<3)throw new T("The number of vertices must be at least three.");let r=n.createTypedArray(t,(t-2)*3);r[0]=1,r[1]=0,r[2]=2;let i=3;for(let e=3;e<t;++e)r[i++]=e-1,r[i++]=0,r[i++]=e;return e.indices=r,e.primitiveType=s.TRIANGLES;case s.TRIANGLE_STRIP:let o=a.computeNumberOfVertices(e);if(o<3)throw new T("The number of vertices must be at least 3.");let u=n.createTypedArray(o,(o-2)*3);u[0]=0,u[1]=1,u[2]=2,o>3&&(u[3]=0,u[4]=2,u[5]=3);let l=6;for(let e=3;e<o-1;e+=2)u[l++]=e,u[l++]=e-1,u[l++]=e+1,e+2<o&&(u[l++]=e,u[l++]=e+1,u[l++]=e+2);return e.indices=u,e.primitiveType=s.TRIANGLES;case s.TRIANGLES:if(S(e.indices))return;let p=a.computeNumberOfVertices(e);if(p<3)throw new T("The number of vertices must be at least three.");if(p%3!=0)throw new T("The number of vertices must be a multiple of three.");let m=n.createTypedArray(p,p);for(let e=0;e<p;++e)m[e]=e;return e.indices=m;case s.LINE_STRIP:let c=a.computeNumberOfVertices(e);if(c<2)throw new T("The number of vertices must be at least two.");let f=n.createTypedArray(c,(c-1)*2);f[0]=0,f[1]=1;let y=2;for(let e=2;e<c;++e)f[y++]=e-1,f[y++]=e;return e.indices=f,e.primitiveType=s.LINES;case s.LINE_LOOP:let h=a.computeNumberOfVertices(e);if(h<2)throw new T("The number of vertices must be at least two.");let d=n.createTypedArray(h,2*h);d[0]=0,d[1]=1;let v=2;for(let e=2;e<h;++e)d[v++]=e-1,d[v++]=e;return d[v++]=h-1,d[v]=0,e.indices=d,e.primitiveType=s.LINES;case s.LINES:if(S(e.indices))return;let b=a.computeNumberOfVertices(e);if(b<2)throw new T("The number of vertices must be at least two.");if(b%2!=0)throw new T("The number of vertices must be a multiple of 2.");let w=n.createTypedArray(b,b);for(let e=0;e<b;++e)w[e]=e;return e.indices=w}})(t),t.primitiveType===s.TRIANGLES?eS(e):t.primitiveType===s.LINES&&eE(e);return e};var eU=O;export{eU as a};