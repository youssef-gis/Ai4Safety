import{a as e}from"./chunk-U6GWZBRL.js";import{a as o,c as r}from"./chunk-Q4W25C4L.js";import"./chunk-QORMFUM4.js";import"./chunk-FWF3VNA2.js";import"./chunk-ET7KY3BS.js";import"./chunk-CUP6SILZ.js";import{a as i,b as t}from"./chunk-IYO6TYGP.js";import{a as n}from"./chunk-AZLP5742.js";import"./chunk-5HPISDSZ.js";import"./chunk-HSJ6GSLC.js";import"./chunk-SXKYZMEL.js";import{a as s}from"./chunk-T6Q6HX5J.js";import{a as a}from"./chunk-4MJDNHOT.js";import{b as p,c as c,d as l}from"./chunk-EDF5FKWJ.js";import{d as h}from"./chunk-XQIJGAVD.js";import"./chunk-UTYWXSQT.js";import{a as u}from"./chunk-RCHWDG3R.js";import"./chunk-4WJUWBRK.js";import"./chunk-5G23AKP3.js";import{a as m,c as k,d as d,f as f}from"./chunk-KWAHJ72S.js";import{a as y}from"./chunk-MKDADUG3.js";import{a as g}from"./chunk-NOIUI5SY.js";import{e as _}from"./chunk-XRRBRTKL.js";function j(e){let r=(e=e??f.EMPTY_OBJECT).polylinePositions,i=e.shapePositions;if(!_(r))throw new g("options.polylinePositions is required.");if(!_(i))throw new g("options.shapePositions is required.");this._positions=r,this._shape=i,this._ellipsoid=d.clone(e.ellipsoid??d.default),this._cornerType=e.cornerType??o.ROUNDED,this._granularity=e.granularity??y.RADIANS_PER_DEGREE,this._workerName="createPolylineVolumeOutlineGeometry";let t=1+r.length*m.packedLength;t+=1+i.length*k.packedLength,this.packedLength=t+d.packedLength+2}j.pack=function(e,o,r){if(!_(e))throw new g("value is required");if(!_(o))throw new g("array is required");r=r??0;let i,t=e._positions,n=t.length;for(o[r++]=n,i=0;i<n;++i,r+=m.packedLength)m.pack(t[i],o,r);let s=e._shape;for(n=s.length,o[r++]=n,i=0;i<n;++i,r+=k.packedLength)k.pack(s[i],o,r);return d.pack(e._ellipsoid,o,r),r+=d.packedLength,o[r++]=e._cornerType,o[r]=e._granularity,o};var L=d.clone(d.UNIT_SPHERE),P={polylinePositions:void 0,shapePositions:void 0,ellipsoid:L,height:void 0,cornerType:void 0,granularity:void 0};j.unpack=function(e,o,r){if(!_(e))throw new g("array is required");o=o??0;let i,t=e[o++],n=Array(t);for(i=0;i<t;++i,o+=m.packedLength)n[i]=m.unpack(e,o);let s=Array(t=e[o++]);for(i=0;i<t;++i,o+=k.packedLength)s[i]=k.unpack(e,o);let a=d.unpack(e,o,L);o+=d.packedLength;let p=e[o++],c=e[o];return _(r)?(r._positions=n,r._shape=s,r._ellipsoid=d.clone(a,r._ellipsoid),r._cornerType=p,r._granularity=c,r):(P.polylinePositions=n,P.shapePositions=s,P.cornerType=p,P.granularity=c,new j(P))};var T=new e;j.createGeometry=function(o){let k=n(o._positions,m.equalsEpsilon),d=o._shape;if(d=r.removeDuplicatesFromShape(d),k.length<2||d.length<3)return;t.computeWindingOrder2D(d)===i.CLOCKWISE&&d.reverse();let f=e.fromPoints(d,T);return function(e,o){let r=new a;r.position=new l({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:e});let i=o.length,t=r.position.values.length/3,n=e.length/3/i,m=s.createTypedArray(t,2*i*(n+1)),k,d,f=0,y=(k=0)*i;for(d=0;d<i-1;d++)m[f++]=d+y,m[f++]=d+y+1;for(m[f++]=i-1+y,m[f++]=y,y=(k=n-1)*i,d=0;d<i-1;d++)m[f++]=d+y,m[f++]=d+y+1;for(m[f++]=i-1+y,m[f++]=y,k=0;k<n-1;k++){let e=i*k,o=e+i;for(d=0;d<i;d++)m[f++]=d+e,m[f++]=d+o}return new c({attributes:r,indices:s.createTypedArray(t,m),boundingSphere:h.fromVertices(e),primitiveType:p.LINES})}(r.computePositions(k,d,f,o,!1),d)};var w=function(e,o){return _(o)&&(e=j.unpack(e,o)),e._ellipsoid=d.clone(e._ellipsoid),j.createGeometry(e)};export{w as default};