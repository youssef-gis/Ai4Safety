import{a as t}from"./chunk-FVGSQINW.js";import{a as e}from"./chunk-Q4W25C4L.js";import"./chunk-QORMFUM4.js";import"./chunk-FWF3VNA2.js";import{a as r}from"./chunk-T77EB7BE.js";import{a as o}from"./chunk-APG2S62J.js";import"./chunk-ET7KY3BS.js";import"./chunk-CUP6SILZ.js";import{b as i}from"./chunk-IYO6TYGP.js";import{a as a}from"./chunk-AZLP5742.js";import"./chunk-5HPISDSZ.js";import"./chunk-HSJ6GSLC.js";import"./chunk-SXKYZMEL.js";import{a as n}from"./chunk-T6Q6HX5J.js";import{a as l}from"./chunk-4MJDNHOT.js";import{b as s,c as u,d as d}from"./chunk-EDF5FKWJ.js";import{d as m}from"./chunk-XQIJGAVD.js";import{i as h}from"./chunk-UTYWXSQT.js";import{a as c}from"./chunk-RCHWDG3R.js";import"./chunk-4WJUWBRK.js";import"./chunk-5G23AKP3.js";import{a as f,b as p,d as g,f as A}from"./chunk-KWAHJ72S.js";import{a as y}from"./chunk-MKDADUG3.js";import{b as b}from"./chunk-NOIUI5SY.js";import{e as _}from"./chunk-XRRBRTKL.js";var w=new f,v=new f,T=new f,k=new f,E=new f,P=new f,M=new f,O=new f;function F(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function S(e,r,o,i,a,n){let l=e.normals,s=e.tangents,u=e.bitangents,d=f.normalize(f.cross(o,r,M),M);n.normal&&t.addAttribute(l,r,i,a),n.tangent&&t.addAttribute(s,d,i,a),n.bitangent&&t.addAttribute(u,o,i,a)}function x(e,r,o){let i,a,s=e.positions,u=e.corners,m=e.endPositions,h=e.lefts,p=e.normals,g=new l,A,b=0,E=0,F,x=0,D;for(F=0;F<s.length;F+=2)b+=D=s[F].length-3,x+=2*D,E+=s[F+1].length-3;for(b+=3,E+=3,F=0;F<u.length;F++){A=u[F];let t=u[F].leftPositions;_(t)?b+=D=t.length:E+=D=u[F].rightPositions.length,x+=D}let N=_(m),j;N&&(b+=j=m[0].length-3,E+=j,j/=3,x+=6*j);let L=b+E,R=new Float64Array(L),H={normals:r.normal?new Float32Array(L):void 0,tangents:r.tangent?new Float32Array(L):void 0,bitangents:r.bitangent?new Float32Array(L):void 0},I=0,V=L-1,G,U,z,B,W=w,C=v,Y,J,K=j/2,Q=n.createTypedArray(L/3,x),X=0;if(N){J=T,Y=k;let e=m[0];for(W=f.fromArray(p,0,W),C=f.fromArray(h,0,C),F=0;F<K;F++)J=f.fromArray(e,(K-1-F)*3,J),Y=f.fromArray(e,(K+F)*3,Y),t.addAttribute(R,Y,I),t.addAttribute(R,J,void 0,V),S(H,W,C,I,V,r),B=(U=I/3)+1,z=(G=(V-2)/3)-1,Q[X++]=G,Q[X++]=U,Q[X++]=z,Q[X++]=z,Q[X++]=U,Q[X++]=B,I+=3,V-=3}let Z=0,q=0,$=s[Z++],tt=s[Z++];for(R.set($,I),R.set(tt,V-tt.length+1),C=f.fromArray(h,q,C),D=tt.length-3,F=0;F<D;F+=3)i=o.geodeticSurfaceNormal(f.fromArray($,F,M),M),a=o.geodeticSurfaceNormal(f.fromArray(tt,D-F,O),O),S(H,W=f.normalize(f.add(i,a,W),W),C,I,V,r),B=(U=I/3)+1,z=(G=(V-2)/3)-1,Q[X++]=G,Q[X++]=U,Q[X++]=z,Q[X++]=z,Q[X++]=U,Q[X++]=B,I+=3,V-=3;for(i=o.geodeticSurfaceNormal(f.fromArray($,D,M),M),a=o.geodeticSurfaceNormal(f.fromArray(tt,D,O),O),W=f.normalize(f.add(i,a,W),W),q+=3,F=0;F<u.length;F++){let e,n=(A=u[F]).leftPositions,l=A.rightPositions,d,m,c=P,g=T,y=k;if(W=f.fromArray(p,q,W),_(n)){for(S(H,W,C,void 0,V,r),V-=3,d=B,m=z,e=0;e<n.length/3;e++)c=f.fromArray(n,3*e,c),Q[X++]=d,Q[X++]=m-e-1,Q[X++]=m-e,t.addAttribute(R,c,void 0,V),g=f.fromArray(R,(m-e-1)*3,g),y=f.fromArray(R,3*d,y),S(H,W,C=f.normalize(f.subtract(g,y,C),C),void 0,V,r),V-=3;c=f.fromArray(R,3*d,c),g=f.subtract(f.fromArray(R,3*m,g),c,g),y=f.subtract(f.fromArray(R,(m-e)*3,y),c,y),S(H,W,C=f.normalize(f.add(g,y,C),C),I,void 0,r),I+=3}else{for(S(H,W,C,I,void 0,r),I+=3,d=z,m=B,e=0;e<l.length/3;e++)c=f.fromArray(l,3*e,c),Q[X++]=d,Q[X++]=m+e,Q[X++]=m+e+1,t.addAttribute(R,c,I),g=f.fromArray(R,3*d,g),y=f.fromArray(R,(m+e)*3,y),S(H,W,C=f.normalize(f.subtract(g,y,C),C),I,void 0,r),I+=3;c=f.fromArray(R,3*d,c),g=f.subtract(f.fromArray(R,(m+e)*3,g),c,g),y=f.subtract(f.fromArray(R,3*m,y),c,y),S(H,W,C=f.normalize(f.negate(f.add(y,g,C),C),C),void 0,V,r),V-=3}for($=s[Z++],tt=s[Z++],$.splice(0,3),tt.splice(tt.length-3,3),R.set($,I),R.set(tt,V-tt.length+1),D=tt.length-3,q+=3,C=f.fromArray(h,q,C),e=0;e<tt.length;e+=3)i=o.geodeticSurfaceNormal(f.fromArray($,e,M),M),a=o.geodeticSurfaceNormal(f.fromArray(tt,D-e,O),O),S(H,W=f.normalize(f.add(i,a,W),W),C,I,V,r),U=(B=I/3)-1,G=(z=(V-2)/3)+1,Q[X++]=G,Q[X++]=U,Q[X++]=z,Q[X++]=z,Q[X++]=U,Q[X++]=B,I+=3,V-=3;I-=3,V+=3}if(S(H,W=f.fromArray(p,p.length-3,W),C,I,V,r),N){I+=3,V-=3,J=T,Y=k;let e=m[1];for(F=0;F<K;F++)J=f.fromArray(e,(j-F-1)*3,J),Y=f.fromArray(e,3*F,Y),t.addAttribute(R,J,void 0,V),t.addAttribute(R,Y,I),S(H,W,C,I,V,r),U=(B=I/3)-1,G=(z=(V-2)/3)+1,Q[X++]=G,Q[X++]=U,Q[X++]=z,Q[X++]=z,Q[X++]=U,Q[X++]=B,I+=3,V-=3}if(g.position=new d({componentDatatype:c.DOUBLE,componentsPerAttribute:3,values:R}),r.st){let t=new Float32Array(L/3*2),e,r,o=0;if(N){b/=3,E/=3;let i=Math.PI/(j+1);r=1/(b-j+1),e=1/(E-j+1);let a,n=j/2;for(F=n+1;F<j+1;F++)a=y.PI_OVER_TWO+i*F,t[o++]=e*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(F=1;F<E-j+1;F++)t[o++]=F*e,t[o++]=0;for(F=j;F>n;F--)a=y.PI_OVER_TWO-F*i,t[o++]=1-e*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(F=n;F>0;F--)a=y.PI_OVER_TWO-i*F,t[o++]=1-r*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(F=b-j;F>0;F--)t[o++]=F*r,t[o++]=1;for(F=1;F<n+1;F++)a=y.PI_OVER_TWO+i*F,t[o++]=r*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a))}else{for(b/=3,E/=3,r=1/(b-1),e=1/(E-1),F=0;F<E;F++)t[o++]=F*e,t[o++]=0;for(F=b;F>0;F--)t[o++]=(F-1)*r,t[o++]=1}g.st=new d({componentDatatype:c.FLOAT,componentsPerAttribute:2,values:t})}return r.normal&&(g.normal=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:H.normals})),r.tangent&&(g.tangent=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:H.tangents})),r.bitangent&&(g.bitangent=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:H.bitangents})),{attributes:g,indices:Q}}function D(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let o=3;o<t.length;o+=3){let i=t[o],a=t[o+1],n=t[o+2];r[e++]=i,r[e++]=a,r[e++]=n,r[e++]=i,r[e++]=a,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}var N=new f,j=new f,L=new p;function R(t,e,r,o,i,a){let n=f.subtract(e,t,N);f.normalize(n,n);let l=r.geodeticSurfaceNormal(t,j),s=f.cross(n,l,N);f.multiplyByScalar(s,o,s);let u=i.latitude,d=i.longitude,m=a.latitude,h=a.longitude;f.add(t,s,j),r.cartesianToCartographic(j,L);let c=L.latitude,p=L.longitude;u=Math.min(u,c),d=Math.min(d,p),m=Math.max(m,c),h=Math.max(h,p),f.subtract(t,s,j),r.cartesianToCartographic(j,L),c=L.latitude,p=L.longitude,u=Math.min(u,c),d=Math.min(d,p),m=Math.max(m,c),h=Math.max(h,p),i.latitude=u,i.longitude=d,a.latitude=m,a.longitude=h}var H=new f,I=new f,V=new p,G=new p;function U(t,r,o,i,n){let l,s,u=a(t=F(t,r),f.equalsEpsilon),d=u.length;if(d<2||o<=0)return new h;let m=.5*o;if(V.latitude=1/0,V.longitude=1/0,G.latitude=-1/0,G.longitude=-1/0,i===e.ROUNDED){let t=u[0];f.subtract(t,u[1],H),f.normalize(H,H),f.multiplyByScalar(H,m,H),f.add(t,H,I),r.cartesianToCartographic(I,L),l=L.latitude,s=L.longitude,V.latitude=Math.min(V.latitude,l),V.longitude=Math.min(V.longitude,s),G.latitude=Math.max(G.latitude,l),G.longitude=Math.max(G.longitude,s)}for(let t=0;t<d-1;++t)R(u[t],u[t+1],r,m,V,G);let c=u[d-1];f.subtract(c,u[d-2],H),f.normalize(H,H),f.multiplyByScalar(H,m,H),f.add(c,H,I),R(c,I,r,m,V,G),i===e.ROUNDED&&(r.cartesianToCartographic(I,L),l=L.latitude,s=L.longitude,V.latitude=Math.min(V.latitude,l),V.longitude=Math.min(V.longitude,s),G.latitude=Math.max(G.latitude,l),G.longitude=Math.max(G.longitude,s));let p=_(n)?n:new h;return p.north=G.latitude,p.south=V.latitude,p.east=G.longitude,p.west=V.longitude,p}function z(t){let r=(t=t??A.EMPTY_OBJECT).positions,i=t.width;b.defined("options.positions",r),b.defined("options.width",i);let a=t.height??0,n=t.extrudedHeight??a;this._positions=r,this._ellipsoid=g.clone(t.ellipsoid??g.default),this._vertexFormat=o.clone(t.vertexFormat??o.DEFAULT),this._width=i,this._height=Math.max(a,n),this._extrudedHeight=Math.min(a,n),this._cornerType=t.cornerType??e.ROUNDED,this._granularity=t.granularity??y.RADIANS_PER_DEGREE,this._shadowVolume=t.shadowVolume??!1,this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+r.length*f.packedLength+g.packedLength+o.packedLength+7}z.pack=function(t,e,r){b.defined("value",t),b.defined("array",e),r=r??0;let i=t._positions,a=i.length;e[r++]=a;for(let t=0;t<a;++t,r+=f.packedLength)f.pack(i[t],e,r);return g.pack(t._ellipsoid,e,r),r+=g.packedLength,o.pack(t._vertexFormat,e,r),r+=o.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=+!!t._shadowVolume,e[r]=t._offsetAttribute??-1,e};var B=g.clone(g.UNIT_SPHERE),W=new o,C={positions:void 0,ellipsoid:B,vertexFormat:W,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};z.unpack=function(t,e,r){b.defined("array",t),e=e??0;let i=t[e++],a=Array(i);for(let r=0;r<i;++r,e+=f.packedLength)a[r]=f.unpack(t,e);let n=g.unpack(t,e,B);e+=g.packedLength;let l=o.unpack(t,e,W);e+=o.packedLength;let s=t[e++],u=t[e++],d=t[e++],m=t[e++],h=t[e++],c=1===t[e++],p=t[e];return _(r)?(r._positions=a,r._ellipsoid=g.clone(n,r._ellipsoid),r._vertexFormat=o.clone(l,r._vertexFormat),r._width=s,r._height=u,r._extrudedHeight=d,r._cornerType=m,r._granularity=h,r._shadowVolume=c,r._offsetAttribute=-1===p?void 0:p,r):(C.positions=a,C.width=s,C.height=u,C.extrudedHeight=d,C.cornerType=m,C.granularity=h,C.shadowVolume=c,C.offsetAttribute=-1===p?void 0:p,new z(C))},z.computeRectangle=function(t,r){let o=(t=t??A.EMPTY_OBJECT).positions,i=t.width;return b.defined("options.positions",o),b.defined("options.width",i),U(o,t.ellipsoid??g.default,i,t.cornerType??e.ROUNDED,r)},z.createGeometry=function(e){let l=e._positions,h=e._width,p=e._ellipsoid,g=a(l=F(l,p),f.equalsEpsilon);if(g.length<2||h<=0)return;let A=e._height,b=e._extrudedHeight,M=!y.equalsEpsilon(A,b,0,y.EPSILON2),O=e._vertexFormat,S={ellipsoid:p,positions:g,width:h,cornerType:e._cornerType,granularity:e._granularity,saveAttributes:!0},N;if(M)S.height=A,S.extrudedHeight=b,S.shadowVolume=e._shadowVolume,S.offsetAttribute=e._offsetAttribute,N=function(e,a){let l,s,u,m,h=new o({position:a.position,normal:a.normal||a.bitangent||e.shadowVolume,tangent:a.tangent,bitangent:a.normal||a.bitangent,st:a.st}),p=e.ellipsoid,g=x(t.computePositions(e),h,p),A=e.height,y=e.extrudedHeight,b=g.attributes,M=g.indices,O=b.position.values,F=O.length,S=new Float64Array(6*F),N=new Float64Array(F);N.set(O);let j=new Float64Array(4*F);j=D(O=i.scaleToGeodeticHeight(O,A,p),0,j),j=D(N=i.scaleToGeodeticHeight(N,y,p),2*F,j),S.set(O),S.set(N,F),S.set(j,2*F),b.position.values=S,b=function(e,r){if(!r.normal&&!r.tangent&&!r.bitangent&&!r.st)return e;let o=e.position.values,i,a;(r.normal||r.bitangent)&&(i=e.normal.values,a=e.bitangent.values);let n=e.position.values.length/18,l=3*n,s=2*n,u=2*l,d;if(r.normal||r.bitangent||r.tangent){let n=r.normal?new Float32Array(6*l):void 0,s=r.tangent?new Float32Array(6*l):void 0,m=r.bitangent?new Float32Array(6*l):void 0,h=w,c=v,p=T,g=k,A=E,y=P,b=u;for(d=0;d<l;d+=3){let e=b+u;h=f.fromArray(o,d,h),c=f.fromArray(o,d+l,c),p=f.fromArray(o,(d+3)%l,p),c=f.subtract(c,h,c),p=f.subtract(p,h,p),g=f.normalize(f.cross(c,p,g),g),r.normal&&(t.addAttribute(n,g,e),t.addAttribute(n,g,e+3),t.addAttribute(n,g,b),t.addAttribute(n,g,b+3)),(r.tangent||r.bitangent)&&(y=f.fromArray(i,d,y),r.bitangent&&(t.addAttribute(m,y,e),t.addAttribute(m,y,e+3),t.addAttribute(m,y,b),t.addAttribute(m,y,b+3)),r.tangent&&(A=f.normalize(f.cross(y,g,A),A),t.addAttribute(s,A,e),t.addAttribute(s,A,e+3),t.addAttribute(s,A,b),t.addAttribute(s,A,b+3))),b+=6}if(r.normal){for(n.set(i),d=0;d<l;d+=3)n[d+l]=-i[d],n[d+l+1]=-i[d+1],n[d+l+2]=-i[d+2];e.normal.values=n}else e.normal=void 0;if(r.bitangent?(m.set(a),m.set(a,l),e.bitangent.values=m):e.bitangent=void 0,r.tangent){let t=e.tangent.values;s.set(t),s.set(t,l),e.tangent.values=s}}if(r.st){let t=e.st.values,r=new Float32Array(6*s);r.set(t),r.set(t,s);let o=2*s;for(let e=0;e<2;e++){for(r[o++]=t[0],r[o++]=t[1],d=2;d<s;d+=2){let e=t[d],i=t[d+1];r[o++]=e,r[o++]=i,r[o++]=e,r[o++]=i}r[o++]=t[0],r[o++]=t[1]}e.st.values=r}return e}(b,a);let L,R=F/3;if(e.shadowVolume){let t=b.normal.values,e=new Float32Array(6*(F=t.length));for(L=0;L<F;L++)t[L]=-t[L];e.set(t,F),e=D(t,4*F,e),b.extrudeDirection=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:e}),a.normal||(b.normal=void 0)}if(_(e.offsetAttribute)){let t=new Uint8Array(6*R);if(e.offsetAttribute===r.TOP)t=t.fill(1,0,R).fill(1,2*R,4*R);else{let o=+(e.offsetAttribute!==r.NONE);t=t.fill(o)}b.applyOffset=new d({componentDatatype:c.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let H=M.length,I=R+R,V=n.createTypedArray(S.length/3,2*H+3*I);V.set(M);let G=H;for(L=0;L<H;L+=3){let t=M[L],e=M[L+1],r=M[L+2];V[G++]=r+R,V[G++]=e+R,V[G++]=t+R}for(L=0;L<I;L+=2)s=(l=L+I)+I,u=l+1,m=s+1,V[G++]=l,V[G++]=s,V[G++]=u,V[G++]=u,V[G++]=s,V[G++]=m;return{attributes:b,indices:V}}(S,O);else if((N=x(t.computePositions(S),O,p)).attributes.position.values=i.scaleToGeodeticHeight(N.attributes.position.values,A,p),_(e._offsetAttribute)){let t=+(e._offsetAttribute!==r.NONE),o=new Uint8Array(N.attributes.position.values.length/3).fill(t);N.attributes.applyOffset=new d({componentDatatype:c.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}let j=N.attributes,L=m.fromVertices(j.position.values,void 0,3);return O.position||(N.attributes.position.values=void 0),new u({attributes:j,indices:N.indices,primitiveType:s.TRIANGLES,boundingSphere:L,offsetAttribute:e._offsetAttribute})},z.createShadowVolume=function(t,e,r){let i=t._granularity,a=t._ellipsoid,n=e(i,a),l=r(i,a);return new z({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:a,granularity:i,extrudedHeight:n,height:l,vertexFormat:o.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(z.prototype,{rectangle:{get:function(){return _(this._rectangle)||(this._rectangle=U(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}});var Y=function(t,e){return _(e)&&(t=z.unpack(t,e)),t._ellipsoid=g.clone(t._ellipsoid),z.createGeometry(t)};export{Y as default};