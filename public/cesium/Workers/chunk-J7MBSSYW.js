import{a as i}from"./chunk-T77EB7BE.js";import{a as t}from"./chunk-T6Q6HX5J.js";import{a as o}from"./chunk-4MJDNHOT.js";import{b as e,c as r,d as n}from"./chunk-EDF5FKWJ.js";import{d as a}from"./chunk-XQIJGAVD.js";import{a as s}from"./chunk-RCHWDG3R.js";import{a as m,d as u,f as f}from"./chunk-KWAHJ72S.js";import{a as c}from"./chunk-MKDADUG3.js";import{a as l}from"./chunk-NOIUI5SY.js";import{e as d}from"./chunk-XRRBRTKL.js";var h=new m(1,1,1),_=Math.cos,k=Math.sin;function p(t){let o=(t=t??f.EMPTY_OBJECT).radii??h,e=t.innerRadii??o,r=t.minimumClock??0,n=t.maximumClock??c.TWO_PI,a=t.minimumCone??0,s=t.maximumCone??c.PI,u=Math.round(t.stackPartitions??10),_=Math.round(t.slicePartitions??8),k=Math.round(t.subdivisions??128);if(u<1)throw new l("options.stackPartitions cannot be less than 1");if(_<0)throw new l("options.slicePartitions cannot be less than 0");if(k<0)throw new l("options.subdivisions must be greater than or equal to zero.");if(d(t.offsetAttribute)&&t.offsetAttribute===i.TOP)throw new l("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=m.clone(o),this._innerRadii=m.clone(e),this._minimumClock=r,this._maximumClock=n,this._minimumCone=a,this._maximumCone=s,this._stackPartitions=u,this._slicePartitions=_,this._subdivisions=k,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}p.packedLength=2*m.packedLength+8,p.pack=function(i,t,o){if(!d(i))throw new l("value is required");if(!d(t))throw new l("array is required");return o=o??0,m.pack(i._radii,t,o),o+=m.packedLength,m.pack(i._innerRadii,t,o),o+=m.packedLength,t[o++]=i._minimumClock,t[o++]=i._maximumClock,t[o++]=i._minimumCone,t[o++]=i._maximumCone,t[o++]=i._stackPartitions,t[o++]=i._slicePartitions,t[o++]=i._subdivisions,t[o]=i._offsetAttribute??-1,t};var b=new m,C=new m,y={radii:b,innerRadii:C,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};p.unpack=function(i,t,o){if(!d(i))throw new l("array is required");t=t??0;let e=m.unpack(i,t,b);t+=m.packedLength;let r=m.unpack(i,t,C);t+=m.packedLength;let n=i[t++],a=i[t++],s=i[t++],u=i[t++],f=i[t++],c=i[t++],h=i[t++],_=i[t];return d(o)?(o._radii=m.clone(e,o._radii),o._innerRadii=m.clone(r,o._innerRadii),o._minimumClock=n,o._maximumClock=a,o._minimumCone=s,o._maximumCone=u,o._stackPartitions=f,o._slicePartitions=c,o._subdivisions=h,o._offsetAttribute=-1===_?void 0:_,o):(y.minimumClock=n,y.maximumClock=a,y.minimumCone=s,y.maximumCone=u,y.stackPartitions=f,y.slicePartitions=c,y.subdivisions=h,y.offsetAttribute=-1===_?void 0:_,new p(y))},p.createGeometry=function(m){let f=m._radii;if(f.x<=0||f.y<=0||f.z<=0)return;let l=m._innerRadii;if(l.x<=0||l.y<=0||l.z<=0)return;let h=m._minimumClock,p=m._maximumClock,b=m._minimumCone,C=m._maximumCone,y=m._subdivisions,A=u.fromCartesian3(f),P=m._slicePartitions+1,v=m._stackPartitions+1;P=Math.round(P*Math.abs(p-h)/c.TWO_PI),v=Math.round(v*Math.abs(C-b)/c.PI),P<2&&(P=2),v<2&&(v=2);let w=0,x=1,g=l.x!==f.x||l.y!==f.y||l.z!==f.z,M=!1,T=!1;g&&(x=2,b>0&&(M=!0,w+=P),C<Math.PI&&(T=!0,w+=P));let E=y*x*(v+P),O=new Float64Array(3*E),R=2*(E+w-(P+v)*x),j=t.createTypedArray(E,R),D,I,z,L,N=0,G=Array(v),B=Array(v);for(D=0;D<v;D++)L=b+D*(C-b)/(v-1),G[D]=k(L),B[D]=_(L);let J=Array(y),S=Array(y);for(D=0;D<y;D++)z=h+D*(p-h)/(y-1),J[D]=k(z),S[D]=_(z);for(D=0;D<v;D++)for(I=0;I<y;I++)O[N++]=f.x*G[D]*S[I],O[N++]=f.y*G[D]*J[I],O[N++]=f.z*B[D];if(g)for(D=0;D<v;D++)for(I=0;I<y;I++)O[N++]=l.x*G[D]*S[I],O[N++]=l.y*G[D]*J[I],O[N++]=l.z*B[D];for(G.length=y,B.length=y,D=0;D<y;D++)L=b+D*(C-b)/(y-1),G[D]=k(L),B[D]=_(L);for(J.length=P,S.length=P,D=0;D<P;D++)z=h+D*(p-h)/(P-1),J[D]=k(z),S[D]=_(z);for(D=0;D<y;D++)for(I=0;I<P;I++)O[N++]=f.x*G[D]*S[I],O[N++]=f.y*G[D]*J[I],O[N++]=f.z*B[D];if(g)for(D=0;D<y;D++)for(I=0;I<P;I++)O[N++]=l.x*G[D]*S[I],O[N++]=l.y*G[D]*J[I],O[N++]=l.z*B[D];for(N=0,D=0;D<v*x;D++){let i=D*y;for(I=0;I<y-1;I++)j[N++]=i+I,j[N++]=i+I+1}let U=v*y*x;for(D=0;D<P;D++)for(I=0;I<y-1;I++)j[N++]=U+D+I*P,j[N++]=U+D+(I+1)*P;if(g)for(U=v*y*x+P*y,D=0;D<P;D++)for(I=0;I<y-1;I++)j[N++]=U+D+I*P,j[N++]=U+D+(I+1)*P;if(g){let i=v*y*x,t=i+y*P;if(M)for(D=0;D<P;D++)j[N++]=i+D,j[N++]=t+D;if(T)for(i+=y*P-P,t+=y*P-P,D=0;D<P;D++)j[N++]=i+D,j[N++]=t+D}let W=new o({position:new n({componentDatatype:s.DOUBLE,componentsPerAttribute:3,values:O})});if(d(m._offsetAttribute)){let t=O.length,o=+(m._offsetAttribute!==i.NONE),e=new Uint8Array(t/3).fill(o);W.applyOffset=new n({componentDatatype:s.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return new r({attributes:W,indices:j,primitiveType:e.LINES,boundingSphere:a.fromEllipsoid(A),offsetAttribute:m._offsetAttribute})};var A=p;export{A as a};