import{a as t}from"./chunk-YHWHVNY2.js";import{a as e}from"./chunk-2ZPEMRCT.js";import{a as i}from"./chunk-3BSRJTW3.js";import{a as o}from"./chunk-T77EB7BE.js";import{a as r}from"./chunk-APG2S62J.js";import{a as n}from"./chunk-T6Q6HX5J.js";import{a as a}from"./chunk-4MJDNHOT.js";import{b as s,c as l,d as u}from"./chunk-EDF5FKWJ.js";import{a as m,d as c}from"./chunk-XQIJGAVD.js";import{g as p,i as h}from"./chunk-UTYWXSQT.js";import{a as f}from"./chunk-RCHWDG3R.js";import{a as d,b as y,c as A,d as x,e as g,f as _}from"./chunk-KWAHJ72S.js";import{a as w}from"./chunk-MKDADUG3.js";import{a as b,b as M}from"./chunk-NOIUI5SY.js";import{e as v}from"./chunk-XRRBRTKL.js";var T=new d,P=new d,E=new d,j=new d,O=new A,R=new g,S=new g,N=new p,D=new d,F=new d,k=new d,L=new y,I=new d,z=new A,B=new A;function V(e,i,r){let n=i.vertexFormat,s=i.center,l=i.semiMajorAxis,c=i.semiMinorAxis,h=i.ellipsoid,y=i.stRotation,x=r?e.length/3*2:e.length/3,_=i.shadowVolume,w=n.st?new Float32Array(2*x):void 0,b=n.normal?new Float32Array(3*x):void 0,M=n.tangent?new Float32Array(3*x):void 0,j=n.bitangent?new Float32Array(3*x):void 0,V=_?new Float32Array(3*x):void 0,G=0,H=D,C=F,U=k,Y=new m(h),J=Y.project(h.cartesianToCartographic(s,L),I),W=h.scaleToGeodeticSurface(s,T);h.geodeticSurfaceNormal(W,W);let Q=R,K=S;if(0!==y){let t=p.fromAxisAngle(W,y,N);Q=g.fromQuaternion(t,Q),t=p.fromAxisAngle(W,-y,N),K=g.fromQuaternion(t,K)}else Q=g.clone(g.IDENTITY,Q),K=g.clone(g.IDENTITY,K);let X=A.fromElements(1/0,1/0,z),q=A.fromElements(-1/0,-1/0,B),Z=e.length,$=r?Z:0,tt=$/3*2;for(let t=0;t<Z;t+=3){let i=t+1,o=t+2,a=d.fromArray(e,t,T);if(n.st){let t=g.multiplyByVector(Q,a,P),e=Y.project(h.cartesianToCartographic(t,L),E);d.subtract(e,J,e),O.x=(e.x+l)/(2*l),O.y=(e.y+c)/(2*c),X.x=Math.min(O.x,X.x),X.y=Math.min(O.y,X.y),q.x=Math.max(O.x,q.x),q.y=Math.max(O.y,q.y),r&&(w[G+tt]=O.x,w[G+1+tt]=O.y),w[G++]=O.x,w[G++]=O.y}(n.normal||n.tangent||n.bitangent||_)&&(H=h.geodeticSurfaceNormal(a,H),_&&(V[t+$]=-H.x,V[i+$]=-H.y,V[o+$]=-H.z),(n.normal||n.tangent||n.bitangent)&&((n.tangent||n.bitangent)&&(C=d.normalize(d.cross(d.UNIT_Z,H,C),C),g.multiplyByVector(K,C,C)),n.normal&&(b[t]=H.x,b[i]=H.y,b[o]=H.z,r&&(b[t+$]=-H.x,b[i+$]=-H.y,b[o+$]=-H.z)),n.tangent&&(M[t]=C.x,M[i]=C.y,M[o]=C.z,r&&(M[t+$]=-C.x,M[i+$]=-C.y,M[o+$]=-C.z)),n.bitangent&&(U=d.normalize(d.cross(H,C,U),U),j[t]=U.x,j[i]=U.y,j[o]=U.z,r&&(j[t+$]=U.x,j[i+$]=U.y,j[o+$]=U.z))))}if(n.st){Z=w.length;for(let t=0;t<Z;t+=2)w[t]=(w[t]-X.x)/(q.x-X.x),w[t+1]=(w[t+1]-X.y)/(q.y-X.y)}let te=new a;if(n.position){let o=t.raisePositionsToHeight(e,i,r);te.position=new u({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:o})}if(n.st&&(te.st=new u({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:w})),n.normal&&(te.normal=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:b})),n.tangent&&(te.tangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:M})),n.bitangent&&(te.bitangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:j})),_&&(te.extrudeDirection=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:V})),r&&v(i.offsetAttribute)){let t=new Uint8Array(x);if(i.offsetAttribute===o.TOP)t=t.fill(1,0,x/2);else{let e=+(i.offsetAttribute!==o.NONE);t=t.fill(e)}te.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return te}function G(t){let e=Array(t*(t+1)*12-6),i=0,o,r,n,a,s;for(o=0,n=1,a=0;a<3;a++)e[i++]=n++,e[i++]=o,e[i++]=n;for(a=2;a<t+1;++a){for(n=a*(a+1)-1,o=(a-1)*a-1,e[i++]=n++,e[i++]=o,e[i++]=n,r=2*a,s=0;s<r-1;++s)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;e[i++]=n++,e[i++]=o,e[i++]=n}for(r=2*t,++n,++o,a=0;a<r-1;++a)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;for(e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o++,e[i++]=o,++o,a=t-1;a>1;--a){for(e[i++]=o++,e[i++]=o,e[i++]=n,r=2*a,s=0;s<r-1;++s)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;e[i++]=o++,e[i++]=o++,e[i++]=n++}for(a=0;a<3;a++)e[i++]=o++,e[i++]=o,e[i++]=n;return e}var H=new d,C=new c,U=new c;function Y(e,i,o,r,n,a,s){let l=t.computeEllipsePositions({center:e,semiMajorAxis:i,semiMinorAxis:o,rotation:r,granularity:n},!1,!0).outerPositions,u=l.length/3,m=Array(u);for(let t=0;t<u;++t)m[t]=d.fromArray(l,3*t);let c=h.fromCartesianArray(m,a,s);return c.width>w.PI&&(c.north=c.north>0?w.PI_OVER_TWO-w.EPSILON7:c.north,c.south=c.south<0?w.EPSILON7-w.PI_OVER_TWO:c.south,c.east=w.PI,c.west=-w.PI),c}function J(t){let e=(t=t??_.EMPTY_OBJECT).center,i=t.ellipsoid??x.default,o=t.semiMajorAxis,n=t.semiMinorAxis,a=t.granularity??w.RADIANS_PER_DEGREE,s=t.vertexFormat??r.DEFAULT;if(M.defined("options.center",e),M.typeOf.number("options.semiMajorAxis",o),M.typeOf.number("options.semiMinorAxis",n),o<n)throw new b("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new b("granularity must be greater than zero.");let l=t.height??0,u=t.extrudedHeight??l;this._center=d.clone(e),this._semiMajorAxis=o,this._semiMinorAxis=n,this._ellipsoid=x.clone(i),this._rotation=t.rotation??0,this._stRotation=t.stRotation??0,this._height=Math.max(u,l),this._granularity=a,this._vertexFormat=r.clone(s),this._extrudedHeight=Math.min(u,l),this._shadowVolume=t.shadowVolume??!1,this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}J.packedLength=d.packedLength+x.packedLength+r.packedLength+9,J.pack=function(t,e,i){return M.defined("value",t),M.defined("array",e),i=i??0,d.pack(t._center,e,i),i+=d.packedLength,x.pack(t._ellipsoid,e,i),i+=x.packedLength,r.pack(t._vertexFormat,e,i),i+=r.packedLength,e[i++]=t._semiMajorAxis,e[i++]=t._semiMinorAxis,e[i++]=t._rotation,e[i++]=t._stRotation,e[i++]=t._height,e[i++]=t._granularity,e[i++]=t._extrudedHeight,e[i++]=+!!t._shadowVolume,e[i]=t._offsetAttribute??-1,e};var W=new d,Q=new x,K=new r,X={center:W,ellipsoid:Q,vertexFormat:K,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};J.unpack=function(t,e,i){M.defined("array",t),e=e??0;let o=d.unpack(t,e,W);e+=d.packedLength;let n=x.unpack(t,e,Q);e+=x.packedLength;let a=r.unpack(t,e,K);e+=r.packedLength;let s=t[e++],l=t[e++],u=t[e++],m=t[e++],c=t[e++],p=t[e++],h=t[e++],f=1===t[e++],y=t[e];return v(i)?(i._center=d.clone(o,i._center),i._ellipsoid=x.clone(n,i._ellipsoid),i._vertexFormat=r.clone(a,i._vertexFormat),i._semiMajorAxis=s,i._semiMinorAxis=l,i._rotation=u,i._stRotation=m,i._height=c,i._granularity=p,i._extrudedHeight=h,i._shadowVolume=f,i._offsetAttribute=-1===y?void 0:y,i):(X.height=c,X.extrudedHeight=h,X.granularity=p,X.stRotation=m,X.rotation=u,X.semiMajorAxis=s,X.semiMinorAxis=l,X.shadowVolume=f,X.offsetAttribute=-1===y?void 0:y,new J(X))},J.computeRectangle=function(t,e){let i=(t=t??_.EMPTY_OBJECT).center,o=t.ellipsoid??x.default,r=t.semiMajorAxis,n=t.semiMinorAxis,a=t.granularity??w.RADIANS_PER_DEGREE,s=t.rotation??0;if(M.defined("options.center",i),M.typeOf.number("options.semiMajorAxis",r),M.typeOf.number("options.semiMinorAxis",n),r<n)throw new b("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new b("granularity must be greater than zero.");return Y(i,r,n,s,a,o,e)},J.createGeometry=function(r){if(r._semiMajorAxis<=0||r._semiMinorAxis<=0)return;let h=r._height,y=r._extrudedHeight,x=!w.equalsEpsilon(h,y,0,w.EPSILON2);r._center=r._ellipsoid.scaleToGeodeticSurface(r._center,r._center);let _={center:r._center,semiMajorAxis:r._semiMajorAxis,semiMinorAxis:r._semiMinorAxis,ellipsoid:r._ellipsoid,rotation:r._rotation,height:h,granularity:r._granularity,vertexFormat:r._vertexFormat,stRotation:r._stRotation},b;if(x)_.extrudedHeight=y,_.shadowVolume=r._shadowVolume,_.offsetAttribute=r._offsetAttribute,b=function(r){let h=r.center,y=r.ellipsoid,x=r.semiMajorAxis,_=d.multiplyByScalar(y.geodeticSurfaceNormal(h,T),r.height,T);C.center=d.add(h,_,C.center),C.radius=x,_=d.multiplyByScalar(y.geodeticSurfaceNormal(h,_),r.extrudedHeight,_),U.center=d.add(h,_,U.center),U.radius=x;let w=t.computeEllipsePositions(r,!0,!0),b=w.positions,M=w.numPts,S=w.outerPositions,H=c.union(C,U),Y=V(b,r,!0),J=G(M),W=J.length;J.length=2*W;let Q=b.length/3;for(let t=0;t<W;t+=3)J[t+W]=J[t+2]+Q,J[t+1+W]=J[t+1]+Q,J[t+2+W]=J[t]+Q;let K=new l({attributes:Y,indices:n.createTypedArray(2*Q/3,J),primitiveType:s.TRIANGLES}),X=function(t,e){let i=e.vertexFormat,r=e.center,n=e.semiMajorAxis,s=e.semiMinorAxis,l=e.ellipsoid,c=e.height,h=e.extrudedHeight,y=e.stRotation,x=t.length/3*2,_=new Float64Array(3*x),w=i.st?new Float32Array(2*x):void 0,b=i.normal?new Float32Array(3*x):void 0,M=i.tangent?new Float32Array(3*x):void 0,S=i.bitangent?new Float32Array(3*x):void 0,V=e.shadowVolume,G=V?new Float32Array(3*x):void 0,H=0,C=D,U=F,Y=k,J=new m(l),W=J.project(l.cartesianToCartographic(r,L),I),Q=l.scaleToGeodeticSurface(r,T);l.geodeticSurfaceNormal(Q,Q);let K=p.fromAxisAngle(Q,y,N),X=g.fromQuaternion(K,R),q=A.fromElements(1/0,1/0,z),Z=A.fromElements(-1/0,-1/0,B),$=t.length,tt=$/3*2;for(let e=0;e<$;e+=3){let o=e+1,r=e+2,a=d.fromArray(t,e,T),u;if(i.st){let t=g.multiplyByVector(X,a,P),e=J.project(l.cartesianToCartographic(t,L),E);d.subtract(e,W,e),O.x=(e.x+n)/(2*n),O.y=(e.y+s)/(2*s),q.x=Math.min(O.x,q.x),q.y=Math.min(O.y,q.y),Z.x=Math.max(O.x,Z.x),Z.y=Math.max(O.y,Z.y),w[H+tt]=O.x,w[H+1+tt]=O.y,w[H++]=O.x,w[H++]=O.y}a=l.scaleToGeodeticSurface(a,a),u=d.clone(a,P),C=l.geodeticSurfaceNormal(a,C),V&&(G[e+$]=-C.x,G[o+$]=-C.y,G[r+$]=-C.z);let m=d.multiplyByScalar(C,c,j);if(a=d.add(a,m,a),m=d.multiplyByScalar(C,h,m),u=d.add(u,m,u),i.position&&(_[e+$]=u.x,_[o+$]=u.y,_[r+$]=u.z,_[e]=a.x,_[o]=a.y,_[r]=a.z),i.normal||i.tangent||i.bitangent){Y=d.clone(C,Y);let n=d.fromArray(t,(e+3)%$,j);d.subtract(n,a,n);let s=d.subtract(u,a,E);C=d.normalize(d.cross(s,n,C),C),i.normal&&(b[e]=C.x,b[o]=C.y,b[r]=C.z,b[e+$]=C.x,b[o+$]=C.y,b[r+$]=C.z),i.tangent&&(U=d.normalize(d.cross(Y,C,U),U),M[e]=U.x,M[o]=U.y,M[r]=U.z,M[e+$]=U.x,M[e+1+$]=U.y,M[e+2+$]=U.z),i.bitangent&&(S[e]=Y.x,S[o]=Y.y,S[r]=Y.z,S[e+$]=Y.x,S[o+$]=Y.y,S[r+$]=Y.z)}}if(i.st){$=w.length;for(let t=0;t<$;t+=2)w[t]=(w[t]-q.x)/(Z.x-q.x),w[t+1]=(w[t+1]-q.y)/(Z.y-q.y)}let te=new a;if(i.position&&(te.position=new u({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:_})),i.st&&(te.st=new u({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:w})),i.normal&&(te.normal=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:b})),i.tangent&&(te.tangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:M})),i.bitangent&&(te.bitangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:S})),V&&(te.extrudeDirection=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:G})),v(e.offsetAttribute)){let t=new Uint8Array(x);if(e.offsetAttribute===o.TOP)t=t.fill(1,0,x/2);else{let i=+(e.offsetAttribute!==o.NONE);t=t.fill(i)}te.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return te}(S,r);J=function(t){let e=t.length/3,i=n.createTypedArray(e,6*e),o=0;for(let t=0;t<e;t++){let r=t,n=t+e,a=(r+1)%e,s=a+e;i[o++]=r,i[o++]=n,i[o++]=a,i[o++]=a,i[o++]=n,i[o++]=s}return i}(S);let q=new l({attributes:X,indices:n.createTypedArray(2*S.length/3,J),primitiveType:s.TRIANGLES}),Z=i.combineInstances([new e({geometry:K}),new e({geometry:q})]);return{boundingSphere:H,attributes:Z[0].attributes,indices:Z[0].indices}}(_);else{let e,i,a,s,l,m,p;if(e=_.center,H=d.multiplyByScalar(_.ellipsoid.geodeticSurfaceNormal(e,H),_.height,H),i=new c(H=d.add(e,H,H),_.semiMajorAxis),s=(a=t.computeEllipsePositions(_,!0,!1)).positions,l=a.numPts,m=V(s,_,!1),p=G(l),b={boundingSphere:i,attributes:m,indices:p=n.createTypedArray(s.length/3,p)},v(r._offsetAttribute)){let t=b.attributes.position.values.length,e=+(r._offsetAttribute!==o.NONE),i=new Uint8Array(t/3).fill(e);b.attributes.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}return new l({attributes:b.attributes,indices:b.indices,primitiveType:s.TRIANGLES,boundingSphere:b.boundingSphere,offsetAttribute:r._offsetAttribute})},J.createShadowVolume=function(t,e,i){let o=t._granularity,n=t._ellipsoid,a=e(o,n),s=i(o,n);return new J({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:n,rotation:t._rotation,stRotation:t._stRotation,granularity:o,extrudedHeight:a,height:s,vertexFormat:r.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(J.prototype,{rectangle:{get:function(){return v(this._rectangle)||(this._rectangle=Y(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return v(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){let i=-e._stRotation;if(0===i)return[0,0,0,1,1,0];let o=t.computeEllipsePositions({center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,rotation:e._rotation,granularity:e._granularity},!1,!0).outerPositions,r=o.length/3,n=Array(r);for(let t=0;t<r;++t)n[t]=d.fromArray(o,3*t);let a=e._ellipsoid,s=e.rectangle;return l._textureCoordinateRotationPoints(n,i,a,s)}(this)),this._textureCoordinateRotationPoints}}});var q=J;export{q as a};